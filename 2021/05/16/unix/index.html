<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Cleo">
    <meta name="description" content="A personal blog based on github and hexo">
    <meta name="author" content="Cleo">
    
    <title>
        
            UNIX操作系统高级编程 |
        
        Keep Learning
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh"};
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Keep Learning
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">UNIX操作系统高级编程</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Cleo</span>
                        
                            <span class="author-label">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-05-16 23:53:53
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="UNIX环境高级编程"><a href="#UNIX环境高级编程" class="headerlink" title="UNIX环境高级编程"></a>UNIX环境高级编程</h1><h2 id="第1章-UNIX基础知识"><a href="#第1章-UNIX基础知识" class="headerlink" title="第1章 UNIX基础知识"></a>第1章 UNIX基础知识</h2><h3 id="1-1-Unix体系结构"><a href="#1-1-Unix体系结构" class="headerlink" title="1.1 Unix体系结构"></a>1.1 Unix体系结构</h3><ul>
<li>内核：一种软件，控制计算机硬件资源，提供程序运行环境</li>
<li>系统调用：内核的接口</li>
<li>shell，公用函数库</li>
<li>应用程序</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210510145922442.png" alt="image-20210510145922442"></p>
<h3 id="1-2-不带缓冲的I-O"><a href="#1-2-不带缓冲的I-O" class="headerlink" title="1.2 不带缓冲的I/O"></a>1.2 不带缓冲的I/O</h3><p>函数open、read、write、lseek以及close提供了不带缓冲的I/O。这些函数都使用<strong>文件描述符</strong>。</p>
<h4 id="1-2-1-文件描述符"><a href="#1-2-1-文件描述符" class="headerlink" title="1.2.1 文件描述符"></a>1.2.1 文件描述符</h4><p><code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>为两个宏，值分别为0、1，表示标准输入和标准输出的文件描述符。</p>
<h4 id="1-2-1-read"><a href="#1-2-1-read" class="headerlink" title="1.2.1 read"></a>1.2.1 read</h4><p>read函数返回读取的字节数，当到达文件的尾端时，read返回0；如果发生了一个读错误，read返回-1。</p>
<h3 id="1-3-标准I-O"><a href="#1-3-标准I-O" class="headerlink" title="1.3 标准I/O"></a>1.3 标准I/O</h3><p>标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需担心如何选取最佳的缓冲区大小。使用标准I/O还简化了对输入行的处理，如fgets读取一个完整的行，而read函数读取指定的字节数。</p>
<p><code>stdin</code>、<code>stdout</code>、getc、putc等均在<code>stdio.h</code>中定义。</p>
<h3 id="1-4-进程控制"><a href="#1-4-进程控制" class="headerlink" title="1.4 进程控制"></a>1.4 进程控制</h3><p>程序（program）是一个存储在磁盘上的某个目录中的可执行文件。程序的执行实例被称为进程（process）。每个进程都有一个唯一的数字标识符，称为进程ID，进程ID总是一个非负整数。</p>
<ul>
<li>getpid()</li>
<li>getgid()</li>
<li>fork()</li>
<li>waitpid()</li>
<li>exec()</li>
</ul>
<p>一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性，它们能访问同一存储区，因此各个线程在访问共享数据时需要采取同步措施以避免不一致性。</p>
<h3 id="1-5-出错处理"><a href="#1-5-出错处理" class="headerlink" title="1.5 出错处理"></a>1.5 出错处理</h3><p>头文件errno.h中定义了<code>errno</code>以及可以赋与它的各种常量，这些常量都以字符E开头。当UNIX系统函数出错时，通常会返回一个负值，而且整形变量<code>errno</code>通常被设置为具有特定信息的值。</p>
<p>对于<code>errno</code>应当注意两条规则：</p>
<ul>
<li>如果没有出错，其值不会被例程清除。因此，仅当函数的返回值指明出错时，才检验其值。</li>
<li>任何函数都不会将<code>errno</code>值设置为0，而且errno.h中定义的所有常量都不为0。</li>
</ul>
<p>C标准定义了2个函数，它们用于打印出错信息：</p>
<p>1 - strerror</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure>
<p>strerror函数将errnum（通常就是errno值）映射为一个出错消息字符串，并且返回此字符串的指针。</p>
<p>2 - perror</p>
<p>perror函数基于errno的当前值，在标准错误上产生一条出错消息，然后返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-时间值"><a href="#1-6-时间值" class="headerlink" title="1.6 时间值"></a>1.6 时间值</h3><p>Unix系统使用过两种不同的时间值：</p>
<ol>
<li><p>日历时间，即UTC，格林尼治标准时间，以秒为单位，可以用于记录文件的最近修改时间，对应类型为<code>time_t</code>。</p>
</li>
<li><p>进程时间，也被称为CPU时间，用以度量进程使用的<strong>中央处理器资源</strong>。进程时间以时钟滴答计算。对应数据类型为<code>clock_t</code>。</p>
</li>
</ol>
<p>当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值：</p>
<ol>
<li><p>时钟时间，是进程运行的时间总量，其值与系统中同时运行的进程数有关。</p>
</li>
<li><p>用户CPU时间，是执行用户指令所用的时间量。</p>
</li>
<li><p>系统CPU时间，是该进程执行内核程序所经历的时间。</p>
</li>
</ol>
<p>用户CPU时间和系统CPU时间之和常被称为<strong>CPU时间</strong>。</p>
<p>time命令用于获取任一进程的时钟时间、用户时间和系统时间。</p>
<h3 id="1-7-信号"><a href="#1-7-信号" class="headerlink" title="1.7 信号"></a>1.7 信号</h3><p>可以使用kill函数产生信号，在一个进程中调用此函数就可以向另一个进程发送一个信号。当然，这样做也有些限制：当向一个进程发送信号时，我们必须是那个进程的所有者或者是超级用户。</p>
<h2 id="第3章-文件I-O"><a href="#第3章-文件I-O" class="headerlink" title="第3章 文件I/O"></a>第3章 文件I/O</h2><h3 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h3><p>本章内容：</p>
<ul>
<li><p>文件I/O。本章介绍的I/O函数通常被称为不带缓冲的I/O（unbuffered I/O），所谓不带缓冲指的是每个read和write都调用内核中的一个系统调用。</p>
<ul>
<li>open</li>
<li>read</li>
<li>write</li>
<li>lseek</li>
<li>close</li>
</ul>
</li>
<li><p>多个进程间共享资源。</p>
<ul>
<li>dup</li>
<li>fcntl</li>
<li>sync</li>
<li>fsync</li>
<li>ioctl</li>
</ul>
</li>
</ul>
<h3 id="3-2-文件描述符"><a href="#3-2-文件描述符" class="headerlink" title="3.2 文件描述符"></a>3.2 文件描述符</h3><p>对内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。</p>
<ul>
<li>文件描述符0——标准输入， <code>STDIN_FILENO</code></li>
<li>文件描述符1——标准输出， <code>STDOUT_FILENO</code></li>
<li>文件描述符2——错误输出， <code>STDERR_FILENO</code></li>
</ul>
<p>上述三个符号常量存储在头文件<code>unistd.h</code>中。</p>
<h3 id="3-3-函数open和openat"><a href="#3-3-函数open和openat" class="headerlink" title="3.3 函数open和openat"></a>3.3 函数open和openat</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/*mode_t mode */</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回文件描述符；若出错，返回-1。</p>
<p><code>...</code>表示该函数的余下参数的数量及类型是可变的。对于open函数而言，仅当创建新文件时才使用最后这个参数。</p>
<p>oflag:</p>
<ul>
<li>O_RDONLY：只读</li>
<li>O_WRONLY：只写</li>
<li>O_RDWR：可读可写</li>
<li>O_EXEC：只执行打开</li>
<li>O_SEARCH：只搜索打开（应用于目录）</li>
</ul>
<p>上述五个常量中必须指定一个且只能指定一个，下列常量则是可选的：</p>
<ul>
<li>O_APPEND：追加模式</li>
<li>O_CREATE：若文件不存在则创建它，此时需要指定mode</li>
<li><p>O_TRUNC：文件存在，且为只写或读-写成功打开，则将其长度截断为0，于O_APPEND对应。</p>
</li>
<li><p>O_DIRECTORY：如果path引用的不是目录，则出错</p>
</li>
<li>O_EXCL：如果同时指定了O_CRAET，而文件已经存在，则出错。可以用于测试一个文件是否存在，如果不存在则创建，这使测试和创建两者成为一个原子操作。</li>
</ul>
<ul>
<li>O_SYNC：使每次write等待物理I/O操作完成，包括由该write操作引起的文件属性更新所需的I/O。</li>
<li>O_DSYNC：使每次write要等待物理I/O操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需等待文件属性被更新。</li>
<li>O_RSYNC：使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作都完成。</li>
</ul>
<ul>
<li>O_CLOEXEC：把FD_CLOEXEC常量设置为文件描述符标志</li>
<li>O_NOCTTY：如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端。</li>
<li>O_NOFOLLOW：如果path是一个链接符号，则出错。</li>
<li>O_NONBLOCK：如果path是一个FIFO、一个快特殊文件或者一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞模式。</li>
<li>O_TTY_INIT：如果打开一个还未打开的终端设备，设置非标准termios参数值，使其符合Single UNIX Specification。</li>
</ul>
<p>关于openat的三种情况：</p>
<ol>
<li>如果path为绝对路径，则fd没有任何作用，传任何值都可以，此时与open函数无异。</li>
<li>如果path为相对路径，而fd为<code>AT_FDCWD</code>，则指定目录为当前目录。</li>
<li>如果path为相对路径，fd不为<code>AT_FDCWD</code>，则需给fd传入指定的目录的文件描述符。</li>
</ol>
<p>TOCTTOU（time-of-check-to-time-of-use），如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的，因为两个基于文件的函数调用，在两个函数调用之间文件可能改变了。</p>
<h3 id="3-4-函数create"><a href="#3-4-函数create" class="headerlink" title="3.4 函数create"></a>3.4 函数create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回一个<strong>只写打开</strong>的文件描述符；若出错，返回-1。</p>
<p>此函数等效于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure>
<p>create只能以只写方式打开所创建的文件，要想是写可读可写必须用open函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure>
<h3 id="3-5-函数close"><a href="#3-5-函数close" class="headerlink" title="3.5 函数close"></a>3.5 函数close</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，则返回-1。</p>
<h3 id="3-6-函数lseek"><a href="#3-6-函数lseek" class="headerlink" title="3.6 函数lseek"></a>3.6 函数lseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回新的文件偏移量；若出错，返回-1。</p>
<p>按系统默认情况，当打开一个文件时，除非指定O_APPEND选项，否则该偏移量被设置为0。</p>
<p>whence的三种情况：</p>
<ul>
<li>whence 为 SEEK_SET，则将文件偏移量设置为距文件开始处offset字节。</li>
<li>whence 为 SEEK_CUR，则将文件偏移量设置为当前值加offset，offset可为正或负。</li>
<li>whence 为 SEEN_END，则将文件偏移量设置为文件长度加offset，offset可正可负。</li>
</ul>
<p>确定打开文件的当前偏移量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> currpos;</span><br><span class="line">currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure>
<p>这种方法也可以用来测试所涉及的文件是否可以设置偏移量，如果文件描述符指向的是一个管道、FIFO或网络套接字，则lseek返回-1，并将errno设置为ESPIPE。</p>
<p>在比较lseek的返回值时应当谨慎，不要测试它是否小于0，而要测试它是否等于<code>-1</code>。</p>
<p>lseek仅将当前的文件描述符记录在内核中，它并<strong>不引起任何I/O操作</strong>。然后，该偏移量用于下一个读或写操作。</p>
<p>文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位超出文件尾端后写时，对于新写的数据需要分配磁盘快，但对于原文件尾和新开始写位置之间的部分则不需要分配磁盘块。</p>
<p>命令<code>od -c</code>以字符方式查看文件内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210511090536433.png" alt="image-20210511090536433"></p>
<h3 id="3-7-函数read"><a href="#3-7-函数read" class="headerlink" title="3.7 函数read"></a>3.7 函数read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>
<p>fd为文件描述符，buf为缓冲区，nbytes为要求读的字节数。返回读到的字节数，若到达文件尾，返回0；若出错，返回-1。</p>
<h3 id="3-8-函数write"><a href="#3-8-函数write" class="headerlink" title="3.8 函数write"></a>3.8 函数write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyts)</span></span>;</span><br></pre></td></tr></table></figure>
<p>fd为文件描述符，buf为包含数据的缓冲区，nbytes为要写入的字节数。若成功，返回已经写的字节数；若出错，返回-1。</p>
<p>返回值通常与nbytes一致，否则表示出错。write出错的一个常见原因时磁盘已写满，或者超过了一个给定进程的文件长度限制。</p>
<h3 id="3-9-I-O的效率"><a href="#3-9-I-O的效率" class="headerlink" title="3.9 I/O的效率"></a>3.9 I/O的效率</h3><p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210511091215956.png" alt="image-20210511091215956"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">str2int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> n, buff_size;</span><br><span class="line">    buff_size = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(buff_size * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buff_size);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, buff_size)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (but != <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="built_in">free</span>(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">str2int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(str), n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210511092423651.png" alt="image-20210511092423651"></p>
<h3 id="3-10-文件共享"><a href="#3-10-文件共享" class="headerlink" title="3.10 文件共享"></a>3.10 文件共享</h3><p>内核使用3种数据结构表示打开文件：</p>
<ol>
<li>每个进程在<strong>进程表</strong>中都有一个记录项（<strong>进程表项</strong>），记录项中包含一张<strong>打开文件描述符表</strong>，可将其视为一个矢量，每个描述符占用一项。每一项包含：<ol>
<li>文件描述符标志</li>
<li>指向一个<strong>文件表项</strong>的指针</li>
</ol>
</li>
<li>内核为所有打开文件维持一张<strong>文件表</strong>，每个文件表项包含：<ol>
<li>文件状态标志</li>
<li>当前文件偏移量</li>
<li>指向该文件<strong>v节点表项</strong>的指针</li>
</ol>
</li>
<li>每个打开文件都有一个v节点（v-node）结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的<strong>i节点</strong>（i-node，索引节点）。i-node包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210511094237554.png" alt="image-20210511094237554"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210511094302763.png" alt="image-20210511094302763"></p>
<p>我们假定第一个进程在文件描述符3上打开该文件，而另一个进程在文件描述符4上打开该文件。打开该文件的每个进程都获得各自的一个文件表项，但对一个给定的文件只有一个v节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使每个进程都有它自己的对该文件的当前偏移量。</p>
<ul>
<li>在完成每个write后，在文件表项中的当前偏移量即增加所写入的字节数。如果这导致当前文件偏移量超过了当前文件长度，则将i节点表项中的<strong>当前文件长度</strong>设置为当前文件偏移量（也就是该文件加长了）。</li>
<li>如果使用O_APPEND标志打开一个文件，则相应标志也被设置到文件表项的文件标志状态中。每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。这就使得每次写入的数据都追加到文件的当前尾端处。</li>
<li>若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置成i节点表项中的当前文件长度。（注意，这与用O_APPEND标志打开文件是不同的。）</li>
<li>lseek函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作。</li>
</ul>
<p>可能有多个文件描述符项指向同一个文件表项，如fork后父子进程各自的每一个打开文件描述符共享同一个文件表项。</p>
<h3 id="3-11-原子操作"><a href="#3-11-原子操作" class="headerlink" title="3.11 原子操作"></a>3.11 原子操作</h3><p>一个原子操作的例子：两个进程打开同一个文件，都先调用lseek，再调用write写文件，可能会导致覆盖。</p>
<p>函数pread和pwrite：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回值为读到的字节数，若已到达文件尾端则返回0；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回已写的字节数；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> bytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用pread相当于调用lseek后调用read，但pread是一个原子操作，即：</p>
<ul>
<li>调用pread时，无法中断其定位和读操作。</li>
<li>不更新当前文件的偏移量。</li>
</ul>
<p>调用pwrite相当于调用lseek后调用write，但同样，是一个原子操作。</p>
<p>另一个原子操作的例子：判断一个文件是否存在，若存在，则open失败；若不存在，则创建该文件。open提供了oflag的O_EXCL和O_CREAT，使得这两个操作成为一个原子操作。如果没有O_EXCL，则可能要这样写代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(pathname, O_WRONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = creat(path, mode)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">&quot;creat error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码带来的问题是，如果在open和creat之间，另一个进程创建了该文件，就会出现问题。</p>
<p>一般而言，<strong>原子操作</strong>（atomic operation）指的是由多步组成的一个操作。如果该操作原子的执行，则<strong>要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集</strong>。</p>
<h3 id="3-12-函数dup和dup2"><a href="#3-12-函数dup和dup2" class="headerlink" title="3.12 函数dup和dup2"></a>3.12 函数dup和dup2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span></span><br></pre></td></tr></table></figure>
<p>上面两个函数都可用来复制一个现有的文件描述符。若成功，返回新的文件描述符；若出错，返回-1。</p>
<p>由dup返回的新文件描述符一定是当前可用文件描述符中的最小值。对于dup2，可以用fd2参数指定新描述符的值。如果fd2已经打开，则先将其关闭；如果fd等于fd2，则dup2返回fd2，而不关闭它。否则，fd2的FD_CLOEXEC文件描述符标志就被清除，这样fd2在进程调用exec时是打开状态。</p>
<p>这些函数返回的新文件描述符与参数fd共享一个文件表项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210511100140948.png" alt="image-20210511100140948"></p>
<p>每个文件描述符都有它自己的一套文件描述符标志。</p>
<h3 id="3-13-函数-sync、fsync-和-fdatasync"><a href="#3-13-函数-sync、fsync-和-fdatasync" class="headerlink" title="3.13 函数 sync、fsync 和 fdatasync"></a>3.13 函数 sync、fsync 和 fdatasync</h3><p>延迟写：传统的Unix系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都通过缓冲区进行。<strong>当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘</strong>。通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据写入磁盘。为了保证磁盘上实际文件系统与缓冲区中内容的一致性，Unix系统提供了sync、fsync和fdatasync三个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>fsync、fdatasync若成功，返回0；若出错，返回-1。</p>
<ul>
<li>sync只是<strong>将所有修改过的块缓冲区排入队列，然后就返回，它并不等待实际写磁盘操作结束</strong>。通常，称为update的系统守护进程周期性地调用（一般每隔30秒）sync函数，这就保证了定期冲洗（flush）内核的块缓冲区。命令sync(1)也调用sync函数。sync对所有文件打开的文件描述符执行。</li>
<li>fsync函数只是对由文件描述符fd指定的一个文件起作用，并且<strong>等待写磁盘操作结束才返回</strong>。fsync可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。</li>
<li>fdatasync类似于fsync，但它<strong>只影响文件的数据部分</strong>。而除数据外，<strong>fsync还会同步更新文件的属性</strong>。</li>
</ul>
<h3 id="3-14-函数fcntl"><a href="#3-14-函数fcntl" class="headerlink" title="3.14 函数fcntl"></a>3.14 函数fcntl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>fcntl函数可以改变已经打开文件的属性。若成功，则依赖cmd；若出错，返回-1。</p>
<p>fcntl函数有以下五种功能：</p>
<p>(1) 复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC）</p>
<p>(2) 获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD）</p>
<p>(3) 获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL）</p>
<p>(4) 获取/设置异步I/O所有权（cmd = F_GETOWN 或 F_SETOWN）</p>
<p>(5) 获取/设置记录锁 （cmd = F_GETLK、F_SETLK 或 F_SETLKW）</p>
<p>11种cmd中的8种：</p>
<ul>
<li><p>F_DUPFD ：复制文件描述符fd。新文件描述符作为函数值返回。它是尚未打开的各描述符中大于或等于第3个参数值（取整）中各值的最小值。新描述符与fd共享同一文件表项。但是新描述符有它自己的一套文件描述符标志。</p>
</li>
<li><p>F_DUPFD_CLOEXEC ：复制文件描述符，设置与新描述符关联的FD_CLOEXEC文件描述符标志的值，返回新文件描述符。</p>
</li>
<li><p>F_GETFD ：对应于fd的<strong>文件描述符标志</strong>作为函数值返回。当前只定义了一个文件描述符标志FD_CLOEXEC。</p>
</li>
<li><p>F_SETFD ：对于fd设置文件描述符标志。新标志值按第3个参数（取为整型值）设置。</p>
</li>
<li><p>F_GETFL ：对应于fd的<strong>文件状态标志</strong>作为函数返回值返回。文件状态标志参考3.3节open函数的第2个参数。遗憾的是，5个访问标志（O_RDONLY、O_WRONLY、O_RDWR、O_EXEC以及O_SEARCH）并不各占1位（这5个值互斥，一个文件的访问方式只能取这5个值之一）。因此首先必须用屏蔽字O_ACCMODE取得访问方式位，然后将结果与这5个值中的每一个相比较。</p>
</li>
<li><p>F_SETFL ：将文件状态标志设置为第3个参数的值（取为整型值）。可以更改的几个标志是：O_APPEND、O_NOBLOCK、O_SYNC、O_DSYNC、O_RSYNC、O_FSYNC、O_ASYNC。</p>
</li>
<li><p>F_GETOWN ：获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID。</p>
</li>
<li><p>F_SETOWN ：设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的arg指定一个进程ID，负的arg表示等于arg绝对值的一个进程组ID。</p>
</li>
</ul>
<p>关于复制文件描述符，前面3.12节介绍了dup和dup2两个函数。实际上，执行<code>dup(fd);</code>等效于执行<code>fcntl(fd, F_DUPFD, 0);</code>，而调用<code>dup2(fd, fd2);</code>相当于执行了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br><span class="line">fcntl(fd, F_DUPFD, fd2);</span><br></pre></td></tr></table></figure>
<p>但是并不完全等效，dup2是一个原子操作，而且dup2和fcntl有一些不同的errno。</p>
<p>在修改文件描述符标志或文件状态标志时必须谨慎，先要获得现在的标志值，然后按照期望修改它，最后设置新标志值。不能只是执行F_SETFD或F_SETFL命令，这样会关闭以前设置的标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 先获取之前的文件标志状态 */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* turn on flags */</span></span><br><span class="line">    val |= flags;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;fcntl F_SETFL error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fl2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* get previous flags */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* turn off flags */</span></span><br><span class="line">    val &amp;= ~flags;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;fcntl F_SETEL error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开状态用<code>val |= flags;</code>，关闭状态用<code>val &amp;= ~flags;</code>。</p>
<p>当使用上述函数打开O_SYNC时，write需要等待缓冲区中的数据写入磁盘块完成后返回，增加了程序执行的时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210511103534471.png" alt="image-20210511103534471"></p>
<p>在这里需要注意，设置文件状态标志位O_SYNC与sync函数的作用不是一样的，前者等待物理I/O操作完整再返回，而后者则是将缓冲块排入队列就返回，不等待物理操作完成。</p>
<p>O_DSYNC与O_SYNC的区别是前者不等待文件属性更新完就返回。</p>
<p>sync函数与fsync函数的区别是fsync只针对某个特定的文件描述符，等待物理I/O完成。</p>
<h3 id="3-15-函数ioctl"><a href="#3-15-函数ioctl" class="headerlink" title="3.15 函数ioctl"></a>3.15 函数ioctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>         <span class="comment">/* System V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span>    <span class="comment">/* BSD and Linux */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若出错，返回-1；若成功，返回其他值。ioctl函数一直是I/O操作的杂物箱。不能用本章中其他函数表示的I/O操作通常都能用ioctl表示。终端I/O是使用ioctl最多的地方。通常还要用到头文件termios.h。</p>
<p>嵌入式常用。</p>
<h3 id="3-16-dev-fd"><a href="#3-16-dev-fd" class="headerlink" title="3.16 /dev/fd"></a>3.16 /dev/fd</h3><p>较新的系统都提供名为/dev/fd的目录，其目录项是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符n（假定描述符n是打开的）。</p>
<p>在下列函数调用中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/df/0&quot;</span>, mode);</span><br></pre></td></tr></table></figure>
<p>大多数系统忽略它所指定的mode，而另外一些系统则要求mode必须是所引用的文件（在这里是标准输入）初始打开时所使用的打开模式的一个子集。因为上面的打开等效于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>所以描述符fd和0共享同一文件表项。例如，若描述符0先前被打开为只读，那么我们也只能对fd进行读操作。即使系统忽略打开模式，而且下列调用是成功的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/fd/0&quot;</span>, O_RDWR);</span><br></pre></td></tr></table></figure>
<p>我们仍然不能对fd进行写操作。</p>
<blockquote>
<p>Linux实现中的/dev/fd是个例外。它把文件描述符映射成指向底层物理文件的符号链接。例如，当打开/dev/fd/0时，事实上正在打开与标准输入关联的文件，因此返回的新文件描述符的模式与/dev/fd文件描述符的模式其实并不相关。</p>
</blockquote>
<p>某些系统提供文件/dev/stdin、/dev/stdout 和 /dev/stderr，这些等效于/dev/fd/0、/dev/fd/1和/dev/fd/2</p>
<p>作为命令行参数的<code>-</code>特指标准输入或输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 - file3 | lpr</span><br></pre></td></tr></table></figure>
<p>cat先读file1，然后读其标准输入（即filter file2的输出），然后读file3，如果支持/dev/fd，可以删除cat对<code>-</code>的特殊处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 /dev/fd/0 file3 | lpr</span><br></pre></td></tr></table></figure>
<h3 id="3-17-练习"><a href="#3-17-练习" class="headerlink" title="3.17 练习"></a>3.17 练习</h3><p>3.6 如果使用追加标志打开一个文件以便读、写，能否仍用lseek在任一位置开始读？能否用lseek更新文件中任一部分的数据？请编写一段程序验证。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：可以从任一位置开始读，但不能从任一位置开始写。写需要O_WROLY或O_RDWR，单独的O_APPEND不具有写的功能。</span><br></pre></td></tr></table></figure>
<h2 id="第4章-文件和目录"><a href="#第4章-文件和目录" class="headerlink" title="第4章 文件和目录"></a>第4章 文件和目录</h2><h3 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h3><p>本章将描述文件系统的其他特征和文件的性质。</p>
<h3 id="4-2-函数stat、fstat、fstatat和lstat"><a href="#4-2-函数stat、fstat、fstatat和lstat" class="headerlink" title="4.2 函数stat、fstat、fstatat和lstat"></a>4.2 函数stat、fstat、fstatat和lstat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>           <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这四个函数在函数执行成功时返回0，出错时返回-1。</p>
<ul>
<li><p>一旦给出pathname，stat函数将返回与此命名文件有关的信息结构。</p>
</li>
<li><p>fstat函数获得已在文件描述符fd上打开文件的有关信息。</p>
</li>
<li><p>lstat类似于stat，但是命名的文件是一个符号链接时，lstat返回该符号链接的有关信息，而不是由该符号链接引用的文件信息。</p>
</li>
<li><p>fstatat函数为一个相对于当前打开目录（由dirfd参数指向）的路径名返回文件统计信息。flags参数控制着是否跟随着一个符号链接。当<code>AT_SYMLINK_NOFOLLOW</code>标志被设置时，fstatat不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返回的是符号链接所指向的实际文件信息。如果fd被设置为<code>AT_FDCWD</code>，并且pathname参数是一个相对路径名，fstatat会计算相对于当前目录的pathname参数。如果pathname是一个绝对路径，fd参数就会被忽略。在这两种情况下，根据flag 的取值，fstatat的作用就跟stat或lstat一样。</p>
</li>
</ul>
<p>参数buf是一个指针，指向的结构为stat，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* File type and mode (permission) */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond</span></span><br><span class="line"><span class="comment">       precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">       For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>stat函数用的最多的地方可能就是<code>ls -l</code>命令。</p>
<h3 id="4-3-文件类型"><a href="#4-3-文件类型" class="headerlink" title="4.3 文件类型"></a>4.3 文件类型</h3><p>文件类型包括如下几种：</p>
<ul>
<li>普通文件（regular file）</li>
<li>目录文件（directory file）：这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有<strong>内核</strong>可以直接写目录文件。</li>
<li>块特殊文件（block special file）：提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。</li>
<li>字符特殊设备（character special file）：提供对设备的不带缓冲访问，每次访问长度可变。<strong>系统中的所有设备要么是字符特殊文件，要么是块特殊设备</strong>。</li>
<li>FIFO：用于进程间通信，有时也称为命名管道（named pipe）。</li>
<li>套接字（socket）：用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。</li>
<li>符号链接（symbolic link）：指向另一个文件。</li>
</ul>
<p><em>文件类型信息</em>包含在stat结构中的st_mode成员中。下列宏可以用于st_mode类型的参数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512092957111.png" alt="image-20210512092957111" style="zoom:67%;" /></p>
<p>下列宏可以用于stat结构来确定IPC（进程间通信）对象：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512093045164.png" alt="image-20210512093045164" style="zoom:67%;" /></p>
<h3 id="4-4-设置用户ID和设置组ID"><a href="#4-4-设置用户ID和设置组ID" class="headerlink" title="4.4 设置用户ID和设置组ID"></a>4.4 设置用户ID和设置组ID</h3><p>与一个进程相关联的ID有6个或更多，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512094448990.png" alt="image-20210512094448990" style="zoom: 80%;" /></p>
<ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们。<span style="color: red">个人理解为启动该进程的用户ID、组ID就是实际用户ID和实际组ID。</span></li>
<li>有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。<span style="color: red">设置用户ID和设置组ID是两个特殊的权限位，用于为启动某进程的用户或用户组设置在运行时与文件所属用户和用户组所拥有的权限，对应文件权限标志<code>s</code>。</span></li>
</ul>
<p><span style="color: blue">通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID。</span></p>
<p>每个文件有一个<strong>所有者</strong>和<strong>组所有者</strong>，所有者由stat结构中的st_uid指定，组所有者由st_gid指定。</p>
<p>文件模式字中的特殊两位：设置用户ID（set-user-ID）位和设置组ID（set-group-ID）位。</p>
<ul>
<li>设置用户ID（set-user-ID）位：当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID（st_uid）。</li>
<li>设置用户组ID（set-group-ID）位：当执行此文件时，将进程的有效用户ID设置为文件的组所有者ID（st_gid）。</li>
</ul>
<p>例如，若文件的所有者是超级用户，而且设置了该文件的设置用户ID位，那么当该程序文件由一个进程执行，该进程具有超级用户权限，不管执行此文件的进程的实际用户ID是什么。</p>
<p>一个最简单的例子，用户可以使用passwd命令修改自己的密码。该程序是一个设置用户ID程序，因为该程序应能将用户的新口令写入文件中（一般是/etc/passwd或/etc/shadow），该文件的所有这为root，且这个文件的权限一般为<code>-rw-r--r--</code>，其他用户没有写的权限，所以需要使用设置用户ID功能才能是普通用户使用passwd命令改密码。</p>
<p><span style="color: red">设置用户ID位及设置组ID位都包含在文件st_mode值中，分别使用S_ISUID和S_ISGID进行<strong>位与</strong>测试可以检测出是否有对应权限。</span></p>
<h3 id="4-5-文件访问权限"><a href="#4-5-文件访问权限" class="headerlink" title="4.5 文件访问权限"></a>4.5 文件访问权限</h3><p>st_mode值也包含了对文件的访问权限位。每个文件有9个访问权限位，可将它们分成3类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512095237126.png" alt="image-20210512095237126"></p>
<p>用户是指文件所有者（owner），组指文件所有组(group)，其他指其他用户（other）。chmod命令可以修改这9个权限位。</p>
<ul>
<li><p>我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有<strong>执行权限</strong>。这就是为什么对于目录执行权限位常被称为搜索位的原因。</p>
<p>注意，对于目录的读权限和执行权限的意义是不同的。读权限允许我们读目录，获得在该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，对该目录的<strong>执行权限</strong>使我们可以<strong>通过</strong>该目录。</p>
</li>
<li><p>对于一个文件的<strong>读权限</strong>决定了我们是否能打开现有文件进行<strong>读操作</strong>。这与open函数的O_RDONLY和O_RDWR标志相关。</p>
</li>
<li><p>对于一个文件的<strong>写权限</strong>决定了我们是否能打开现有文件进行<strong>写操作</strong>。这与open函数的O_WRONLY和O_RDWR标志相关。</p>
</li>
<li><p>为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有<strong>写权限</strong>。</p>
</li>
<li><p>为了在一个目录中创建一个新文件，必须对该目录具有<strong>写权限</strong>和<strong>执行权限</strong>。</p>
</li>
<li><p>为了删除一个现有文件，必须对<strong>包含该文件的目录</strong>具有<strong>写权限</strong>和<strong>执行权限</strong>。对该文件本身则<strong>不需要</strong>有读、写权限。</p>
</li>
<li><p>如果用7个exec函数中的任何一个执行某个文件，都必须对该文件具有<strong>执行权限</strong>。该文件还必须是一个<strong>普通文件</strong>。</p>
</li>
</ul>
<p>文件所有者（st_uid）和（st_gid）是文件的性质，两个有效ID（有效用户ID和有效组ID）和附属组ID是进程的性质。</p>
<p>内核进行的测试具体如下：</p>
<ul>
<li>若进程的<strong>有效用户ID</strong>是0（超级用户），则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由。</li>
<li>若进程的<strong>有效用户ID</strong>等于文件的所有者ID（也就是进程拥有此文件），那么如果所有者适当的访问权限被设置，则允许访问；否则拒绝访问。</li>
<li>若进程的<strong>有效组ID</strong>或进程的附属组ID之一等于文件的组ID，那么如果组适当的访问权限被设置，则允许访问；否则拒绝访问。</li>
<li>若其他用户适当的访问权限位被设置，则允许访问；否则拒绝访问。</li>
</ul>
<h3 id="4-6-新文件和目录的所有权"><a href="#4-6-新文件和目录的所有权" class="headerlink" title="4.6 新文件和目录的所有权"></a>4.6 新文件和目录的所有权</h3><p>新文件的用户ID设置为进程的有效用户ID。关于组ID，POSIX.1允许实现选择下列之一作为新文件的组ID：</p>
<ol>
<li>新文件的组ID可以是进程的有效组ID</li>
<li>新文件的组ID可以是它所在目录的组ID</li>
</ol>
<h3 id="4-7-函数access和faccessat"><a href="#4-7-函数access和faccessat" class="headerlink" title="4.7 函数access和faccessat"></a>4.7 函数access和faccessat</h3><p>access和faccessat函数是按<strong>实际用户ID</strong>和<strong>实际组ID</strong>进行访问权限测试的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>           <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>两个函数若执行成功，返回值为0，失败返回-1。</p>
<p>即使一个进程可能已经通过设置用户ID或设置组ID以超级用户权限运行，它仍可能想验证其实际用户能否访问一个给定的文件。</p>
<p>测试文件是否已经存在，mode就为<code>F_OK</code>；否则，mode是图4-7中所列常量的按位或。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>R_OK</td>
<td>测试读权限</td>
</tr>
<tr>
<td>W_OK</td>
<td>测试写权限</td>
</tr>
<tr>
<td>X_OK</td>
<td>测试执行权限</td>
</tr>
</tbody>
</table>
</div>
<p>至于faccessat函数的fd参数和pathname参数，其用法和openat函数的fd参数和pathname一致。</p>
<p>flag参数可以用于改变faccessat的行为，如果flag设置为<code>AT_EACCESS</code>，访问检查用的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。</p>
<h3 id="4-8-函数umask"><a href="#4-8-函数umask" class="headerlink" title="4.8 函数umask"></a>4.8 函数umask</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> cmask)</span></span>;</span><br></pre></td></tr></table></figure>
<p>umask函数为进程设置文件模式<strong>创建屏蔽字</strong>，并<strong>返回之前的值</strong>。该函数是少数几个没有出错返回函数中的一个。参数cmask是由图4-6中列出的9个常量（S_IRUSR、S_IWUSR等）中的若干按位“或”构成的。在文件模式创建屏蔽字中为1的位，在文件mode中的相应位一定被关闭。</p>
<p>Unix系统的大多数用户从不处理他们的umask值。通常在登录时，由shell的启动文件设置一次，然后不再改变。尽管如此，当编写创建新文件的程序时，如果我们想确保指定的访问权限位已经激活，那么必须在进程运行时修改umask值。</p>
<p><strong>umask命令</strong></p>
<p>umask命令用于查看或显示被屏蔽的位的八进制或许可的权限，还可用于设置屏蔽位，以8进制表示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span></span><br><span class="line">022</span><br><span class="line">$ <span class="built_in">umask</span> -S</span><br><span class="line">u=rwx, g=rx, o=rx</span><br><span class="line">$ <span class="built_in">umask</span> 027</span><br><span class="line">$ <span class="built_in">umask</span> -S</span><br><span class="line">u=rwx, g=rx, o=</span><br></pre></td></tr></table></figure>
<h3 id="4-9-函数chmod、fchmod和fchmodat"><a href="#4-9-函数chmod、fchmod和fchmodat" class="headerlink" title="4.9 函数chmod、fchmod和fchmodat"></a>4.9 函数chmod、fchmod和fchmodat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>chmod、fchmod和fchmodat这3个函数使我们可以更改现有文件的访问权限。若执行成功，则返回0，执行失败则返回-1。flag参数可以用于改变fchmodat的行为，当设置了<code>AT_SYMLINK_NOFOLLOW</code>标志时，fchmodat并不会跟随符号链接。</p>
<p>为了改变一个文件的权限位，<strong>进程的有效用户ID必须等于文件的所有者ID，或该进程必须具有超级用户权限</strong>。参数mode时图4-11中所示常量的按位或。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512123036645.png" alt="image-20210512123036645"></p>
<p>chmod函数更新的只是i节点最近一次被更改的时间。按系统默认方式，<code>ls -l</code>列出的是最后修改文件内容的时间。</p>
<p>chmod函数在下列条件下自动清除两个权限位：</p>
<ul>
<li>Solaris等系统对用于普通文件的粘着位赋予了特殊含义，在这些系统上如果我们试图设置普通文件粘着位（S_ISVTX），而且又没有超级用户权限，那么mode中的粘着位自动被关闭。这意味着只有超级用户才能设置文件的粘着位。这样做的理由是防止恶意用户设置粘着位，由此影响系统性能。</li>
<li>新创建文件的组ID可能不是调用进程所属的组。新文件的组ID可能是父目录的组ID。特别地，如果新文件的组ID不等于进程的有效组ID或者进程附属组ID中的一个，而且进程没有超级用户权限，那么设置ID位会被自动关闭。这就防止了用户创建一个设置组ID文件，而该文件是由非该用户所属的组拥有的。</li>
</ul>
<h3 id="4-10-粘着位"><a href="#4-10-粘着位" class="headerlink" title="4.10 粘着位"></a>4.10 粘着位</h3><p>S_ISVTX。</p>
<h3 id="4-11-函数chown、fchown、fchownat和lchown"><a href="#4-11-函数chown、fchown、fchownat和lchown" class="headerlink" title="4.11 函数chown、fchown、fchownat和lchown"></a>4.11 函数chown、fchown、fchownat和lchown</h3><p>chown函数可用于更改文件的用户ID和组ID。如果两个参数owner或group中的任意一个是-1，则对应的ID不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure>
<p>四个函数的返回值：若成功，返回0；若出错，返回-1。</p>
<p>除了所引用的文件是符号链接外，这四个函数的操作类似。在符号链接情况下，lchown和fchownat（设置了<code>AT_SYMLINK_NOFOLLOW</code>标志）更改符号链接本身的所有者，而不是符号链接所指向的文件所有者。</p>
<p>超级用户可以更改文件的所有者和所有组，而有些系统支持任一用户更改他们所拥有的文件所有者。</p>
<h3 id="4-12-文件长度"><a href="#4-12-文件长度" class="headerlink" title="4.12 文件长度"></a>4.12 文件长度</h3><p>stat结构成员st_size表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。</p>
<p>对于普通文件，其文件长度可以是0，在开始读这种文件时，将得到文件结束符（EOF）。对于目录，文件长度通常是一个数（如16或512）的整数倍。对于符号链接，文件长度是指向的文件名中的实际字节数。</p>
<p>现今，大多数现代的UNIX系统提供字段st_blksize和st_blocks。前者是对文件I/O较合适的块长度，后者是所分配的实际512字节块块数。</p>
<h4 id="文件中的空洞"><a href="#文件中的空洞" class="headerlink" title="文件中的空洞"></a>文件中的空洞</h4><p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512132044857.png" alt="image-20210512132044857"></p>
<p>文件core的长度稍稍超过8MB，可是du命令报告该文件所使用的磁盘空间总量是272个512字节块（即139264字节）。很明显，此文件中有很多空洞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512132255994.png" alt="image-20210512132255994"></p>
<p>使用wc命令，可以看出正常的I/O操作读整个文件的长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512132333732.png" alt="image-20210512132333732"></p>
<p>如果使用cat复制这个文件，那么所有的这些空洞都会被填满，其中所有实际数据字节皆填写为0。</p>
<h3 id="4-13-文件截断"><a href="#4-13-文件截断" class="headerlink" title="4.13 文件截断"></a>4.13 文件截断</h3><p>在打开文件时使用O_TRUNC标志截断为0是一个特例。为了截断文件，可以使用下列函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若失败，返回-1。</p>
<p>这两个函数将现有文件截断为length。若原来的文件长度大于length，则截断后大于length的部分无法访问。若原来问价你的长度小于length，则截断后文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0（也就是可能在文件中创建了一个空洞）。</p>
<h3 id="4-14-文件系统"><a href="#4-14-文件系统" class="headerlink" title="4.14 文件系统"></a>4.14 文件系统</h3><p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512141454390.png" alt="image-20210512141454390"></p>
<p>我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统。i节点时固定长度的记录项，它包含有关文件的大部分信息。更仔细地观察一个柱面的i节点和数据块部分，可以看到下图所示情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512141628360.png" alt="image-20210512141628360"></p>
<ul>
<li><p>上图中，有两个目录项指向同一个i节点。每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除该文件（也可以释放该文件占用的数据块）。这就是为什么“解除一个文件的链接”操作并不总是意味着“释放该文件占用的磁盘块”的原因。这也是为什么删除一个目录项的函数被称为unlink而不是delete的原因。在stat结构中，链接计数包含在st_nlink成员中，其基本系统数据类型是nlink_t，这种链接类型称为<strong>硬链接</strong>。</p>
</li>
<li><p>另一种链接类型称为<strong>符号链接</strong>。符号链接文件的实际内容包含了该链接所指向的文件的名字。符号链接i节点中文件类型是S_IFLNK，于是系统知道这是一个符号链接。</p>
</li>
<li>i节点包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录项中：文件名和i节点编号。i节点编号的数据类型是ino_t。</li>
<li>因为目录项中的i节点编号指向同一文件系统中的相应i节点，一个目录项不能指向另一个文件系统的i节点。因此ln命令不能跨越文件系统。</li>
<li>当在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需构造一个指向现有i节点的新目录项，并删除老的目录项。链接计数不会改变。这就是mv命令的通常操作方式。</li>
</ul>
<p>上述时普通文件的链接计数的概念，对于目录文件的链接计数字段如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512143539155.png" alt="image-20210512143539155"></p>
<p>我们在当前目录下创建一个testdir目录。testdir目录的i节点的链接计数项为2，一个来自创建该目录的父目录，即当前工作目录，还有一个来自于testdir目录中的<code>.</code>。而当前工作目录的i节点的链接计数项至少为3，一个来自于其父目录，一个来自于当前目录下的<code>.</code>，还有一个来自testdir目录的<code>..</code>。注意，在父目录中每一个子目录都使该父目录的链接计数增加1。</p>
<h3 id="4-15-函数link、linkat、unlink、unlinkat和remove"><a href="#4-15-函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="4.15 函数link、linkat、unlink、unlinkat和remove"></a>4.15 函数link、linkat、unlink、unlinkat和remove</h3><p>创建一个指向现有文件的链接的方法是使用link函数或linkat函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回-1。</p>
<p>这两个函数创建一个新目录项newpath，它引用现有文件existingpath。如果newpath已经存在，则返回出错。只创建newpath中最后一个分量，路径中的其他部分应当已经存在。</p>
<p>linkat函数使用flag参数控制指向现有符号链接还是指向现有符号链接所指向的文件。（flag = AT_SYMLINK_FOLLOW说明指向符号链接指向的文件）。</p>
<p>为删除一个现有的目录项，可以调用unlink函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回-1。</p>
<p>这两个函数删除目录项，并将由pathname所引用的文件的链接计数减1。如果对该文件还有其他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不对该文件做任何更改。</p>
<p>只有当链接计数达到0时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——只要有进程打开了文件，其内容也不能删除。关闭一个文件时，内核首先检查打开该文件的进程个数，如果这个计数达到0，内核再去检查其链接计数；如果计数也是0，那么就删除该文件的内容。</p>
<p>unlinkat的flag参数给出一种方法，使调用进程可以改变unlinkat函数的默认行为。当<code>AT_REMOVEDIR</code>标志被设置时，unlinkat函数可以类似于rmdir一样删除目录。如果这个标志被清除，unlinkat与unlink执行同样的操作。</p>
<p>我们也可以使用remove函数解除对一个文件或目录的链接。对于文件，remove功能与unlink相同。对于目录，remove的功能与rmdir相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回-1。</p>
<h3 id="4-16-函数rename和renameat"><a href="#4-16-函数rename和renameat" class="headerlink" title="4.16 函数rename和renameat"></a>4.16 函数rename和renameat</h3><p>文件或目录可以用rename函数或renameat函数进行重命名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回-1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210512152722143.png" alt="image-20210512152722143"></p>
<h3 id="4-17-符号链接"><a href="#4-17-符号链接" class="headerlink" title="4.17 符号链接"></a>4.17 符号链接</h3><p>硬链接直接指向文件的i节点，且有以下限制：</p>
<ul>
<li>硬链接通常要求链接和文件位于同一文件系统中</li>
<li>只有超级用户才能创建指向目录的硬链接</li>
</ul>
<p>符号链接以及它指向的何种对象无文件系统的限制，任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中的另一位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210514150353762.png" alt="image-20210514150353762" style="zoom: 67%;" /></p>
<p>使用符号链接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都将返回出错，errno值为ELOOP。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210514151153998.png" alt="image-20210514151153998"></p>
<p>这样的循环很容易消除。因为unlink并不跟随符号链接，所以可以unlink文件foo/testdir。但是如果创建了一个构成这种循环的硬链接，那么就很难消除它。</p>
<p><code>ls</code>命令使用<code>-l</code>参数可以查看文件的较详细信息，包括符号链接，使用<code>-F</code>参数会在符号链接后加上<code>@</code>。</p>
<h3 id="4-18-创建和读取符号链接"><a href="#4-18-创建和读取符号链接" class="headerlink" title="4.18 创建和读取符号链接"></a>4.18 创建和读取符号链接</h3><p>可以使用symlink或symlinkat函数创建一个符号链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回-1。函数创建一个指向actualpath的新目录项sympath。<span style="color: red">在创建此符号链接时，并不要求actualpath已经存在。</span>并且，actualpath和sympath并不需要位于同一文件系统中。</p>
<p>symlinkat函数中的fd参数为已打开的文件描述符，使得sympath的路径相对于该文件描述符。如果sympath为绝对路径或fd设置为<code>AT_FDCWD</code>，则symlinkat与symlink等同。</p>
<p>由于open函数跟随符号链接，所以需要一种方法打开链接本身，并读该链接中的名字。readlink和readlinkat函数提供了这种功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br></pre></td></tr></table></figure>
<p>两个函数组合了open、read和close的所有操作。如果函数成功，则返回读入buf的字节数。出错返回-1。在buf中返回的符号链接的内容<strong>不以null字节终止</strong>。</p>
<h3 id="4-19-文件的时间"><a href="#4-19-文件的时间" class="headerlink" title="4.19 文件的时间"></a>4.19 文件的时间</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>例子</th>
<th>ls(1)选项</th>
</tr>
</thead>
<tbody>
<tr>
<td>st_atime</td>
<td>文件数据的最后访问时间</td>
<td>read</td>
<td>-u</td>
</tr>
<tr>
<td>st_mtime</td>
<td>文件数据的最后修改时间</td>
<td>write</td>
<td>默认</td>
</tr>
<tr>
<td>st_ctime</td>
<td>i节点状态的最后更改时间</td>
<td>chmod、chown</td>
<td>-c</td>
</tr>
</tbody>
</table>
</div>
<p>注意，修改时间（st_mtime）和状态更改时间（st_ctime）之间的区别。修改时间时文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。更改文件的访问权限、更改用户ID、更改连接数等都将影响到i节点，但这些操作并没有修改文件的内容。文件的内容与文件的状态信息是分开存访的，所以，除了要记录文件数据修改时间外，还需要记录状态更改时间。</p>
<p>注意，系统并不维护对一个i节点的最后一次访问时间，所以access和stat函数并不更改上述3个时间中的任意一个。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210514194111564.png" alt="image-20210514194111564"></p>
<h3 id="4-20-函数futimens、utimensat和utimes"><a href="#4-20-函数futimens、utimensat和utimes" class="headerlink" title="4.20 函数futimens、utimensat和utimes"></a>4.20 函数futimens、utimensat和utimes</h3><p>一个文件的<strong>访问</strong>和<strong>修改</strong>时间可以用以下几个函数更改。futimens和utimensat函数可以指定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；否则，返回-1。times数组第一个元素包含访问时间，第二个元素包含修改时间。这两个时间是日历时间，即从（1970年1月1日00:00:00）以来所经过的秒数。不足秒的部分用纳秒表示。</p>
<p>时间戳可以按下列4中方式之一进行指定：</p>
<ul>
<li>如果times参数是一个空指针，则访问时间和修改时间两者都设置成当前时间。</li>
<li>如果times参数指向两个timespce结构的数组，任一数组元素的tv_nsec字段的值为<code>UTIME_NOW</code>，相应的时间戳就设置为当前时间，忽略相应的tv_sec字段。</li>
<li>如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值为<code>UTIME_OMIT</code>，相应的时间戳保持不变，忽略相应的tv_sec字段。</li>
<li>如果times参数指向两个timespec结构的数组，且tv_nsec字段的值为既不是<code>UTIME_NOW</code>也不是<code>UTIME_OMIT</code>，在这种情况下，相应的时间戳设置为相应的tv_sec和tv_nsec字段的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">  	<span class="keyword">time_t</span> tv_sec;  <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span>   tv_nsec; <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>utimensat默认行为是跟随符号链接，如果将flag参数设置为<code>AT_SYMLINK_NOFOLLOW</code>标志，则符号链接本身的时间就会被修改（如果路径名是符号链接）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timeval times[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>utimes函数对路径名进行操作。timeval结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;  <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span>   tv_usec; <span class="comment">/* microsecnods */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>timeval结构的两个成员一个表示秒，一个表示微秒。timeval同样也是表示时间戳。<span style="color: red">调用utimes时，st_ctime字段会被自动更新。</span></p>
<h3 id="4-21-函数mkdir、mkdirat和rmdir"><a href="#4-21-函数mkdir、mkdirat和rmdir" class="headerlink" title="4.21 函数mkdir、mkdirat和rmdir"></a>4.21 函数mkdir、mkdirat和rmdir</h3><p>mkdir、mkdirat用于创建目录，rmdir用于删除目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功返回0，出错返回-1。这两个函数将创建一个新的空目录，<code>.</code>和<code>..</code>是自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。</p>
<p>常见的错误是指定与文件相同的mode（只指定读、写权限）。但是，对于目录通常至少要设置一个执行权限位，以允许访问该目录中的文件名。</p>
<p>rmdir函数可以删除一个空目录。空目录是只能包含<code>.</code>和<code>..</code>这两项的目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-22-读目录"><a href="#4-22-读目录" class="headerlink" title="4.22 读目录"></a>4.22 读目录</h3><p>对某个目录具有访问权限的任一用户都可以读该目录，但是，为了防止文件系统产生混乱，只有内核才能写该目录。一个目录的写权限位和执行权限位决定了在该目录中能否<strong>创建新文件</strong>以及<strong>删除文件</strong>，它们并不表示能否写目录本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回指针；若出错，返回NULL */</span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回指针；若在目录尾或出错，返回NULL */</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回与dp关联的目录中的当前位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>dirent结构体至少包含以下两个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ino_t</span> d_ino;       <span class="comment">/* i-node number */</span></span><br><span class="line"><span class="keyword">char</span>  d_name[];    <span class="comment">/* null-terminated filename */</span></span><br></pre></td></tr></table></figure>
<p>DIR结构是一个内部结构，上述7个函数用这个内部结构保存当前正在被读的目录的有关信息。</p>
<p>DIR结构由fdopendir创建时，readdir返回的第一项取决于传给fdopendir函数的文件描述符相关联的文件偏移量。</p>
<h3 id="4-23-函数chdir、fchdir和getcwd"><a href="#4-23-函数chdir、fchdir和getcwd" class="headerlink" title="4.23 函数chdir、fchdir和getcwd"></a>4.23 函数chdir、fchdir和getcwd</h3><p>进程调用chdir或fchdir函数可以更改当前工作目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回-1。</p>
<p>getcwd从当前目录开始，用<code>..</code>找到其上一级目录，然后读其目录项，直到该目录项中的i节点编号与工作目录i节点编号相同，这样就找到了其对应的文件名。按照这种方法逐层上移，直到遇到根，这样就得到了当前工作目录完整的绝对路径名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回buf；若出错，返回NULL。必须向该函数传递两个参数，一个是缓冲区地址buf，另一个是缓冲区长度size（以字节为单位）。该缓冲区必须有足够的长度以容纳绝对路径名再加上一个终止null字节，否则返回出错。</p>
<p>chdir跟随符号链接，但是getcwd沿目录树向上溯源时，并不了解某个目录由符号链接所指向。</p>
<h3 id="4-24-设备特殊文件"><a href="#4-24-设备特殊文件" class="headerlink" title="4.24 设备特殊文件"></a>4.24 设备特殊文件</h3><p>每个<strong>文件系统</strong>所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型dev_t。主设备号标识设备驱动程序，有时编码为与其通信的外设备板；次设备号标识特定的子设备。一个磁盘驱动器经常包含若干个文件系统。在同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但是次设备号却不同。</p>
<p>系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点。</p>
<p>只有字符特殊文件和块特殊文件才有st_rdev值。此值包含实际的设备号。</p>
<p>major与minor用于查看主、次设备号，是两个宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dev = %d/%d\n&quot;</span>, major(buf.st_dev), minor(buf.st_dev));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;rdev = %d/%d\n&quot;</span>, major(buf.st_rdev), minor(buf.st_rdev));</span><br></pre></td></tr></table></figure>
<h2 id="第5章-标准I-O库"><a href="#第5章-标准I-O库" class="headerlink" title="第5章 标准I/O库"></a>第5章 标准I/O库</h2><h3 id="5-1-引言"><a href="#5-1-引言" class="headerlink" title="5.1 引言"></a>5.1 引言</h3><p>标准I/O库处理很多细节，如缓冲区分配、以优化的块长度执行I/O等。这些处理使用户不必担心如何选择使用正确的块长度。</p>
<h3 id="5-2-流和FILE对象"><a href="#5-2-流和FILE对象" class="headerlink" title="5.2 流和FILE对象"></a>5.2 流和FILE对象</h3><p>第三章中的I/O操作通过打开文件得到文件描述符，进而对文件描述符进行后续I/O操作。标准I/O则是将文件与<strong>流</strong>相关联。</p>
<p>流的<strong>定向</strong>决定了所读写的字符是单字节还是多字节的。当一个流被创建时，它并没有定向。如果在一个未定向的流上使用多字节I/O函数，则将该流的定向设置为宽定向的。如果在一个未定向的流上使用单字节I/O函数，则将流的定向设置为单字节定向的。</p>
<p>有两个函数可以改变流的定向：freopen清除一个流的定向，fwide用于设置流的定向。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若流是宽定向的，返回正值；若流是字节定向的，返回负值；若流是未定向的，返回0。</p>
<p>mode参数：</p>
<ul>
<li>mode为正，fwide将试图使指定的流为宽定向的；</li>
<li>mode为负，fwide将试图使指定的流为字节定向的；</li>
<li>mode为0，不设置流的定向，返回流的定向。</li>
</ul>
<p>注意，fwide并不改变已经定向的流的定向。</p>
<h3 id="5-3-标准输入、标准输出和标准错误"><a href="#5-3-标准输入、标准输出和标准错误" class="headerlink" title="5.3 标准输入、标准输出和标准错误"></a>5.3 标准输入、标准输出和标准错误</h3><p>头文件stdio.h中定义：<code>stdin</code>、<code>stdout</code>、<code>stderr</code>。三个均为<code>FILE *</code>类型，即文件指针。</p>
<h3 id="5-4-缓冲"><a href="#5-4-缓冲" class="headerlink" title="5.4 缓冲"></a>5.4 缓冲</h3><p>标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数，它也对每个I/O流自动地进行缓冲管理，从而避免了应用程序需要考虑这一点所带来的麻烦。</p>
<p>标准I/O提供了3种类型的缓冲：</p>
<ul>
<li>全缓冲：在填满标准I/O缓冲区后才进行实际I/O操作。在缓冲区未满时，可使用fflush函数冲洗一个流，将缓冲区中的内容写到磁盘上。</li>
<li>行缓冲：当在输入和输出中遇到换行符或行缓冲区满时，标准I/O库执行I/O操作。任何时候只要通过标准I/O库要求从一个不带缓冲的流，或者一个行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流。</li>
<li>不带缓冲：不对字符进行缓冲存储。</li>
</ul>
<p>标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来。</p>
<p>ISO C要求下列缓冲特征：</p>
<ul>
<li>当且仅当标准输入和标准输出并不指向交互设备时，它们才是全缓冲的</li>
<li>标准错误决不会是全缓冲的</li>
</ul>
<p>很多系统默认使用下列类型的缓冲：</p>
<ul>
<li>标准错误是不带缓冲的</li>
<li>若是指向终端设备的流，则是行缓冲的；否则是全缓冲的</li>
</ul>
<p>对于一个给定的流，如果我们并不喜欢这些系统默认，则可调用下列两个函数中的一个更改缓冲类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *fp, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *fp, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回非0。这些函数必须要在对文件指针执行任何一个其他操作之前调用。</p>
<p>setbuf用于打开或关闭缓冲，若buf参数为NULL，则为不带缓冲。否则，参数buf必须指向一个长度为BUFSIZ的缓冲区，执行后流就是全缓冲的，但如果一个流与一个终端设备相关，那么也可能将其设置为行缓冲。</p>
<p>setvbuf可以精确设置所需的缓冲类型，mode参数：</p>
<ul>
<li>_IOFBF：全缓冲</li>
<li>_IOLBF：行缓冲</li>
<li>_IONBF：不带缓冲</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516132140722.png" alt="image-20210516132140722"></p>
<p>任何时候，我们都可强制冲洗一个流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回EOF。</p>
<h3 id="5-5-打开流"><a href="#5-5-打开流" class="headerlink" title="5.5 打开流"></a>5.5 打开流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *type, FILE *fp)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br></pre></td></tr></table></figure>
<p>三个函数若成功，返回文件指针；若出错，返回NULL。</p>
<ul>
<li>fopen打开路径名pathname为一个指定的文件流</li>
<li>freopen在一个指定的流上打开一个指定的文件，若该流已经打开，则先关闭该流。若流已经定向，则使用freopen清除该定向。</li>
<li>fdopen取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合。</li>
</ul>
<p>type参数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516132953737.png" alt="image-20210516132953737"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516133650170.png" alt="image-20210516133650170"></p>
<p>关闭流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：若成功，返回0；若出错，返回EOF。在该文件被关闭之前，冲洗缓冲区中的输出数据。缓冲区中的任何输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓冲区，则释放此缓冲区。</p>
<h3 id="5-6-读和写流（每次一个字符）"><a href="#5-6-读和写流（每次一个字符）" class="headerlink" title="5.6 读和写流（每次一个字符）"></a>5.6 读和写流（每次一个字符）</h3><p>一旦打开了流，则可在3种不同类型的<strong>非格式化I/O</strong>中进行选择，对其进行读、写操作：</p>
<ul>
<li>每次一个字符：getc(), fgetc(), getchar()</li>
<li>每次一行：fgets(), fputs()</li>
<li>直接I/O：fread(), fwrite()。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。</li>
</ul>
<h4 id="1-输入函数"><a href="#1-输入函数" class="headerlink" title="1. 输入函数"></a>1. 输入函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>三个函数若成功，返回下一个字符；若已达文件尾端或出错，返回EOF。</p>
<p>getc可被实现为宏，而fgetc不能实现为宏，是一个函数。调用fgetc所需的时间可能比getc要长，因为调用函数所需的时间通常长于调用宏。getchar相当于getc(stdin)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516135340453.png" alt="image-20210516135340453"></p>
<p>注意，不管是出错还是到达文件尾端，这3个函数都返回同样的值。为了区分这两种不同的情况，必须调用ferror或feof。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 两个函数的返回值：若条件为真，返回非0；否则，返回0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在大多数实现中，为每个流在FILE对象中维护了两个标志：</p>
<ul>
<li>出错标志</li>
<li>文件结束标志</li>
</ul>
<p>调用clearerr可清楚这两个标志。</p>
<p>从流中读取数据后，可调用ungetc将字符再押送回流中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回c；若出错，返回EOF。压送回流中的字符以后又可从流中读出，但读出字符的顺序与压送回的顺序相反。</p>
<h4 id="2-输出函数"><a href="#2-输出函数" class="headerlink" title="2. 输出函数"></a>2. 输出函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回c；若出错，返回EOF。</p>
<h3 id="5-7-每次一行I-O"><a href="#5-7-每次一行I-O" class="headerlink" title="5.7 每次一行I/O"></a>5.7 每次一行I/O</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回buf；若已到达文件尾或出错，返回NULL。这两个函数都指定了缓冲区的地址，读入的行将送入其中。gets从标准输入读，而fgets则从指定的流读。</p>
<p>fgets必须指定缓冲区的长度n，此函数一直读到下一个换行符为止，但是不超过n-1个字符，读入的字符被送入缓冲区。该缓冲区以null字节结尾。</p>
<p>gets是一个不推荐使用的函数，其问题是调用者在使用gets时不能指定缓冲区的长度。这样就可能造成缓冲区溢出。<strong>gets与fgets的另一个区别是，gets并不将换行符存入缓冲区中。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516145134449.png" alt="image-20210516145134449"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure>
<p>出错返回EOF。函数fputs将一个以null字节终止的字符串写到指定的流，尾端的终止符null不写出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516145208039.png" alt="image-20210516145208039"></p>
<p>puts函数会在额外输出一个换行符。</p>
<h3 id="5-8-标准I-O的效率"><a href="#5-8-标准I-O的效率" class="headerlink" title="5.8 标准I/O的效率"></a>5.8 标准I/O的效率</h3><h3 id="5-9-二进制I-O"><a href="#5-9-二进制I-O" class="headerlink" title="5.9 二进制I/O"></a>5.9 二进制I/O</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>两个函数的返回值：读或写的对象数。size为每个元素的长度，nobj为欲写的元素个数。</p>
<p>对于读，如果出错或到达文件尾，返回的数字可能小于nobj，应调用ferror或feof以判断究竟是哪一种情况。对于写，如果返回值小于nobj，则出错。</p>
<h3 id="5-10-定位流"><a href="#5-10-定位流" class="headerlink" title="5.10 定位流"></a>5.10 定位流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回当前文件位置指示；若出错，返回-1L */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ftell和fseek使用长整型long来存储和设置字节位置。rewind可以将一个流设置到文件的起始位置。where参数值可为<code>SEEK_CUR</code>、<code>SEEK_SET</code>、<code>SEEK_END</code>。</p>
<p>为了定位一个文本文件，whence一定要是<code>SEEKj_SET</code>，且offset只有两种值：0，或是对该文件的ftell所返回的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回值：若成功，返回当前文件位置；若出错，返回(off_t)-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">ftello</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ftello、fseeko与ftell、fseek的区别就在于ftello和fseeko使用了off_t类型来存储位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *fp, <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<p>两个函数的返回值：若成功，返回0；若出错，返回非0。</p>
<p>fgetpos和fsetpos使用一个抽象数据类型<span style="color: red">fpos_t</span>记录文件的位置。这种数据类型可以根据需要定义一个足够大的数，用以记录文件位置。</p>
<h3 id="5-11-格式化I-O"><a href="#5-11-格式化I-O" class="headerlink" title="5.11 格式化I/O"></a>5.11 格式化I/O</h3><h4 id="1-格式化输出"><a href="#1-格式化输出" class="headerlink" title="1. 格式化输出"></a>1. 格式化输出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回值：若成功，返回输出字符数；若出错，返回负值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回值：若成功，返回存入数组的字符数；若编码错误，返回负值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若缓冲区足够大，返回将要存入数组的字符数；若编码错误，返回负值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>printf</li>
<li>fprintf 写至指定的流</li>
<li>dprintf 写至指定的文件描述符</li>
<li>sprintf 将格式化的字符送入数组buf中，sprintf 在该数组的尾端自动加一个null字节，但该字符不包括在返回值中</li>
<li>snprintf 解决了sprintf的缓冲区溢出问题，超过缓冲区尾端写的所有字符都被丢弃。</li>
</ul>
<p>转换说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][fldwidth][precision][lenmodifier]convtype</span><br></pre></td></tr></table></figure>
<p>flags:</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516154855978.png" alt="image-20210516154855978"></p>
<p>lenmodifier:</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516155053219.png" alt="image-20210516155053219"></p>
<p>convtype:</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210516155122124.png" alt="image-20210516155122124"></p>
<h4 id="2-格式化输入"><a href="#2-格式化输入" class="headerlink" title="2. 格式化输入"></a>2. 格式化输入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>scanf族用于分析输入字符串，并将字符序列转换成指定类型的变量。格式之后的个参数包含了变量的地址，用转换结果对这些变量赋值。</p>
<h3 id="5-12-实现细节"><a href="#5-12-实现细节" class="headerlink" title="5.12 实现细节"></a>5.12 实现细节</h3><p>标准I/O库最终都要调用第3章说明中的I/O例程。每个标准I/O流都有一个与其相关联的文件描述符，可以对一个流调用fileno函数以获得其描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-13-临时文件"><a href="#5-13-临时文件" class="headerlink" title="5.13 临时文件"></a>5.13 临时文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回唯一路径名的指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回文件指针；若出错，返回NULL */</span></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时，都产生一个不同的路径名，最多调用次数是TMP_MAX。TMP_MAX定义在stdio.h中。如果ptr参数为NULL，则所产生的路径名存放在一个静态区中，指向静态区的指针作为函数值返回。后续调用tmpnam时，会重写该静态区。如果prt不是NULL，则认为它应该是指向长度至少是L_tmpnam个字符的数组（L_tmpnam是一个常量，定义在stdio.h中）。所产生的路径名存放在该数组中，prt也作为函数值返回。</p>
<p>tmpfile创建一个临时二进制文件（类型wb+），在关闭该文件或程序结束时将自动删除这种文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回指向目录名的指针；若出错，返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回文件描述符；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>mkdtemp函数创建了一个目录，该目录有一个唯一的名字；mkstemp函数创建了一个文件，该文件有一个唯一的名字。名字是通过template字符串进行选择的。这个字符串是后6位设置为XXXXXX的路径名。函数将这些占位符替换成不同的字符串来构建一个唯一的路径名。如果成功的话，这两个函数将修改template字符串反映临时文件的名字。</p>
<p>mkdtemp函数创建的目录使用下列访问权限位：S_IRUSR、S_IWUSR、S_IXUSR。mkstemp函数以唯一的名字创建一个普通文件并且打开该文件，该函数返回的文件描述符以读写方式打开，访问权限位设置为：S_IRUSR、S_IWUSR。</p>
<p>与tmpfile不同的是，mkstemp创建的临时文件并不会自动删除。</p>
<h2 id="第6章-系统数据文件和信息"><a href="#第6章-系统数据文件和信息" class="headerlink" title="第6章 系统数据文件和信息"></a>第6章 系统数据文件和信息</h2><h3 id="6-1-引言"><a href="#6-1-引言" class="headerlink" title="6.1 引言"></a>6.1 引言</h3><p><strong>系统文件</strong>：</p>
<ul>
<li>口令文件：/etc/passwd</li>
<li>组文件：/etc/group</li>
</ul>
<p>UNIX系统的正常运作需要使用大量与系统有关的数据文件，这些数据文件都是ASCII文本文件，并且使用标准I/O库读这些文件。但是，对于较大的系统，顺序扫描口令文件很花费时间，我们需要能够以非ASCII文本格式存放这些文件，但仍向使用其他文件格式的应用程序提供接口。</p>
<p><strong>为应用程序提供对数据文件的可移植接口</strong>是本章的主题。本章也包括了系统标识函数、时间和日期函数。</p>
<h3 id="6-2-口令文件"><a href="#6-2-口令文件" class="headerlink" title="6.2 口令文件"></a>6.2 口令文件</h3><p>头文件pwd.h中定义的passwd结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517091026848.png" alt="image-20210517091026848"></p>
<p>/etc/passwd（Linux）:</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517091205402.png" alt="image-20210517091205402"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517091706896.png" alt="image-20210517091706896"></p>
<ul>
<li>空白注释字段不产生任何影响</li>
<li>/usr/sbin/nologin 打印可定制的出错信息，然后以非0状态终止，可阻止一个特定用户登陆系统</li>
<li>nobody用户名使任何人都可登陆至系统，但其用户ID（65534）和组ID（65534）不提供任何特权。该用户ID和组ID只能访问人人皆可读、写的文件</li>
</ul>
<p>两个获取口令文件项的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回指向passwd结构的指针；若出错，返回NULL。</p>
<p>passwd结构通常是函数内部的静态变量，只要调用任一相关函数，其内容就会被重写。</p>
<p>有些程序要查看整个口令文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回指针；若出错或到达文件尾，返回NULL */</span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用getpwend时，它返回口令文件中的下一个记录项。每次调用此函数都重写passwd结构。第一次调用时，它打开所使用的各个文件。在使用getpwent查看完口令文件后，一定要调用endpwent关闭这些文件。getpwent对返回记录项的顺序并无要求。</p>
<p>setpwent反绕它所使用的文件。</p>
<h3 id="6-3-阴影口令"><a href="#6-3-阴影口令" class="headerlink" title="6.3 阴影口令"></a>6.3 阴影口令</h3><p>加密口令时经<strong>单向</strong>加密算法处理过的用户口令副本。对于一个加密口令，找不到一种算法可以将其反变换到明文口令。</p>
<p>阴影口令（shadow password）文件中存放这些加密过的口令，与之相关的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517094911742.png" alt="image-20210517094911742"></p>
<p>只有用户登陆名和加密口令这两个字段是必须的。阴影口令文件（/etc/shadow）文件只有root用户可读，而/etc/passwd文件可由各用户自由读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回指针；若出错，返回NULL */</span></span><br><span class="line"><span class="function">struct spwd *<span class="title">getspnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct spwd *<span class="title">getspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-组文件"><a href="#6-4-组文件" class="headerlink" title="6.4 组文件"></a>6.4 组文件</h3><p>/etc/group为组文件。与之对应的C结构体是在头文件grp.h中的group：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517095502842.png" alt="image-20210517095502842"></p>
<p>gr_men是一个指针数组，其中每一个指针指向一个属于该组的用户名。该数组以null指针结尾。</p>
<p>可以用下列两个函数来获取一个group的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回指针；若出错，返回NULL */</span></span><br><span class="line"><span class="function">struct group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="function">struct group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如同对口令文件进行操作的函数一样，这两个函数通常也返回指向一个静态变量的指针，在每次调用时都重写该静态变量。</p>
<p>搜索整个组文件，使用另外几个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回指针；若出错或到达文件尾端，返回NULL */</span></span><br><span class="line"><span class="function">struct group *<span class="title">getgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-附属组ID（supplementary-group-ID）"><a href="#6-5-附属组ID（supplementary-group-ID）" class="headerlink" title="6.5 附属组ID（supplementary group ID）"></a>6.5 附属组ID（supplementary group ID）</h3><p>我们不仅可以属于口令文件记录项中组ID所对应的组，也可属于多至16各另外的组。文件访问权限检查修改为：不仅将进程的有效组ID与文件的组ID相比较，而且也将所有附属组ID与文件的组ID进行比较。</p>
<p>使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目，因此也就要同时属于多个组，此类情况是常有的。</p>
<h3 id="6-6-实现区别"><a href="#6-6-实现区别" class="headerlink" title="6.6 实现区别"></a>6.6 实现区别</h3><p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517100902560.png" alt="image-20210517100902560"></p>
<h3 id="6-7-其他数据文件"><a href="#6-7-其他数据文件" class="headerlink" title="6.7 其他数据文件"></a>6.7 其他数据文件</h3><p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517101250237.png" alt="image-20210517101250237"></p>
<p>一般情况下，对于每个数据文件，至少有3各函数：</p>
<ul>
<li>get函数：读下一个记录，如果需要，还会打开该文件。此种函数通常返回指向一个结构的指针。当已达到文件尾端时返回空指针。大多数get函数返回指向一个静态存储类结构的指针，如果要保存它，则需复制它。</li>
<li>set函数：打开相应的数据文件（如果尚未打开），然后反绕该文件。如果希望在相应文件起始处开始处理，则调用此函数。</li>
<li>end函数：关闭相应数据文件。</li>
</ul>
<p>另外，还可支持某种形式的键搜索，如getpwname、getpwudi等等。</p>
<h3 id="6-8-登陆账户记录"><a href="#6-8-登陆账户记录" class="headerlink" title="6.8 登陆账户记录"></a>6.8 登陆账户记录</h3><p>大多数UNIX系统都提供下列两个数据文件：</p>
<ul>
<li>utmp：记录当前登陆到系统的各个用户，对应命令who（/var/run/utmp）</li>
<li>wtmp：跟踪各个登陆和注销事件，对应命令last（/var/log/wtmp）</li>
</ul>
<p>对应的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ut_line[<span class="number">8</span>];   <span class="comment">/* tty line: &quot;ttyh0&quot;, &quot;ttyd0&quot;, &quot;ttyp0&quot;, ... */</span></span><br><span class="line">    <span class="keyword">char</span> ut_name[<span class="number">8</span>];   <span class="comment">/* login time */</span></span><br><span class="line">    <span class="keyword">long</span> ut_time;      <span class="comment">/* seconds since Epoch */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>登陆时，login程序填写此类型结构，然后将其写入到utmp文件中，同时也将其填写到wtmp文件中。注销时，init进程将utmp文件中相应的记录擦除（每个字节都填以null字节），并将一个新记录填写到wtmp文件中。</p>
<h3 id="6-9-系统标识"><a href="#6-9-系统标识" class="headerlink" title="6.9 系统标识"></a>6.9 系统标识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(struct utsname *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>uname函数返回与主机和操作系统有关的信息，若成功，返回非负值；若出错，返回-1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517102628960.png" alt="image-20210517102628960"></p>
<p>utsname结构中，每个字段都是一个字符数组，每个数组的长度由实现确定。每个字符串都以null字节结尾。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517102827921.png" alt="image-20210517102827921"></p>
<p>BSD派生的系统提供gethostname函数，它只返回主机名，该名字通常就是TCP/IP网络上主机的名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gethostname</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">int</span> namelen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回0；若出错，返回-1。namelen参数指定name缓冲区长度，如若提供足够的空间，则通过name返回的字符串以null字节结尾。如果没有提供足够的空间，则没有说明通过name返回的字符串是否以null结尾。相关联的文件是/etc/hostname。</p>
<h3 id="6-10-时间和日期例程"><a href="#6-10-时间和日期例程" class="headerlink" title="6.10 时间和日期例程"></a>6.10 时间和日期例程</h3><p>time函数用于获取日历时间（从UTC到现在的秒数）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *calptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回时间值；若出错，返回-1。如果参数非空，则时间值也存放在由calptr指向的单元内。</p>
<p>clock_gettime函数可用于获取指定时钟的时间，将时间存在timespce结构中，它把时间表示为秒和纳秒：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> clock_id, struct timespec *tsp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>clock_id的类型为clockid_t：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517104625328.png" alt="image-20210517104625328"></p>
<p>clock_id设置为CLOCK_REALTIME时，clock_gettime函数提供了与time函数类似的功能，不过在系统支持高精度时间值的情况下，clock_gettime可能比time函数得到更高精度的时间值。</p>
<p>clock_getres函数把参数tsp指向的timespec结构初始化为与clock_id参数对应的时钟精度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_getres</span><span class="params">(<span class="keyword">clockid_t</span> clock_id, struct timespec *tsp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>要对特定的时钟设置时间，可以调用clock_settime函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_settime</span><span class="params">(<span class="keyword">clockid_t</span> clock_id, <span class="keyword">const</span> struct timespec *tsp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>gettimeofday函数以距特定时间（1970年1月1日00:00:00）的秒数的方式将当前时间存放在tp指向的timeval结构中，而该结构将当前时间表示为为秒和微妙。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tp, <span class="keyword">void</span> *tzp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>tzp的唯一合法值是NULL，其他值将产生不确定的结构。某些平台支持用tzp说明时区，但这完全依赖于实现。</p>
<p>一旦获取这种从上述特定时间经过的秒数的整型时间值后，通常要调用函数将其转换为分解的时间结构，然后调用另一个函数生成人们可读的时间和日期。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517110330679.png" alt="image-20210517110330679"></p>
<p>上图中表示了时间转换关系，虚线表示受到环境变量TZ的影响。点划线标示了如何从时间相关的结构获得日历时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出错返回NULL */</span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *calptr)</span></span>;</span><br><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *calptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>localtime和gmtime将日历时间转换成分解的时间，并将这些存放在一个tm结构中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517110736428.png" alt="image-20210517110736428" style="zoom:67%;" /></p>
<p>除了月日字段，其他字段的值都以0开始。如果夏令时生效，则夏令时标志值为正；如果为非夏令时时间，则该标志值为0，如果此信息不可用，则其值为负。</p>
<p>localtime和gmtime的区别是：localtime将日历时间转换成本地时间（考虑本地时区和夏令时标志），而gmtime则将日历时间转换成协调统一时间的年、月、日、时、分、秒、周日分解结构。</p>
<p>函数mktime以本地时间的年、月、日等作为参数，将其变换成time_t值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功，返回日历时间；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">mktime</span><span class="params">(struct tm *tmptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数strftime是一个类似于printf的时间值函数，非常复杂，可以通过可用的多个参数来定制产生的字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> struct tm *tmptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime_l</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> struct tm *tmptr, <span class="keyword">locale_t</span> locale)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若有空间，返回存入数组的字符数（在末尾加上null终止符，但该字符不算在返回字符数中）；否则，返回0。strftime_l允许调用者将区域指定为参数，除此之外，strftime和strftime_l函数是相同的。strftime使用通过TZ环境变量指定的区域。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517112208563.png" alt="image-20210517112208563"></p>
<p>strptime函数是strftime的反过来版本，把字符串时间转换成分解时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出错返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">const</span> <span class="keyword">char</span> *format, struct tm *tmptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qinglew/ImageHost/image-20210517113214260.png" alt="image-20210517113214260"></p>

        </div>

        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/05/09/C-Primer-Plus/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer Plus学习记录</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Cleo</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts">
    
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
