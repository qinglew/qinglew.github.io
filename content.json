{"meta":{"title":"Hexo","subtitle":"Keep Learning","description":"A personal blog based on github and hexo","author":"Cleo","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2021-04-16T14:00:40.000Z","updated":"2021-04-16T14:02:36.525Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-04-16T14:02:50.000Z","updated":"2021-04-16T14:03:12.052Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"UNIX操作系统高级编程","slug":"unix","date":"2021-05-16T15:53:53.000Z","updated":"2021-05-26T15:12:08.037Z","comments":true,"path":"2021/05/16/unix/","link":"","permalink":"http://example.com/2021/05/16/unix/","excerpt":"","text":"UNIX环境高级编程第1章 UNIX基础知识1.1 Unix体系结构 内核：一种软件，控制计算机硬件资源，提供程序运行环境 系统调用：内核的接口 shell，公用函数库 应用程序 1.2 不带缓冲的I/O函数open、read、write、lseek以及close提供了不带缓冲的I/O。这些函数都使用文件描述符。 1.2.1 文件描述符STDIN_FILENO、STDOUT_FILENO为两个宏，值分别为0、1，表示标准输入和标准输出的文件描述符。 1.2.1 readread函数返回读取的字节数，当到达文件的尾端时，read返回0；如果发生了一个读错误，read返回-1。 1.3 标准I/O标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需担心如何选取最佳的缓冲区大小。使用标准I/O还简化了对输入行的处理，如fgets读取一个完整的行，而read函数读取指定的字节数。 stdin、stdout、getc、putc等均在stdio.h中定义。 1.4 进程控制程序（program）是一个存储在磁盘上的某个目录中的可执行文件。程序的执行实例被称为进程（process）。每个进程都有一个唯一的数字标识符，称为进程ID，进程ID总是一个非负整数。 getpid() getgid() fork() waitpid() exec() 一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性，它们能访问同一存储区，因此各个线程在访问共享数据时需要采取同步措施以避免不一致性。 1.5 出错处理头文件errno.h中定义了errno以及可以赋与它的各种常量，这些常量都以字符E开头。当UNIX系统函数出错时，通常会返回一个负值，而且整形变量errno通常被设置为具有特定信息的值。 对于errno应当注意两条规则： 如果没有出错，其值不会被例程清除。因此，仅当函数的返回值指明出错时，才检验其值。 任何函数都不会将errno值设置为0，而且errno.h中定义的所有常量都不为0。 C标准定义了2个函数，它们用于打印出错信息： 1 - strerror 12#include &lt;string.h&gt;char *strerror(int errnum); strerror函数将errnum（通常就是errno值）映射为一个出错消息字符串，并且返回此字符串的指针。 2 - perror perror函数基于errno的当前值，在标准错误上产生一条出错消息，然后返回。 12#include &lt;stdio.h&gt;void perror(const char *msg); 1.6 时间值Unix系统使用过两种不同的时间值： 日历时间，即UTC，格林尼治标准时间，以秒为单位，可以用于记录文件的最近修改时间，对应类型为time_t。 进程时间，也被称为CPU时间，用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。对应数据类型为clock_t。 当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值： 时钟时间，是进程运行的时间总量，其值与系统中同时运行的进程数有关。 用户CPU时间，是执行用户指令所用的时间量。 系统CPU时间，是该进程执行内核程序所经历的时间。 用户CPU时间和系统CPU时间之和常被称为CPU时间。 time命令用于获取任一进程的时钟时间、用户时间和系统时间。 1.7 信号可以使用kill函数产生信号，在一个进程中调用此函数就可以向另一个进程发送一个信号。当然，这样做也有些限制：当向一个进程发送信号时，我们必须是那个进程的所有者或者是超级用户。 第3章 文件I/O3.1 引言本章内容： 文件I/O。本章介绍的I/O函数通常被称为不带缓冲的I/O（unbuffered I/O），所谓不带缓冲指的是每个read和write都调用内核中的一个系统调用。 open read write lseek close 多个进程间共享资源。 dup fcntl sync fsync ioctl 3.2 文件描述符对内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。 文件描述符0——标准输入， STDIN_FILENO 文件描述符1——标准输出， STDOUT_FILENO 文件描述符2——错误输出， STDERR_FILENO 上述三个符号常量存储在头文件unistd.h中。 3.3 函数open和openat1234#include &lt;fcntl.h&gt;int open(const char *path, int oflag, ... /* mode_t mode */);int openat(int fd, const char *path, int oflag, ... /*mode_t mode */); 若成功，返回文件描述符；若出错，返回-1。 ...表示该函数的余下参数的数量及类型是可变的。对于open函数而言，仅当创建新文件时才使用最后这个参数。 oflag: O_RDONLY：只读 O_WRONLY：只写 O_RDWR：可读可写 O_EXEC：只执行打开 O_SEARCH：只搜索打开（应用于目录） 上述五个常量中必须指定一个且只能指定一个，下列常量则是可选的： O_APPEND：追加模式 O_CREATE：若文件不存在则创建它，此时需要指定mode O_TRUNC：文件存在，且为只写或读-写成功打开，则将其长度截断为0，于O_APPEND对应。 O_DIRECTORY：如果path引用的不是目录，则出错 O_EXCL：如果同时指定了O_CRAET，而文件已经存在，则出错。可以用于测试一个文件是否存在，如果不存在则创建，这使测试和创建两者成为一个原子操作。 O_SYNC：使每次write等待物理I/O操作完成，包括由该write操作引起的文件属性更新所需的I/O。 O_DSYNC：使每次write要等待物理I/O操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需等待文件属性被更新。 O_RSYNC：使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作都完成。 O_CLOEXEC：把FD_CLOEXEC常量设置为文件描述符标志 O_NOCTTY：如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端。 O_NOFOLLOW：如果path是一个链接符号，则出错。 O_NONBLOCK：如果path是一个FIFO、一个快特殊文件或者一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞模式。 O_TTY_INIT：如果打开一个还未打开的终端设备，设置非标准termios参数值，使其符合Single UNIX Specification。 关于openat的三种情况： 如果path为绝对路径，则fd没有任何作用，传任何值都可以，此时与open函数无异。 如果path为相对路径，而fd为AT_FDCWD，则指定目录为当前目录。 如果path为相对路径，fd不为AT_FDCWD，则需给fd传入指定的目录的文件描述符。 TOCTTOU（time-of-check-to-time-of-use），如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的，因为两个基于文件的函数调用，在两个函数调用之间文件可能改变了。 3.4 函数create123#include &lt;fcntl.h&gt;int creat(const char * path, mode_t mode); 若成功，返回一个只写打开的文件描述符；若出错，返回-1。 此函数等效于： 1open(path, O_WRONLY | O_CREAT | O_TRUNC, mode); create只能以只写方式打开所创建的文件，要想是写可读可写必须用open函数： 1open(path, O_RDWR | O_CREAT | O_TRUNC, mode); 3.5 函数close123#include &lt;unistd.h&gt;int close(int fp); 若成功，返回0；若出错，则返回-1。 3.6 函数lseek123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); 若成功，返回新的文件偏移量；若出错，返回-1。 按系统默认情况，当打开一个文件时，除非指定O_APPEND选项，否则该偏移量被设置为0。 whence的三种情况： whence 为 SEEK_SET，则将文件偏移量设置为距文件开始处offset字节。 whence 为 SEEK_CUR，则将文件偏移量设置为当前值加offset，offset可为正或负。 whence 为 SEEN_END，则将文件偏移量设置为文件长度加offset，offset可正可负。 确定打开文件的当前偏移量： 12off_t currpos;currpos = lseek(fd, 0, SEEK_CUR); 这种方法也可以用来测试所涉及的文件是否可以设置偏移量，如果文件描述符指向的是一个管道、FIFO或网络套接字，则lseek返回-1，并将errno设置为ESPIPE。 在比较lseek的返回值时应当谨慎，不要测试它是否小于0，而要测试它是否等于-1。 lseek仅将当前的文件描述符记录在内核中，它并不引起任何I/O操作。然后，该偏移量用于下一个读或写操作。 文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位超出文件尾端后写时，对于新写的数据需要分配磁盘快，但对于原文件尾和新开始写位置之间的部分则不需要分配磁盘块。 命令od -c以字符方式查看文件内容。 3.7 函数read123#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes); fd为文件描述符，buf为缓冲区，nbytes为要求读的字节数。返回读到的字节数，若到达文件尾，返回0；若出错，返回-1。 3.8 函数write123#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbyts); fd为文件描述符，buf为包含数据的缓冲区，nbytes为要写入的字节数。若成功，返回已经写的字节数；若出错，返回-1。 返回值通常与nbytes一致，否则表示出错。write出错的一个常见原因时磁盘已写满，或者超过了一个给定进程的文件长度限制。 3.9 I/O的效率 12345678910111213141516171819202122232425262728293031323334353637#include &quot;apue.h&quot;#include &lt;string.h&gt;int str2int(const char *);int main(int argc, char *argv[])&#123; int n, buff_size; buff_size = str2int(argv[1]); char *buf = (char *)malloc(buff_size * sizeof(char)); printf(&quot;%d\\n&quot;, buff_size); while ((n = read(STDIN_FILENO, buf, buff_size)) &gt; 0) &#123; if (write(STDOUT_FILENO, buf, n) != n) err_sys(&quot;write error&quot;); &#125; if (n &lt; 0) err_sys(&quot;read error&quot;); if (but != NULL) free(buf); return 0;&#125;int str2int(const char *str)&#123; int length = strlen(str), n = 0; for (int i = 0; i &lt; length; i++) &#123; n = n * 10 + (str[i] - &#x27;0&#x27;); &#125; return n;&#125; 测试结果： 3.10 文件共享内核使用3种数据结构表示打开文件： 每个进程在进程表中都有一个记录项（进程表项），记录项中包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。每一项包含： 文件描述符标志 指向一个文件表项的指针 内核为所有打开文件维持一张文件表，每个文件表项包含： 文件状态标志 当前文件偏移量 指向该文件v节点表项的指针 每个打开文件都有一个v节点（v-node）结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的i节点（i-node，索引节点）。i-node包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。 我们假定第一个进程在文件描述符3上打开该文件，而另一个进程在文件描述符4上打开该文件。打开该文件的每个进程都获得各自的一个文件表项，但对一个给定的文件只有一个v节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使每个进程都有它自己的对该文件的当前偏移量。 在完成每个write后，在文件表项中的当前偏移量即增加所写入的字节数。如果这导致当前文件偏移量超过了当前文件长度，则将i节点表项中的当前文件长度设置为当前文件偏移量（也就是该文件加长了）。 如果使用O_APPEND标志打开一个文件，则相应标志也被设置到文件表项的文件标志状态中。每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。这就使得每次写入的数据都追加到文件的当前尾端处。 若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置成i节点表项中的当前文件长度。（注意，这与用O_APPEND标志打开文件是不同的。） lseek函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作。 可能有多个文件描述符项指向同一个文件表项，如fork后父子进程各自的每一个打开文件描述符共享同一个文件表项。 3.11 原子操作一个原子操作的例子：两个进程打开同一个文件，都先调用lseek，再调用write写文件，可能会导致覆盖。 函数pread和pwrite： 1234567#include &lt;unistd.h&gt;/* 返回值为读到的字节数，若已到达文件尾端则返回0；若出错，返回-1 */ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);/* 若成功，返回已写的字节数；若出错，返回-1 */ssize_t pwrite(int fd, const void *buf, size_t bytes, off_t offset); 调用pread相当于调用lseek后调用read，但pread是一个原子操作，即： 调用pread时，无法中断其定位和读操作。 不更新当前文件的偏移量。 调用pwrite相当于调用lseek后调用write，但同样，是一个原子操作。 另一个原子操作的例子：判断一个文件是否存在，若存在，则open失败；若不存在，则创建该文件。open提供了oflag的O_EXCL和O_CREAT，使得这两个操作成为一个原子操作。如果没有O_EXCL，则可能要这样写代码： 123456789101112if ((fd = open(pathname, O_WRONLY)) &lt; 0)&#123; if (errno == ENOENT) &#123; if ((fd = creat(path, mode)) &lt; 0) err_sys(&quot;creat error&quot;); &#125; else &#123; err_sys(&quot;open error&quot;); &#125;&#125; 上述代码带来的问题是，如果在open和creat之间，另一个进程创建了该文件，就会出现问题。 一般而言，原子操作（atomic operation）指的是由多步组成的一个操作。如果该操作原子的执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。 3.12 函数dup和dup212345#include &lt;unistd.h&gt;int dup(int fd);int dup2(int fd, int fd2) 上面两个函数都可用来复制一个现有的文件描述符。若成功，返回新的文件描述符；若出错，返回-1。 由dup返回的新文件描述符一定是当前可用文件描述符中的最小值。对于dup2，可以用fd2参数指定新描述符的值。如果fd2已经打开，则先将其关闭；如果fd等于fd2，则dup2返回fd2，而不关闭它。否则，fd2的FD_CLOEXEC文件描述符标志就被清除，这样fd2在进程调用exec时是打开状态。 这些函数返回的新文件描述符与参数fd共享一个文件表项。 每个文件描述符都有它自己的一套文件描述符标志。 3.13 函数 sync、fsync 和 fdatasync延迟写：传统的Unix系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据写入磁盘。为了保证磁盘上实际文件系统与缓冲区中内容的一致性，Unix系统提供了sync、fsync和fdatasync三个函数。 123456#include &lt;unistd.h&gt;int fsync(int fd);int fdatasync(int fd);void sync(void); fsync、fdatasync若成功，返回0；若出错，返回-1。 sync只是将所有修改过的块缓冲区排入队列，然后就返回，它并不等待实际写磁盘操作结束。通常，称为update的系统守护进程周期性地调用（一般每隔30秒）sync函数，这就保证了定期冲洗（flush）内核的块缓冲区。命令sync(1)也调用sync函数。sync对所有文件打开的文件描述符执行。 fsync函数只是对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束才返回。fsync可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。 fdatasync类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。 3.14 函数fcntl123#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* int arg */); fcntl函数可以改变已经打开文件的属性。若成功，则依赖cmd；若出错，返回-1。 fcntl函数有以下五种功能： (1) 复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC） (2) 获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD） (3) 获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL） (4) 获取/设置异步I/O所有权（cmd = F_GETOWN 或 F_SETOWN） (5) 获取/设置记录锁 （cmd = F_GETLK、F_SETLK 或 F_SETLKW） 11种cmd中的8种： F_DUPFD ：复制文件描述符fd。新文件描述符作为函数值返回。它是尚未打开的各描述符中大于或等于第3个参数值（取整）中各值的最小值。新描述符与fd共享同一文件表项。但是新描述符有它自己的一套文件描述符标志。 F_DUPFD_CLOEXEC ：复制文件描述符，设置与新描述符关联的FD_CLOEXEC文件描述符标志的值，返回新文件描述符。 F_GETFD ：对应于fd的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志FD_CLOEXEC。 F_SETFD ：对于fd设置文件描述符标志。新标志值按第3个参数（取为整型值）设置。 F_GETFL ：对应于fd的文件状态标志作为函数返回值返回。文件状态标志参考3.3节open函数的第2个参数。遗憾的是，5个访问标志（O_RDONLY、O_WRONLY、O_RDWR、O_EXEC以及O_SEARCH）并不各占1位（这5个值互斥，一个文件的访问方式只能取这5个值之一）。因此首先必须用屏蔽字O_ACCMODE取得访问方式位，然后将结果与这5个值中的每一个相比较。 F_SETFL ：将文件状态标志设置为第3个参数的值（取为整型值）。可以更改的几个标志是：O_APPEND、O_NOBLOCK、O_SYNC、O_DSYNC、O_RSYNC、O_FSYNC、O_ASYNC。 F_GETOWN ：获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID。 F_SETOWN ：设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的arg指定一个进程ID，负的arg表示等于arg绝对值的一个进程组ID。 关于复制文件描述符，前面3.12节介绍了dup和dup2两个函数。实际上，执行dup(fd);等效于执行fcntl(fd, F_DUPFD, 0);，而调用dup2(fd, fd2);相当于执行了: 12close(fd);fcntl(fd, F_DUPFD, fd2); 但是并不完全等效，dup2是一个原子操作，而且dup2和fcntl有一些不同的errno。 在修改文件描述符标志或文件状态标志时必须谨慎，先要获得现在的标志值，然后按照期望修改它，最后设置新标志值。不能只是执行F_SETFD或F_SETFL命令，这样会关闭以前设置的标志位。 12345678910111213141516171819202122232425262728#include &quot;apue.h&quot;#include &lt;fcntl.h&gt;void set_fl(int fd, int flags)&#123; /* 先获取之前的文件标志状态 */ int val; if ((val = fcntl(fd, F_GETFL, 0)) &lt; 0) err_sys(&quot;fcntl F_GETFL error&quot;); /* turn on flags */ val |= flags; if (fcntl(fd, F_SETFL, val) &lt; 0) err_sys(&quot;fcntl F_SETFL error&quot;);&#125;void set_fl2(int fd, int flags)&#123; /* get previous flags */ int val; if ((val = fcntl(fd, F_GETFL, 0)) &lt; 0) err_sys(&quot;fcntl F_GETFL error&quot;); /* turn off flags */ val &amp;= ~flags; if (fcntl(fd, F_SETFL, val) &lt; 0) err_sys(&quot;fcntl F_SETEL error&quot;);&#125; 打开状态用val |= flags;，关闭状态用val &amp;= ~flags;。 当使用上述函数打开O_SYNC时，write需要等待缓冲区中的数据写入磁盘块完成后返回，增加了程序执行的时间。 在这里需要注意，设置文件状态标志位O_SYNC与sync函数的作用不是一样的，前者等待物理I/O操作完整再返回，而后者则是将缓冲块排入队列就返回，不等待物理操作完成。 O_DSYNC与O_SYNC的区别是前者不等待文件属性更新完就返回。 sync函数与fsync函数的区别是fsync只针对某个特定的文件描述符，等待物理I/O完成。 3.15 函数ioctl1234#include &lt;unistd.h&gt; /* System V */#include &lt;sys/ioctl.h&gt; /* BSD and Linux */int ioctl(int fd, int request, ...); 若出错，返回-1；若成功，返回其他值。ioctl函数一直是I/O操作的杂物箱。不能用本章中其他函数表示的I/O操作通常都能用ioctl表示。终端I/O是使用ioctl最多的地方。通常还要用到头文件termios.h。 嵌入式常用。 3.16 /dev/fd较新的系统都提供名为/dev/fd的目录，其目录项是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符n（假定描述符n是打开的）。 在下列函数调用中： 1fd = open(&quot;/dev/df/0&quot;, mode); 大多数系统忽略它所指定的mode，而另外一些系统则要求mode必须是所引用的文件（在这里是标准输入）初始打开时所使用的打开模式的一个子集。因为上面的打开等效于： 1fd = dup(0); 所以描述符fd和0共享同一文件表项。例如，若描述符0先前被打开为只读，那么我们也只能对fd进行读操作。即使系统忽略打开模式，而且下列调用是成功的： 1fd = open(&quot;/dev/fd/0&quot;, O_RDWR); 我们仍然不能对fd进行写操作。 Linux实现中的/dev/fd是个例外。它把文件描述符映射成指向底层物理文件的符号链接。例如，当打开/dev/fd/0时，事实上正在打开与标准输入关联的文件，因此返回的新文件描述符的模式与/dev/fd文件描述符的模式其实并不相关。 某些系统提供文件/dev/stdin、/dev/stdout 和 /dev/stderr，这些等效于/dev/fd/0、/dev/fd/1和/dev/fd/2 作为命令行参数的-特指标准输入或输出。 1filter file2 | cat file1 - file3 | lpr cat先读file1，然后读其标准输入（即filter file2的输出），然后读file3，如果支持/dev/fd，可以删除cat对-的特殊处理： 1filter file2 | cat file1 /dev/fd/0 file3 | lpr 3.17 练习3.6 如果使用追加标志打开一个文件以便读、写，能否仍用lseek在任一位置开始读？能否用lseek更新文件中任一部分的数据？请编写一段程序验证。 1答：可以从任一位置开始读，但不能从任一位置开始写。写需要O_WROLY或O_RDWR，单独的O_APPEND不具有写的功能。 第4章 文件和目录4.1 引言本章将描述文件系统的其他特征和文件的性质。 4.2 函数stat、fstat、fstatat和lstat123456789101112#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat(const char *pathname, struct stat *statbuf);int fstat(int fd, struct stat *statbuf);int lstat(const char *pathname, struct stat *statbuf);#include &lt;fcntl.h&gt; /* Definition of AT_* constants */#include &lt;sys/stat.h&gt;int fstatat(int dirfd, const char *pathname, struct stat *statbuf, int flags); 这四个函数在函数执行成功时返回0，出错时返回-1。 一旦给出pathname，stat函数将返回与此命名文件有关的信息结构。 fstat函数获得已在文件描述符fd上打开文件的有关信息。 lstat类似于stat，但是命名的文件是一个符号链接时，lstat返回该符号链接的有关信息，而不是由该符号链接引用的文件信息。 fstatat函数为一个相对于当前打开目录（由dirfd参数指向）的路径名返回文件统计信息。flags参数控制着是否跟随着一个符号链接。当AT_SYMLINK_NOFOLLOW标志被设置时，fstatat不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返回的是符号链接所指向的实际文件信息。如果fd被设置为AT_FDCWD，并且pathname参数是一个相对路径名，fstatat会计算相对于当前目录的pathname参数。如果pathname是一个绝对路径，fd参数就会被忽略。在这两种情况下，根据flag 的取值，fstatat的作用就跟stat或lstat一样。 参数buf是一个指针，指向的结构为stat，定义如下： 123456789101112131415161718192021222324struct stat &#123; dev_t st_dev; /* ID of device containing file */ ino_t st_ino; /* Inode number */ mode_t st_mode; /* File type and mode (permission) */ nlink_t st_nlink; /* Number of hard links */ uid_t st_uid; /* User ID of owner */ gid_t st_gid; /* Group ID of owner */ dev_t st_rdev; /* Device ID (if special file) */ off_t st_size; /* Total size, in bytes */ blksize_t st_blksize; /* Block size for filesystem I/O */ blkcnt_t st_blocks; /* Number of 512B blocks allocated */ /* Since Linux 2.6, the kernel supports nanosecond precision for the following timestamp fields. For the details before Linux 2.6, see NOTES. */ struct timespec st_atim; /* Time of last access */ struct timespec st_mtim; /* Time of last modification */ struct timespec st_ctim; /* Time of last status change */ #define st_atime st_atim.tv_sec /* Backward compatibility */ #define st_mtime st_mtim.tv_sec #define st_ctime st_ctim.tv_sec&#125;; stat函数用的最多的地方可能就是ls -l命令。 4.3 文件类型文件类型包括如下几种： 普通文件（regular file） 目录文件（directory file）：这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。 块特殊文件（block special file）：提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。 字符特殊设备（character special file）：提供对设备的不带缓冲访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊设备。 FIFO：用于进程间通信，有时也称为命名管道（named pipe）。 套接字（socket）：用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。 符号链接（symbolic link）：指向另一个文件。 文件类型信息包含在stat结构中的st_mode成员中。下列宏可以用于st_mode类型的参数： 下列宏可以用于stat结构来确定IPC（进程间通信）对象： 4.4 设置用户ID和设置组ID与一个进程相关联的ID有6个或更多，如下图所示： 实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们。个人理解为启动该进程的用户ID、组ID就是实际用户ID和实际组ID。 有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。 保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。设置用户ID和设置组ID是两个特殊的权限位，用于为启动某进程的用户或用户组设置在运行时与文件所属用户和用户组所拥有的权限，对应文件权限标志s。 通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID。 每个文件有一个所有者和组所有者，所有者由stat结构中的st_uid指定，组所有者由st_gid指定。 文件模式字中的特殊两位：设置用户ID（set-user-ID）位和设置组ID（set-group-ID）位。 设置用户ID（set-user-ID）位：当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID（st_uid）。 设置用户组ID（set-group-ID）位：当执行此文件时，将进程的有效用户ID设置为文件的组所有者ID（st_gid）。 例如，若文件的所有者是超级用户，而且设置了该文件的设置用户ID位，那么当该程序文件由一个进程执行，该进程具有超级用户权限，不管执行此文件的进程的实际用户ID是什么。 一个最简单的例子，用户可以使用passwd命令修改自己的密码。该程序是一个设置用户ID程序，因为该程序应能将用户的新口令写入文件中（一般是/etc/passwd或/etc/shadow），该文件的所有这为root，且这个文件的权限一般为-rw-r--r--，其他用户没有写的权限，所以需要使用设置用户ID功能才能是普通用户使用passwd命令改密码。 设置用户ID位及设置组ID位都包含在文件st_mode值中，分别使用S_ISUID和S_ISGID进行位与测试可以检测出是否有对应权限。 4.5 文件访问权限st_mode值也包含了对文件的访问权限位。每个文件有9个访问权限位，可将它们分成3类： 用户是指文件所有者（owner），组指文件所有组(group)，其他指其他用户（other）。chmod命令可以修改这9个权限位。 我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录执行权限位常被称为搜索位的原因。 注意，对于目录的读权限和执行权限的意义是不同的。读权限允许我们读目录，获得在该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，对该目录的执行权限使我们可以通过该目录。 对于一个文件的读权限决定了我们是否能打开现有文件进行读操作。这与open函数的O_RDONLY和O_RDWR标志相关。 对于一个文件的写权限决定了我们是否能打开现有文件进行写操作。这与open函数的O_WRONLY和O_RDWR标志相关。 为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限。 为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限。 为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身则不需要有读、写权限。 如果用7个exec函数中的任何一个执行某个文件，都必须对该文件具有执行权限。该文件还必须是一个普通文件。 文件所有者（st_uid）和（st_gid）是文件的性质，两个有效ID（有效用户ID和有效组ID）和附属组ID是进程的性质。 内核进行的测试具体如下： 若进程的有效用户ID是0（超级用户），则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由。 若进程的有效用户ID等于文件的所有者ID（也就是进程拥有此文件），那么如果所有者适当的访问权限被设置，则允许访问；否则拒绝访问。 若进程的有效组ID或进程的附属组ID之一等于文件的组ID，那么如果组适当的访问权限被设置，则允许访问；否则拒绝访问。 若其他用户适当的访问权限位被设置，则允许访问；否则拒绝访问。 4.6 新文件和目录的所有权新文件的用户ID设置为进程的有效用户ID。关于组ID，POSIX.1允许实现选择下列之一作为新文件的组ID： 新文件的组ID可以是进程的有效组ID 新文件的组ID可以是它所在目录的组ID 4.7 函数access和faccessataccess和faccessat函数是按实际用户ID和实际组ID进行访问权限测试的。 12345678#include &lt;unistd.h&gt;int access(const char *pathname, int mode);#include &lt;fcntl.h&gt; /* Definition of AT_* constants */#include &lt;unistd.h&gt;int faccessat(int dirfd, const char *pathname, int mode, int flags); 两个函数若执行成功，返回值为0，失败返回-1。 即使一个进程可能已经通过设置用户ID或设置组ID以超级用户权限运行，它仍可能想验证其实际用户能否访问一个给定的文件。 测试文件是否已经存在，mode就为F_OK；否则，mode是图4-7中所列常量的按位或。 mode 说明 R_OK 测试读权限 W_OK 测试写权限 X_OK 测试执行权限 至于faccessat函数的fd参数和pathname参数，其用法和openat函数的fd参数和pathname一致。 flag参数可以用于改变faccessat的行为，如果flag设置为AT_EACCESS，访问检查用的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。 4.8 函数umask123#include &lt;sys/stat.h&gt;mode_t umask(mode_t cmask); umask函数为进程设置文件模式创建屏蔽字，并返回之前的值。该函数是少数几个没有出错返回函数中的一个。参数cmask是由图4-6中列出的9个常量（S_IRUSR、S_IWUSR等）中的若干按位“或”构成的。在文件模式创建屏蔽字中为1的位，在文件mode中的相应位一定被关闭。 Unix系统的大多数用户从不处理他们的umask值。通常在登录时，由shell的启动文件设置一次，然后不再改变。尽管如此，当编写创建新文件的程序时，如果我们想确保指定的访问权限位已经激活，那么必须在进程运行时修改umask值。 umask命令 umask命令用于查看或显示被屏蔽的位的八进制或许可的权限，还可用于设置屏蔽位，以8进制表示。 1234567$ umask022$ umask -Su=rwx, g=rx, o=rx$ umask 027$ umask -Su=rwx, g=rx, o= 4.9 函数chmod、fchmod和fchmodat12345#include &lt;sys/stat.h&gt;int chmod(const char *pathname, mode_t mode);int fchmod(int fd, mode_t mode);int fchmodat(int fd, const char *pathname, mode_t mode, int flag); chmod、fchmod和fchmodat这3个函数使我们可以更改现有文件的访问权限。若执行成功，则返回0，执行失败则返回-1。flag参数可以用于改变fchmodat的行为，当设置了AT_SYMLINK_NOFOLLOW标志时，fchmodat并不会跟随符号链接。 为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或该进程必须具有超级用户权限。参数mode时图4-11中所示常量的按位或。 chmod函数更新的只是i节点最近一次被更改的时间。按系统默认方式，ls -l列出的是最后修改文件内容的时间。 chmod函数在下列条件下自动清除两个权限位： Solaris等系统对用于普通文件的粘着位赋予了特殊含义，在这些系统上如果我们试图设置普通文件粘着位（S_ISVTX），而且又没有超级用户权限，那么mode中的粘着位自动被关闭。这意味着只有超级用户才能设置文件的粘着位。这样做的理由是防止恶意用户设置粘着位，由此影响系统性能。 新创建文件的组ID可能不是调用进程所属的组。新文件的组ID可能是父目录的组ID。特别地，如果新文件的组ID不等于进程的有效组ID或者进程附属组ID中的一个，而且进程没有超级用户权限，那么设置ID位会被自动关闭。这就防止了用户创建一个设置组ID文件，而该文件是由非该用户所属的组拥有的。 4.10 粘着位S_ISVTX。 4.11 函数chown、fchown、fchownat和lchownchown函数可用于更改文件的用户ID和组ID。如果两个参数owner或group中的任意一个是-1，则对应的ID不变。 123456#include &lt;unistd.h&gt;int chown(const char *pathname, uid_t owner, gid_t group);int fchown(int fd, uid_t owner, gid_t group);int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);int lchown(const char *pathname, uid_t owner, gid_t group); 四个函数的返回值：若成功，返回0；若出错，返回-1。 除了所引用的文件是符号链接外，这四个函数的操作类似。在符号链接情况下，lchown和fchownat（设置了AT_SYMLINK_NOFOLLOW标志）更改符号链接本身的所有者，而不是符号链接所指向的文件所有者。 超级用户可以更改文件的所有者和所有组，而有些系统支持任一用户更改他们所拥有的文件所有者。 4.12 文件长度stat结构成员st_size表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。 对于普通文件，其文件长度可以是0，在开始读这种文件时，将得到文件结束符（EOF）。对于目录，文件长度通常是一个数（如16或512）的整数倍。对于符号链接，文件长度是指向的文件名中的实际字节数。 现今，大多数现代的UNIX系统提供字段st_blksize和st_blocks。前者是对文件I/O较合适的块长度，后者是所分配的实际512字节块块数。 文件中的空洞 文件core的长度稍稍超过8MB，可是du命令报告该文件所使用的磁盘空间总量是272个512字节块（即139264字节）。很明显，此文件中有很多空洞。 使用wc命令，可以看出正常的I/O操作读整个文件的长度。 如果使用cat复制这个文件，那么所有的这些空洞都会被填满，其中所有实际数据字节皆填写为0。 4.13 文件截断在打开文件时使用O_TRUNC标志截断为0是一个特例。为了截断文件，可以使用下列函数： 1234#include &lt;unistd.h&gt;int truncate(const char* pathname, off_t length);int ftruncate(int fd, off_t length); 若成功，返回0；若失败，返回-1。 这两个函数将现有文件截断为length。若原来的文件长度大于length，则截断后大于length的部分无法访问。若原来问价你的长度小于length，则截断后文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0（也就是可能在文件中创建了一个空洞）。 4.14 文件系统 我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统。i节点时固定长度的记录项，它包含有关文件的大部分信息。更仔细地观察一个柱面的i节点和数据块部分，可以看到下图所示情况： 上图中，有两个目录项指向同一个i节点。每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除该文件（也可以释放该文件占用的数据块）。这就是为什么“解除一个文件的链接”操作并不总是意味着“释放该文件占用的磁盘块”的原因。这也是为什么删除一个目录项的函数被称为unlink而不是delete的原因。在stat结构中，链接计数包含在st_nlink成员中，其基本系统数据类型是nlink_t，这种链接类型称为硬链接。 另一种链接类型称为符号链接。符号链接文件的实际内容包含了该链接所指向的文件的名字。符号链接i节点中文件类型是S_IFLNK，于是系统知道这是一个符号链接。 i节点包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录项中：文件名和i节点编号。i节点编号的数据类型是ino_t。 因为目录项中的i节点编号指向同一文件系统中的相应i节点，一个目录项不能指向另一个文件系统的i节点。因此ln命令不能跨越文件系统。 当在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需构造一个指向现有i节点的新目录项，并删除老的目录项。链接计数不会改变。这就是mv命令的通常操作方式。 上述时普通文件的链接计数的概念，对于目录文件的链接计数字段如下所示： 我们在当前目录下创建一个testdir目录。testdir目录的i节点的链接计数项为2，一个来自创建该目录的父目录，即当前工作目录，还有一个来自于testdir目录中的.。而当前工作目录的i节点的链接计数项至少为3，一个来自于其父目录，一个来自于当前目录下的.，还有一个来自testdir目录的..。注意，在父目录中每一个子目录都使该父目录的链接计数增加1。 4.15 函数link、linkat、unlink、unlinkat和remove创建一个指向现有文件的链接的方法是使用link函数或linkat函数。 1234#include &lt;unistd.h&gt;int link(const char* existingpath, const char *newpath);int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag); 若成功，返回0；若出错，返回-1。 这两个函数创建一个新目录项newpath，它引用现有文件existingpath。如果newpath已经存在，则返回出错。只创建newpath中最后一个分量，路径中的其他部分应当已经存在。 linkat函数使用flag参数控制指向现有符号链接还是指向现有符号链接所指向的文件。（flag = AT_SYMLINK_FOLLOW说明指向符号链接指向的文件）。 为删除一个现有的目录项，可以调用unlink函数： 1234#include &lt;unistd.h&gt;int unlink(const char *pathname);int unlinkat(int fd, const char *pathname, int flag); 若成功，返回0；若出错，返回-1。 这两个函数删除目录项，并将由pathname所引用的文件的链接计数减1。如果对该文件还有其他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不对该文件做任何更改。 只有当链接计数达到0时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——只要有进程打开了文件，其内容也不能删除。关闭一个文件时，内核首先检查打开该文件的进程个数，如果这个计数达到0，内核再去检查其链接计数；如果计数也是0，那么就删除该文件的内容。 unlinkat的flag参数给出一种方法，使调用进程可以改变unlinkat函数的默认行为。当AT_REMOVEDIR标志被设置时，unlinkat函数可以类似于rmdir一样删除目录。如果这个标志被清除，unlinkat与unlink执行同样的操作。 我们也可以使用remove函数解除对一个文件或目录的链接。对于文件，remove功能与unlink相同。对于目录，remove的功能与rmdir相同。 123#include &lt;stdio.h&gt;int remove(const char *pathname); 若成功，返回0；若出错，返回-1。 4.16 函数rename和renameat文件或目录可以用rename函数或renameat函数进行重命名。 1234#include &lt;stdio.h&gt;int rename(const char *oldname, const char *newname);int renameat(int oldfd, const char *oldname, int newfd, const char *newname); 若成功，返回0；若出错，返回-1。 4.17 符号链接硬链接直接指向文件的i节点，且有以下限制： 硬链接通常要求链接和文件位于同一文件系统中 只有超级用户才能创建指向目录的硬链接 符号链接以及它指向的何种对象无文件系统的限制，任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中的另一位置。 使用符号链接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都将返回出错，errno值为ELOOP。 这样的循环很容易消除。因为unlink并不跟随符号链接，所以可以unlink文件foo/testdir。但是如果创建了一个构成这种循环的硬链接，那么就很难消除它。 ls命令使用-l参数可以查看文件的较详细信息，包括符号链接，使用-F参数会在符号链接后加上@。 4.18 创建和读取符号链接可以使用symlink或symlinkat函数创建一个符号链接。 1234#include &lt;unistd.h&gt;int symlink(const char *actualpath, const char *sympath);int symlinkat(const char *actualpath, int fd, const char *sympath); 若成功，返回0；若出错，返回-1。函数创建一个指向actualpath的新目录项sympath。在创建此符号链接时，并不要求actualpath已经存在。并且，actualpath和sympath并不需要位于同一文件系统中。 symlinkat函数中的fd参数为已打开的文件描述符，使得sympath的路径相对于该文件描述符。如果sympath为绝对路径或fd设置为AT_FDCWD，则symlinkat与symlink等同。 由于open函数跟随符号链接，所以需要一种方法打开链接本身，并读该链接中的名字。readlink和readlinkat函数提供了这种功能： 1234#include &lt;unistd.h&gt;ssize_t readlink(const char *pathname, char *buf, size_t bufsize);ssize_t readlinkat(int fd, const char *pathname, char *buf, size_t bufsize); 两个函数组合了open、read和close的所有操作。如果函数成功，则返回读入buf的字节数。出错返回-1。在buf中返回的符号链接的内容不以null字节终止。 4.19 文件的时间 字段 说明 例子 ls(1)选项 st_atime 文件数据的最后访问时间 read -u st_mtime 文件数据的最后修改时间 write 默认 st_ctime i节点状态的最后更改时间 chmod、chown -c 注意，修改时间（st_mtime）和状态更改时间（st_ctime）之间的区别。修改时间时文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。更改文件的访问权限、更改用户ID、更改连接数等都将影响到i节点，但这些操作并没有修改文件的内容。文件的内容与文件的状态信息是分开存访的，所以，除了要记录文件数据修改时间外，还需要记录状态更改时间。 注意，系统并不维护对一个i节点的最后一次访问时间，所以access和stat函数并不更改上述3个时间中的任意一个。 4.20 函数futimens、utimensat和utimes一个文件的访问和修改时间可以用以下几个函数更改。futimens和utimensat函数可以指定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构。 1234#include &lt;sys/stat.h&gt;int futimens(int fd, const struct timespec times[2]);int utimensat(int fd, const char *path, const struct timespec times[2], int flag); 若成功，返回0；否则，返回-1。times数组第一个元素包含访问时间，第二个元素包含修改时间。这两个时间是日历时间，即从（1970年1月1日00:00:00）以来所经过的秒数。不足秒的部分用纳秒表示。 时间戳可以按下列4中方式之一进行指定： 如果times参数是一个空指针，则访问时间和修改时间两者都设置成当前时间。 如果times参数指向两个timespce结构的数组，任一数组元素的tv_nsec字段的值为UTIME_NOW，相应的时间戳就设置为当前时间，忽略相应的tv_sec字段。 如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值为UTIME_OMIT，相应的时间戳保持不变，忽略相应的tv_sec字段。 如果times参数指向两个timespec结构的数组，且tv_nsec字段的值为既不是UTIME_NOW也不是UTIME_OMIT，在这种情况下，相应的时间戳设置为相应的tv_sec和tv_nsec字段的值。 1234struct timespec &#123; time_t tv_sec; /* seconds */ long tv_nsec; /* nanoseconds */&#125;; utimensat默认行为是跟随符号链接，如果将flag参数设置为AT_SYMLINK_NOFOLLOW标志，则符号链接本身的时间就会被修改（如果路径名是符号链接）。 12#include &lt;sys/time.h&gt;int utimes(const char *pathname, const struct timeval times[2]); utimes函数对路径名进行操作。timeval结构如下： 1234struct timeval &#123; time_t tv_sec; /* seconds */ long tv_usec; /* microsecnods */&#125;; timeval结构的两个成员一个表示秒，一个表示微秒。timeval同样也是表示时间戳。调用utimes时，st_ctime字段会被自动更新。 4.21 函数mkdir、mkdirat和rmdirmkdir、mkdirat用于创建目录，rmdir用于删除目录。 1234#include &lt;sys/stat.h&gt;int mkdir(const char *pathname, mode_t mode);int mkdirat(int fd, const char *pathname, mode_t mode); 若成功返回0，出错返回-1。这两个函数将创建一个新的空目录，.和..是自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。 常见的错误是指定与文件相同的mode（只指定读、写权限）。但是，对于目录通常至少要设置一个执行权限位，以允许访问该目录中的文件名。 rmdir函数可以删除一个空目录。空目录是只能包含.和..这两项的目录。 123#include &lt;unistd.h&gt;int rmdir(const char *pathname); 4.22 读目录对某个目录具有访问权限的任一用户都可以读该目录，但是，为了防止文件系统产生混乱，只有内核才能写该目录。一个目录的写权限位和执行权限位决定了在该目录中能否创建新文件以及删除文件，它们并不表示能否写目录本身。 1234567891011121314151617#include &lt;dirent.h&gt;/* 若成功，返回指针；若出错，返回NULL */DIR *opendir(const char *pathname);DIR *fdopendir(int fd);/* 若成功，返回指针；若在目录尾或出错，返回NULL */struct dirent *readdir(DIR *dp);/* 若成功，返回0；若出错，返回-1 */void rewinddir(DIR *dp);int closedir(DIR *dp);/* 返回与dp关联的目录中的当前位置 */long telldir(DIR *dp);void seekdir(DIR *dp, long loc); dirent结构体至少包含以下两个成员： 12ino_t d_ino; /* i-node number */char d_name[]; /* null-terminated filename */ DIR结构是一个内部结构，上述7个函数用这个内部结构保存当前正在被读的目录的有关信息。 DIR结构由fdopendir创建时，readdir返回的第一项取决于传给fdopendir函数的文件描述符相关联的文件偏移量。 4.23 函数chdir、fchdir和getcwd进程调用chdir或fchdir函数可以更改当前工作目录。 1234#include &lt;unistd.h&gt;int chdir(const char *pathname);int fchdir(int fd); 若成功，返回0；若出错，返回-1。 getcwd从当前目录开始，用..找到其上一级目录，然后读其目录项，直到该目录项中的i节点编号与工作目录i节点编号相同，这样就找到了其对应的文件名。按照这种方法逐层上移，直到遇到根，这样就得到了当前工作目录完整的绝对路径名。 123#include &lt;unistd.h&gt;char *getcwd(char *buf, size_t size); 若成功，返回buf；若出错，返回NULL。必须向该函数传递两个参数，一个是缓冲区地址buf，另一个是缓冲区长度size（以字节为单位）。该缓冲区必须有足够的长度以容纳绝对路径名再加上一个终止null字节，否则返回出错。 chdir跟随符号链接，但是getcwd沿目录树向上溯源时，并不了解某个目录由符号链接所指向。 4.24 设备特殊文件每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型dev_t。主设备号标识设备驱动程序，有时编码为与其通信的外设备板；次设备号标识特定的子设备。一个磁盘驱动器经常包含若干个文件系统。在同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但是次设备号却不同。 系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点。 只有字符特殊文件和块特殊文件才有st_rdev值。此值包含实际的设备号。 major与minor用于查看主、次设备号，是两个宏。 12printf(&quot;dev = %d/%d\\n&quot;, major(buf.st_dev), minor(buf.st_dev));printf(&quot;rdev = %d/%d\\n&quot;, major(buf.st_rdev), minor(buf.st_rdev)); 第5章 标准I/O库5.1 引言标准I/O库处理很多细节，如缓冲区分配、以优化的块长度执行I/O等。这些处理使用户不必担心如何选择使用正确的块长度。 5.2 流和FILE对象第三章中的I/O操作通过打开文件得到文件描述符，进而对文件描述符进行后续I/O操作。标准I/O则是将文件与流相关联。 流的定向决定了所读写的字符是单字节还是多字节的。当一个流被创建时，它并没有定向。如果在一个未定向的流上使用多字节I/O函数，则将该流的定向设置为宽定向的。如果在一个未定向的流上使用单字节I/O函数，则将流的定向设置为单字节定向的。 有两个函数可以改变流的定向：freopen清除一个流的定向，fwide用于设置流的定向。 1234#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;int fwide(FILE *fp, int mode); 若流是宽定向的，返回正值；若流是字节定向的，返回负值；若流是未定向的，返回0。 mode参数： mode为正，fwide将试图使指定的流为宽定向的； mode为负，fwide将试图使指定的流为字节定向的； mode为0，不设置流的定向，返回流的定向。 注意，fwide并不改变已经定向的流的定向。 5.3 标准输入、标准输出和标准错误头文件stdio.h中定义：stdin、stdout、stderr。三个均为FILE *类型，即文件指针。 5.4 缓冲标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数，它也对每个I/O流自动地进行缓冲管理，从而避免了应用程序需要考虑这一点所带来的麻烦。 标准I/O提供了3种类型的缓冲： 全缓冲：在填满标准I/O缓冲区后才进行实际I/O操作。在缓冲区未满时，可使用fflush函数冲洗一个流，将缓冲区中的内容写到磁盘上。 行缓冲：当在输入和输出中遇到换行符或行缓冲区满时，标准I/O库执行I/O操作。任何时候只要通过标准I/O库要求从一个不带缓冲的流，或者一个行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流。 不带缓冲：不对字符进行缓冲存储。 标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来。 ISO C要求下列缓冲特征： 当且仅当标准输入和标准输出并不指向交互设备时，它们才是全缓冲的 标准错误决不会是全缓冲的 很多系统默认使用下列类型的缓冲： 标准错误是不带缓冲的 若是指向终端设备的流，则是行缓冲的；否则是全缓冲的 对于一个给定的流，如果我们并不喜欢这些系统默认，则可调用下列两个函数中的一个更改缓冲类型： 1234#include &lt;stdio.h&gt;void setbuf(FILE *fp, char *buf);int setvbuf(FILE *fp, char *buf, int mode, size_t size); 若成功，返回0；若出错，返回非0。这些函数必须要在对文件指针执行任何一个其他操作之前调用。 setbuf用于打开或关闭缓冲，若buf参数为NULL，则为不带缓冲。否则，参数buf必须指向一个长度为BUFSIZ的缓冲区，执行后流就是全缓冲的，但如果一个流与一个终端设备相关，那么也可能将其设置为行缓冲。 setvbuf可以精确设置所需的缓冲类型，mode参数： _IOFBF：全缓冲 _IOLBF：行缓冲 _IONBF：不带缓冲 任何时候，我们都可强制冲洗一个流： 123#include &lt;stdio.h&gt;int fflush(FILE *fp); 若成功，返回0；若出错，返回EOF。 5.5 打开流12345#include &lt;stdio.h&gt;FILE *fopen(const char *pathname, const char *type);FILE *freopen(const char *pathname, const char *type, FILE *fp);FILE *fdopen(int fd, const char *type); 三个函数若成功，返回文件指针；若出错，返回NULL。 fopen打开路径名pathname为一个指定的文件流 freopen在一个指定的流上打开一个指定的文件，若该流已经打开，则先关闭该流。若流已经定向，则使用freopen清除该定向。 fdopen取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合。 type参数： 关闭流： 123#include &lt;stdio.h&gt;int fclose(FILE *fp); 返回值：若成功，返回0；若出错，返回EOF。在该文件被关闭之前，冲洗缓冲区中的输出数据。缓冲区中的任何输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓冲区，则释放此缓冲区。 5.6 读和写流（每次一个字符）一旦打开了流，则可在3种不同类型的非格式化I/O中进行选择，对其进行读、写操作： 每次一个字符：getc(), fgetc(), getchar() 每次一行：fgets(), fputs() 直接I/O：fread(), fwrite()。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。 1. 输入函数12345#include &lt;stdio.h&gt;int getc(FILE *fp);int fgetc(FILE *fp);int getchar(); 三个函数若成功，返回下一个字符；若已达文件尾端或出错，返回EOF。 getc可被实现为宏，而fgetc不能实现为宏，是一个函数。调用fgetc所需的时间可能比getc要长，因为调用函数所需的时间通常长于调用宏。getchar相当于getc(stdin)。 注意，不管是出错还是到达文件尾端，这3个函数都返回同样的值。为了区分这两种不同的情况，必须调用ferror或feof。 1234567#include &lt;stdio.h&gt;/* 两个函数的返回值：若条件为真，返回非0；否则，返回0 */int ferror(FILE *fp);int feof(FILE *fp);void clearerr(FILE *fp); 在大多数实现中，为每个流在FILE对象中维护了两个标志： 出错标志 文件结束标志 调用clearerr可清楚这两个标志。 从流中读取数据后，可调用ungetc将字符再押送回流中。 123#include &lt;stdio.h&gt;int ungetc(int c, FILE *fp); 若成功，返回c；若出错，返回EOF。压送回流中的字符以后又可从流中读出，但读出字符的顺序与压送回的顺序相反。 2. 输出函数12345#include &lt;stdio.h&gt;int putc(int c, FILE *fp);int fputc(int c, FILE *fp);int putchar(int c); 若成功，返回c；若出错，返回EOF。 5.7 每次一行I/O1234#include &lt;stdio.h&gt;char *fgets(char *buf, int n, FILE *fp);char *gets(char *buf); 若成功，返回buf；若已到达文件尾或出错，返回NULL。这两个函数都指定了缓冲区的地址，读入的行将送入其中。gets从标准输入读，而fgets则从指定的流读。 fgets必须指定缓冲区的长度n，此函数一直读到下一个换行符为止，但是不超过n-1个字符，读入的字符被送入缓冲区。该缓冲区以null字节结尾。 gets是一个不推荐使用的函数，其问题是调用者在使用gets时不能指定缓冲区的长度。这样就可能造成缓冲区溢出。gets与fgets的另一个区别是，gets并不将换行符存入缓冲区中。 1234#include &lt;stdio.h&gt;int fputs(const char *str, FILE *fp);int puts(const char *str); 出错返回EOF。函数fputs将一个以null字节终止的字符串写到指定的流，尾端的终止符null不写出。 puts函数会在额外输出一个换行符。 5.8 标准I/O的效率5.9 二进制I/O1234#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nobj, FILE *fp);size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *fp); 两个函数的返回值：读或写的对象数。size为每个元素的长度，nobj为欲写的元素个数。 对于读，如果出错或到达文件尾，返回的数字可能小于nobj，应调用ferror或feof以判断究竟是哪一种情况。对于写，如果返回值小于nobj，则出错。 5.10 定位流123456789#include &lt;stdio.h&gt;/* 若成功，返回当前文件位置指示；若出错，返回-1L */long ftell(FILE *fp);/* 若成功，返回0；若出错，返回-1 */int fseek(FILE *fp, long offset, int whence);void rewind(FILE *fp); ftell和fseek使用长整型long来存储和设置字节位置。rewind可以将一个流设置到文件的起始位置。where参数值可为SEEK_CUR、SEEK_SET、SEEK_END。 为了定位一个文本文件，whence一定要是SEEKj_SET，且offset只有两种值：0，或是对该文件的ftell所返回的值。 1234567#include &lt;stdio.h&gt;/* 返回值：若成功，返回当前文件位置；若出错，返回(off_t)-1 */off_t ftello(FILE *fp);/* 若成功，返回0；若出错，返回-1 */int fseeko(FILE *fp, off_t offset, int whence); ftello、fseeko与ftell、fseek的区别就在于ftello和fseeko使用了off_t类型来存储位置。 1234#include &lt;stdio.h&gt;int fgetpos(FILE *fp, fpos_t *pos);int fsetpos(FILE *fp, const fpos_t *pos); 两个函数的返回值：若成功，返回0；若出错，返回非0。 fgetpos和fsetpos使用一个抽象数据类型fpos_t记录文件的位置。这种数据类型可以根据需要定义一个足够大的数，用以记录文件位置。 5.11 格式化I/O1. 格式化输出123456789101112#include &lt;stdio.h&gt;/* 返回值：若成功，返回输出字符数；若出错，返回负值 */int printf(const char *format, ...);int fprintf(FILE *fp, const char *format, ...);int dprintf(int fd, const char *format, ...);/* 返回值：若成功，返回存入数组的字符数；若编码错误，返回负值 */int sprintf(char *buf, const char *format, ...);/* 若缓冲区足够大，返回将要存入数组的字符数；若编码错误，返回负值 */int snprintf(char *buf, size_t n, const char *format, ...); printf fprintf 写至指定的流 dprintf 写至指定的文件描述符 sprintf 将格式化的字符送入数组buf中，sprintf 在该数组的尾端自动加一个null字节，但该字符不包括在返回值中 snprintf 解决了sprintf的缓冲区溢出问题，超过缓冲区尾端写的所有字符都被丢弃。 转换说明： 1%[flags][fldwidth][precision][lenmodifier]convtype flags: lenmodifier: convtype: 2. 格式化输入12345#include &lt;stdio.h&gt;int scanf(const char *format, ...);int fscanf(FILE *fp, const char *format, ...);int sscanf(const char *buf, const char *format, ...); scanf族用于分析输入字符串，并将字符序列转换成指定类型的变量。格式之后的个参数包含了变量的地址，用转换结果对这些变量赋值。 5.12 实现细节标准I/O库最终都要调用第3章说明中的I/O例程。每个标准I/O流都有一个与其相关联的文件描述符，可以对一个流调用fileno函数以获得其描述符。 123#include &lt;stdio.h&gt;int fileno(FILE *fp); 5.13 临时文件1234567#include &lt;stdio.h&gt;/* 返回唯一路径名的指针 */char *tmpnam(char *ptr);/* 若成功，返回文件指针；若出错，返回NULL */FILE *tmpfile(void); tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时，都产生一个不同的路径名，最多调用次数是TMP_MAX。TMP_MAX定义在stdio.h中。如果ptr参数为NULL，则所产生的路径名存放在一个静态区中，指向静态区的指针作为函数值返回。后续调用tmpnam时，会重写该静态区。如果prt不是NULL，则认为它应该是指向长度至少是L_tmpnam个字符的数组（L_tmpnam是一个常量，定义在stdio.h中）。所产生的路径名存放在该数组中，prt也作为函数值返回。 tmpfile创建一个临时二进制文件（类型wb+），在关闭该文件或程序结束时将自动删除这种文件。 1234567#include &lt;stdio.h&gt;/* 若成功，返回指向目录名的指针；若出错，返回NULL */char *mkdtemp(char *template);/* 若成功，返回文件描述符；若出错，返回-1 */int mkstemp(char *template); mkdtemp函数创建了一个目录，该目录有一个唯一的名字；mkstemp函数创建了一个文件，该文件有一个唯一的名字。名字是通过template字符串进行选择的。这个字符串是后6位设置为XXXXXX的路径名。函数将这些占位符替换成不同的字符串来构建一个唯一的路径名。如果成功的话，这两个函数将修改template字符串反映临时文件的名字。 mkdtemp函数创建的目录使用下列访问权限位：S_IRUSR、S_IWUSR、S_IXUSR。mkstemp函数以唯一的名字创建一个普通文件并且打开该文件，该函数返回的文件描述符以读写方式打开，访问权限位设置为：S_IRUSR、S_IWUSR。 与tmpfile不同的是，mkstemp创建的临时文件并不会自动删除。 第6章 系统数据文件和信息6.1 引言系统文件： 口令文件：/etc/passwd 组文件：/etc/group UNIX系统的正常运作需要使用大量与系统有关的数据文件，这些数据文件都是ASCII文本文件，并且使用标准I/O库读这些文件。但是，对于较大的系统，顺序扫描口令文件很花费时间，我们需要能够以非ASCII文本格式存放这些文件，但仍向使用其他文件格式的应用程序提供接口。 为应用程序提供对数据文件的可移植接口是本章的主题。本章也包括了系统标识函数、时间和日期函数。 6.2 口令文件头文件pwd.h中定义的passwd结构： /etc/passwd（Linux）: 空白注释字段不产生任何影响 /usr/sbin/nologin 打印可定制的出错信息，然后以非0状态终止，可阻止一个特定用户登陆系统 nobody用户名使任何人都可登陆至系统，但其用户ID（65534）和组ID（65534）不提供任何特权。该用户ID和组ID只能访问人人皆可读、写的文件 两个获取口令文件项的函数： 1234#include &lt;pwd.h&gt;struct passwd *getpwuid(uid_t uid);struct passwd *getpwnam(const char *name); 若成功，返回指向passwd结构的指针；若出错，返回NULL。 passwd结构通常是函数内部的静态变量，只要调用任一相关函数，其内容就会被重写。 有些程序要查看整个口令文件： 1234567#include &lt;pwd.h&gt;/* 若成功，返回指针；若出错或到达文件尾，返回NULL */struct passwd *getpwent(void);void setpwent(void);void endpwent(void); 调用getpwend时，它返回口令文件中的下一个记录项。每次调用此函数都重写passwd结构。第一次调用时，它打开所使用的各个文件。在使用getpwent查看完口令文件后，一定要调用endpwent关闭这些文件。getpwent对返回记录项的顺序并无要求。 setpwent反绕它所使用的文件。 6.3 阴影口令加密口令是经单向加密算法处理过的用户口令副本。对于一个加密口令，找不到一种算法可以将其反变换到明文口令。 阴影口令（shadow password）文件中存放这些加密过的口令，与之相关的结构： 只有用户登陆名和加密口令这两个字段是必须的。阴影口令文件（/etc/shadow）文件只有root用户可读，而/etc/passwd文件可由各用户自由读取。 12345678#include &lt;shadow.h&gt;/* 若成功，返回指针；若出错，返回NULL */struct spwd *getspnam(const char *name);struct spwd *getspent(void);void setspent(void);void endspent(void); 6.4 组文件/etc/group为组文件。与之对应的C结构体是在头文件grp.h中的group： gr_men是一个指针数组，其中每一个指针指向一个属于该组的用户名。该数组以null指针结尾。 可以用下列两个函数来获取一个group的信息： 12345#include &lt;grp.h&gt;/* 若成功，返回指针；若出错，返回NULL */struct group *getgrgid(gid_t gid);struct group *getgrnam(const char *name); 如同对口令文件进行操作的函数一样，这两个函数通常也返回指向一个静态变量的指针，在每次调用时都重写该静态变量。 搜索整个组文件，使用另外几个函数： 1234567#include &lt;grp.h&gt;/* 若成功，返回指针；若出错或到达文件尾端，返回NULL */struct group *getgrent(void);void setgrent(void);void endgrent(void); 6.5 附属组ID（supplementary group ID）我们不仅可以属于口令文件记录项中组ID所对应的组，也可属于多至16各另外的组。文件访问权限检查修改为：不仅将进程的有效组ID与文件的组ID相比较，而且也将所有附属组ID与文件的组ID进行比较。 使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目，因此也就要同时属于多个组，此类情况是常有的。 6.6 实现区别 6.7 其他数据文件 一般情况下，对于每个数据文件，至少有3各函数： get函数：读下一个记录，如果需要，还会打开该文件。此种函数通常返回指向一个结构的指针。当已达到文件尾端时返回空指针。大多数get函数返回指向一个静态存储类结构的指针，如果要保存它，则需复制它。 set函数：打开相应的数据文件（如果尚未打开），然后反绕该文件。如果希望在相应文件起始处开始处理，则调用此函数。 end函数：关闭相应数据文件。 另外，还可支持某种形式的键搜索，如getpwnam、getpwuid等等。 6.8 登陆账户记录大多数UNIX系统都提供下列两个数据文件： utmp：记录当前登陆到系统的各个用户，对应命令who（/var/run/utmp） wtmp：跟踪各个登陆和注销事件，对应命令last（/var/log/wtmp） 对应的结构体： 12345struct utmp &#123; char ut_line[8]; /* tty line: &quot;ttyh0&quot;, &quot;ttyd0&quot;, &quot;ttyp0&quot;, ... */ char ut_name[8]; /* login time */ long ut_time; /* seconds since Epoch */&#125;; 登陆时，login程序填写此类型结构，然后将其写入到utmp文件中，同时也将其填写到wtmp文件中。注销时，init进程将utmp文件中相应的记录擦除（每个字节都填以null字节），并将一个新记录填写到wtmp文件中。 6.9 系统标识123#include &lt;sys/utsname.h&gt;int uname(struct utsname *name); uname函数返回与主机和操作系统有关的信息，若成功，返回非负值；若出错，返回-1。 utsname结构中，每个字段都是一个字符数组，每个数组的长度由实现确定。每个字符串都以null字节结尾。 BSD派生的系统提供gethostname函数，它只返回主机名，该名字通常就是TCP/IP网络上主机的名字。 123#include &lt;unistd.h&gt;int gethostname(char *name, int namelen); 若成功，返回0；若出错，返回-1。namelen参数指定name缓冲区长度，如若提供足够的空间，则通过name返回的字符串以null字节结尾。如果没有提供足够的空间，则没有说明通过name返回的字符串是否以null结尾。相关联的文件是/etc/hostname。 6.10 时间和日期例程time函数用于获取日历时间（从UTC到现在的秒数）： 123#include &lt;time.h&gt;time_t time(time_t *calptr); 若成功，返回时间值；若出错，返回-1。如果参数非空，则时间值也存放在由calptr指向的单元内。 clock_gettime函数可用于获取指定时钟的时间，将时间存在timespce结构中，它把时间表示为秒和纳秒： 1234#include &lt;sys/time.h&gt;/* 若成功，返回0；若出错，返回-1 */int clock_gettime(clockid_t clock_id, struct timespec *tsp); clock_id的类型为clockid_t： clock_id设置为CLOCK_REALTIME时，clock_gettime函数提供了与time函数类似的功能，不过在系统支持高精度时间值的情况下，clock_gettime可能比time函数得到更高精度的时间值。 clock_getres函数把参数tsp指向的timespec结构初始化为与clock_id参数对应的时钟精度。 1234#include &lt;sys/time.h&gt;/* 若成功，返回0；若出错，返回-1 */int clock_getres(clockid_t clock_id, struct timespec *tsp); 要对特定的时钟设置时间，可以调用clock_settime函数： 1234#include &lt;sys/time.h&gt;/* 若成功，返回0；若出错，返回-1 */int clock_settime(clockid_t clock_id, const struct timespec *tsp); gettimeofday函数以距特定时间（1970年1月1日00:00:00）的秒数的方式将当前时间存放在tp指向的timeval结构中，而该结构将当前时间表示为为秒和微妙。 123#include &lt;sys/time.h&gt;int gettimeofday(struct timeval *tp, void *tzp); tzp的唯一合法值是NULL，其他值将产生不确定的结构。某些平台支持用tzp说明时区，但这完全依赖于实现。 一旦获取这种从上述特定时间经过的秒数的整型时间值后，通常要调用函数将其转换为分解的时间结构，然后调用另一个函数生成人们可读的时间和日期。 上图中表示了时间转换关系，虚线表示受到环境变量TZ的影响。点划线标示了如何从时间相关的结构获得日历时间。 12345#include &lt;time.h&gt;/* 出错返回NULL */struct tm *gmtime(const time_t *calptr);struct tm *localtime(const time_t *calptr); localtime和gmtime将日历时间转换成分解的时间，并将这些存放在一个tm结构中： 除了月日字段，其他字段的值都以0开始。如果夏令时生效，则夏令时标志值为正；如果为非夏令时时间，则该标志值为0，如果此信息不可用，则其值为负。 localtime和gmtime的区别是：localtime将日历时间转换成本地时间（考虑本地时区和夏令时标志），而gmtime则将日历时间转换成协调统一时间的年、月、日、时、分、秒、周日分解结构。 函数mktime以本地时间的年、月、日等作为参数，将其变换成time_t值。 1234#include &lt;time.h&gt;/* 若成功，返回日历时间；若出错，返回-1 */time_t mktime(struct tm *tmptr); 函数strftime是一个类似于printf的时间值函数，非常复杂，可以通过可用的多个参数来定制产生的字符串。 1234#include &lt;time.h&gt;size_t strftime(char *buf, size_t maxsize, const char *format, const struct tm *tmptr);size_t strftime_l(char *buf, size_t maxsize, const char *format, const struct tm *tmptr, locale_t locale); 若有空间，返回存入数组的字符数（在末尾加上null终止符，但该字符不算在返回字符数中）；否则，返回0。strftime_l允许调用者将区域指定为参数，除此之外，strftime和strftime_l函数是相同的。strftime使用通过TZ环境变量指定的区域。 strptime函数是strftime的反过来版本，把字符串时间转换成分解时间。 1234#include &lt;time.h&gt;/* 若成功，返回上一次解析的字符的下一字符的指针；出错返回NULL */char *strptime(const char *buf, const char *format, struct tm *tmptr); 第7章 进程环境7.1 引言本章将学习： 当程序执行时，其main函数是如何被调用的 命令行参数是如何传递给新程序的 典型的存储空间布局是什么样式的 如何分配另外的存储空间 进程如何使用环境变量 进程的各种不同终止方式 longjum和setjmp函数以及它们与栈的交互作用 进程的资源限制 7.2 main函数C程序的main函数原型： 1int main(int argc, char *argv[]); 当内核执行C程序时（使用一个exec函数），在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址——这是由连接编辑器设置的，而连接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。 7.3 进程终止8种终止进程的方式，前5种为正常终止： 从 main 返回 调用 exit 调用 _exit 或 _Exit 最后一个线程从其启动例程返回 从最后一个线程调用 pthread_exit 3种异常终止方式： 调用abort 接到一个信号 最后一个线程对取消请求做出响应 上一节提及的启动例程是这样编写的，使得从main返回后立即调用exit函数。如果将启动例程以C代码形式表示（实际上该例程常常使用汇编语言编写），则它调用main函数的形式可能是： 1exit(main(argc, argv)); 1. 退出函数3个函数用于正常终止一个程序：_exit和_Exit立即进入内核，exit则先执行一些清理处理，然后返回内核。 123456789#include &lt;stdlib.h&gt;void exit(int status);void _Exit(int status);#include &lt;unistd.h&gt;void _exit(int status); exit函数总是执行一个标准I/O库的清理关闭操作：对于所有打开的流，调用fclose函数，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。 3个退出函数都有一个整型参数，称为终止状态。大多数UNIX系统shell都提供检查进程终止状态的方法。如果： 调用这些函数时不带终止状态 main执行了一个无返回值的return main没有声明返回类型为整型 则该进程的终止状态是未定义的。但是，若main的返回类型是整型，并且main执行到最后一条语句（隐式返回），那么该进程的终止状态是0。 2. 函数atexitatexit函数用于注册终止处理程序（exit handler），这些函数注册后由exit自动调用。 123#include &lt;stdlib.h&gt;int atexit(void (*func)(void)); /* 若成功，返回0；若出错，返回非0 */ exit调用这些函数的顺序与它们注册时候的顺序相反，同一函数若登记多次，也会被调用多次。 exit首先调用各终止处理程序，然后关闭所有打开流。内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显式或隐式地调用_exit或_Exit。进程也可非自愿地由一个信号使其终止。 7.4 命令行参数当执行一个程序时，调用exec的进程可将命令行参数传递给该新程序。 解析命令行参数： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]) &#123; int flags, opt; int nsecs, tfnd; nsecs = 0; tfnd = 0; flags = 0; while ((opt = getopt(argc, argv, &quot;nt:&quot;)) != -1) &#123; switch (opt) &#123; case &#x27;n&#x27;: flags = 1; break; case &#x27;t&#x27;: nsecs = atoi(optarg); tfnd = 1; break; default: fprintf(stderr, &quot;Usage: %s [-t nsecs] [-n] name\\n&quot;, argv[0]); exit(EXIT_FAILURE); &#125; &#125; printf(&quot;name argument = %s\\n&quot;, argv[optind]); exit(EXIT_SUCCESS);&#125; 7.5 环境表每个程序都接收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以空字符结尾的C风格字符串的地址。全局变量environ则包含了该指针数组的地址： 1extern char **environ; 我们称 environ 为环境指针，各指针指向的字符串为环境字符串。通常使用getenv和putenv函数来访问特定的环境变量，而不是用environ变量。但是，如果要查看整个环境，则必须使用environ指针。 7.6 C程序的存储空间布局（内存模型） 历史沿袭至今，C程序一直由以下几部分组成： 正文段：这是由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序（如编译器、shell等）在存储器中也只需有一个副本。另外，正文段常常是只读的，以防止程序由于意外而修改其指令。 初始化数据段：通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。例如，C程序中任何函数之外的声明： 1int maxcount = 99; 未初始化数据段：通常将此段称为bss段，在程序开始执行之前，内核将此段中的数据初始化为0或空指针。如函数外的声明： 1long sum[1000]; 栈：自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C递归函数可以工作。递归函数每次调用自身时，就用一个新的栈帧，因此一次函数调用实例中的变量集不会影响另一次函数调用实例中的变量。 堆：通常在堆中进行动态内存分配。 从图7-6中可以看出，未初始化数据段的内容并不存放在磁盘程序文件中。其原因是，内核在程序开始运行前将它们都设置为0。需要存放在磁盘程序文件中的段只有正文段和初始化数据段。 size命令报告正文段、数据段和bss段的长度（以字节为单位）： 7.7 共享库共享库使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种例程的一个副本。程序第一次执行或第一次调用某个函数库时，用动态链接方法将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。 共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑。 下面是一个例子，不使用共享库： 使用共享库： 使用共享库后，执行文件的正文段和数据段的长度都显著减小。 7.8 存储空间分配12345678#include &lt;stdlib.h&gt;/* 三个函数返回值：若成功，返回非空指针；若出错，返回NULL */void *malloc(size_t size);void *calloc(size_t nobj, size_t size);void *realloc(void *ptr, size_t newsize);void free(void *ptr); malloc 分配指定字节数的存储区，此存储区的初始值不确定（垃圾数据）。 calloc 为指定数量指定长度的对象分配空间，该空间中每一位都初始化为0。 realloc 增加或减少以前分配区的长度。当增加长度时，可能需要将以前分配区的内容移到另一个足够大的区域（该过程由realloc自动完成），以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。注意，realloc的第二个参数是存储区的新长度，不是新、旧长度之差。作为一个特例，若ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度为newsize的存储区。 致命性错误： 释放一个已经释放了的块； 调用free时所使用的指针不是3个alloc函数的返回值 替代的存储空间分配程序 - allocaalloca是在当前函数的栈帧上分配存储空间，而不是在堆中。 优点：当函数返回时，自动释放它所使用的栈帧，所以不必再为释放空间而费心。 缺点：alloca函数增加了栈帧的长度，有些系统在函数被调用后不能增加栈帧长度，于是也就不支持alloca函数。 7.9 环境变量123#include &lt;stdlib.h&gt;char *getenv(const char *name); /* 若找到，返回指向与name关联的value的指针；若未找到，返回NULL */ 我们应当使用getenv从环境变量中取一个指定环境变量的值，而不是直接访问environ。 环境变量： 修改环境变量： 12345678#include &lt;stdlib.h&gt;/* 若成功，返回0；若出错，返回非0 */int putenv(char *str);/* 若成功，返回0；若出错，返回-1 */int setenv(const char *name, const char *value, int rewrite);int unsetenv(const char *name); putenv 取形式为 name=value 的字符串，将其放到环境表中。如果name已经存在，则先删除其原来的定义。 setenv 将 name 设置为 value。如果环境中 name 已经存在，那么使用 rewrite 来设置是否删除现有定义（rewrite = 1，删除现有定义）。 unsetenv 删除 name 的定义。即使不存在这种定义也不算出错。 注意，putenv 和 setenv 之间的区别。setenv 必须分配存储空间，以便依据其参数创建 name = value 字符串。putenv 可以自由地将传递给它的参数字符串直接放到环境中。确实，许多实现就是这么做的，因此，将存访在栈中的字符串作为参数传递给 putenv 就会发生错误，其原因是，从当前函数返回时，其栈帧占用的存储区可能被重用。 环境表在进程的内存空间中处于顶部，删除一个环境字符串很简单，只要将后续指针前移。增加一个环境字符串则困难的多，既不能向上扩展，也不能向下扩展（下为栈），该空间的长度不能再增加。 修改现有的name 如果新 value 的长度少于或等于现有的 value 的长度，只要将新字符串复制到原字符串所用的空间中 如果新 value 的长度大于现有的 value 的长度，必须调用malloc为新字符串分配空间并将其复制到新分配的空间中，接着使用环境表中针对 name 的指针指向新分配区 增加一个新的 name，首先，必须调用malloc为 name=value 字符串分配空间，然后将此字符串复制到新分配空间中 如果这是第一次增加一个新 name，必须调用malloc为新的指针表分配空间，接着，将原来的环境表复制到新分配区，并将指向新 name=value 字符串的指针存放在该指针的表尾，然后又将一个空指针存放其后。最后使用environ指向新的指针表。 如果不是第一次增加新name，只需调用realloc，分配比原空间多存放一个指针的空间。然后将新向 name=value 字符串的指针放在该表表尾，后面跟着一个空指针。 7.10 setjmp 和 longjmp在C中，goto语句是不能跨越函数的，而执行这种类型跳转功能的是非局部goto——setjmp 和 longjmp函数。非局部指的是在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中。 123456#include &lt;setjmp.h&gt;/* 若直接调用，返回0；若从longjmp返回，则为longjmp设置的val值 */int setjmp(jmp_buf env);void longjmp(jmp_buf env, int val); 自动变量、寄存器变量和易失变量使用 longjmp 回到 setjmp 处时，自动变量、寄存器变量状态如何？看情况。大多数实现并不回滚这些自动变量和寄存器的值。 静态变量、全局变量、volatile修饰的自动变量、存储在内存上的自动变量不会回滚 寄存器变量、自动变量（使用优化编译后存储在寄存器上）会回滚 或者可以说存储在内存中的变量不会回滚，而存储在寄存器上的变量会回滚。 7.11 getrlimit 和 setrlimit每个进程都有一组资源限制，其中一些可以使用 getrlimit 和 setrlimit 函数查询和更改。 12345#include &lt;sys/resource.h&gt;/* 若成功，返回0；若出错，返回非0 */int getrlimit(int resource, struct rlimit *rlptr);int setrlimit(int resource, const struct rlimit *rlptr); 1234struct rlimit &#123; rlim_t rlim_cur; /* soft limit: current limit */ rlim_t rlim_max; /* hard limit: maximum value for rlim_cur */&#125;; 进程的资源限制通常是在系统初始化时由0进程建立的，然后由后续进程继承。每种实现都可以用自己的方法对资源限制做出调整。 软限制可以被任何进程修改，修改后其值必须小于或等于其硬限制。 硬限制可以被任何进程降低，但必须大于等于其软限制值，且这种降低对普通用户而言是不可逆的。 只有超级用户进程可以提升硬限制值。 常量RLIM_INFINITY指定了一个无限量的限制。 第8章 进程控制8.1 引言 进程控制：创建新进程、执行程序、进程终止 进程属性的各种ID——实际、有效和保存的用户ID和组ID 解释器文件 system函数 进程会计机制 8.2 进程标识每个进程都有一个非负整型表示的唯一进程ID。虽然是唯一的，但进程ID是可复用的，当一个进程终止后，其进程ID就成为复用的候选者。 0：调度进程，常被称为交换进程，是内核的一部分，不执行任何磁盘上的程序。 1：init进程，在自举过程结束时由内核调用。init通常读取与系统有关的初始化文件，并将系统引导到一个状态。init进程绝不会终止。它是一个普通的用户进程，但是它以超级用户特权运行。 2：页守护进程，负责支持虚拟存储器系统的分页操作。 12345678#include &lt;unistd.h&gt;pid_t getpid(void); // 进程IDpid_t getppid(void); // 父进程IDuid_t getuid(void); // 实际用户IDuid_t geteuid(void); // 有效用户IDgid_t getgid(void); // 实际组IDgit_t getegid(void); // 有效组ID 8.3 函数 fork一个现有的进程可以调用fork函数创建一个新进程。 1234#include &lt;unistd.h&gt;/* 子进程返回0，父进程返回子进程ID，出错返回-1 */pid_t fork(void); fork 函数被调用一次，但返回两次。进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0。 子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本，子进程获得父进程的数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。 写时复制（Copy-On-Write，COW）：由于fork之后经常跟随着exec，所以现在很多实现并不执行一个父进程数据段、栈和堆的完全副本。这些区域由父进程和子进程共享，并且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”。 文件共享在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说，就好像执行了dup函数。父进程和子进程每个相同的打开描述符共享一个文件表项，其文件偏移量是共享的。 fork之后处理文件描述有以下两种常见的情况： 父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行读、写操作的任一共享描述符的文件偏移量已做了相应更新。 父进程和子进程各自执行不同的程序段。在这种情况下，在fork之后，父进程和子进程各自关闭它们不需使用的文件描述符，这样就不会干扰对方使用文件描述符。这种方法是网络服务进程经常使用的。 除了打开文件之外，父进程的很多属性也由子进程继承，包括： 实际用户ID、实际组ID、有效用户ID、有效组ID 附属组ID 进程组ID 会话ID 控制终端 这是用户ID标志和设置组ID标志 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭标志 环境 连接的共享存储段 存储映像 资源限制 父进程和子进程之间的区别具体如下： fork的返回值不同 进程ID不同 这两个进程的父进程ID不同 子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0 子进程不继承父进程设置的文件锁 子进程的未处理闹钟被清除 子进程的未处理信号集被设置为空集 8.4 函数vforkvfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。且vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。（如果调用这两个函数之前子进程依赖父进程的进一步动作，则会导致死锁。） vfork并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec（或exit），于是就不会引用该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。因此，在子进程中改变fork之前的变量，会使得父进程中的变量更新。 8.5 函数exit如果父进程在子进程之前终止，对于父进程已终止的所有进程，它们的父进程都改变为 init 进程。我们称这些进程由 init 进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1。这种处理方式保证了每个进程有一个父进程。 如果子进程在父进程之前终止，那么父进程如何能在做相应检查时获得子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。 一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵死进程。ps命令将僵死进程的状态打印为Z。 一个由init进程收养的进程终止时会发生什么？它会不会编程一个僵死进程？答案是不会。因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也防止了系统中塞满僵死进程。 8.6 函数wait和waitpid当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号，该信号是内核向父进程发送的异步通知。对于这种信号系统默认动作是忽略它。 调用wait或waitpid的进程可能会发生什么： 如果它没有任何子进程，则立即出错返回 如果其所有子进程还在运行，则阻塞 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。 12345#include &lt;sys/wait.h&gt;/* 若成功，返回进程ID；若出错，返回0或-1 */pid_t wait(int *statloc);pid_t waitpid(pid_t pid, int *statloc, int options); 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选项，可使调用者不阻塞。 waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。 以上是用于检查wait获取的statloc的宏。 如果一个父进程有几个子进程，那么只要一个子进程终止，wait就返回。waitpid函数提供了等待一个特定进程的功能。对于waitpid中的pid参数： -1：等待任一子进程，此时与wait等效 >0：等待进程ID与pid相等的子进程 ==0：等待组ID等于调用组进程ID的任意子进程 pid&lt;-1：等待组ID等于pid绝对值的任一子进程 对于wait，其唯一的出错就是调用进程没有子进程。但是对于waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错。 waitpid的options参数使我们能进一步控制waitpid的操作。此参数或者为0，或者为下图中常量按位或运算的结果。 如果一个进程fork一个子进程，但不要等待子进程终止，也不希望子进程处于僵死状态直到父进程结束，实现这一要求的诀窍是调用fork两次，让第一个子进程先终止并等待，使得第二个子进程的父进程变成init，而不等待第二个子进程。 123456789101112131415161718192021222324#include &quot;apue.h&quot;#include &lt;sys/wait.h&gt;int main()&#123; pid_t pid; if ((pid = fork()) &lt; 0) err_sys(&quot;fork error&quot;); else if (pid == 0) &#123; if ((pid = fork()) &lt; 0) err_sys(&quot;fork error&quot;); else if (pid &gt; 0) exit(0); // 第一个子进程结束，该子进程的子进程被init进程收养，而不会由于未等待其结束变成僵尸进程。 sleep(2); printf(&quot;second child, parent pid = %ld\\n&quot;, (long)getppid()); exit(0); &#125; if (waitpid(pid, NULL, 0) != pid) // 等待第一个子进程结束 err_sys(&quot;waitpid error&quot;); exit(0); 8.7 函数waitid1234#include &lt;sys/wait.h&gt;/* 若成功，返回0；若出错，返回-1 */int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); 与waitpid相似，waitid允许一个进程指定要等待的子进程。 8.8 函数wait3和wait4wait3、wait4 比wait、waitpid、waitid所提供的功能要多一个，这与附加参数有关。该参数允许内核返回由终止进程及其所有子进程使用的资源概况。 12345678#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;/* 若成功，返回进程ID；若出错，返回-1 */pid_t wait3(int *statloc, int options, struct rusage *rusage);pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage); 8.9 竞争条件当各进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为这发生了竞争条件（race condition）。 如果一个父进程要等待其子进程终止，使用wait函数中的一个。 如果一个子进程要等待其父进程终止，则可以使用轮询： 12while (getppid() != 1) sleep(1); 但这种方式浪费了时间。为避免竞争条件和轮询，可使用信号机制或IPC。 8.10 函数execexec并不创建新程序，所以前后的进程ID并未改变，exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。 基本进程控制原语： fork：创建进程 exec：初始执行新的程序 exit：处理终止 wait：等待终止 123456789101112#include &lt;unistd.h&gt;/* * 7个函数，若出错，返回-1；若成功，不返回 */int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);int execv(const char *pathname, char *const argv[]);int ececle(const char *pathname, const char *arg0, ..., /* (char *)0, char *const envp[] */);int execve(const char *pathname, char *const argv[], char *const envp[]);int execlp(const char *filename, const char *arg0, ... /* (char *) 0 */);int ececvp(const char *filename, char *const argv[]);int fexecve(int fd, char *const argv[], char *const envp[]); 前四个以路径名作为参数，后两个以文件名作为参数，最后一个以文件描述符作为参数。当以文件名作为参数时： 如果filename包含/，则就将其视为路径名pathname。 否则，按PATH环境变量，在个目录下搜索可执行文件 简记： l：表示列表，命令的参数分开传递，以(char *)0结尾 v：表示矢量，命令的参数使用char *数组传递 e：传递环境变量 p：使用filename而不是路径名 f：使用文件描述符 前面曾提及，在执行exec后，进程ID没有改变。但新程序从调用进程继承了的下列属性： 进程ID和父进程ID 实际用户ID和实际组ID 附属组ID 进程组ID 会话ID 控制终端 闹钟尚余留的时间 当前工作目录 根目录 文件模式创建屏蔽字 文件锁 进程信号屏蔽 未处理信号 资源限制 nice值 tms_utime、tms_stime、tms_cutime以及tms_cstime值 对打开文件的处理与每个描述符的执行时关闭（close-on-exec）标志值有关。FD_CLOEXEC标志，进程中每个打开描述符都有一个执行时关闭标志。若设置了此标志，则在执行exec时关闭该描述符；否则该描述符任然打开。除非特地用fcntl设置了该执行时关闭标志，否则系统的默认操作是在exec后仍保持这种描述符打开。对于目录流，明确要求exec时关闭。 在exec前后实际用户ID和实际组ID保持不变，而有效ID是否改变则取决于所执行程序文件的设置用户ID和设置组ID位是否设置。如果新程序的设置用户ID位已设置，则有效用户ID变为程序文件所有者的ID；否则有效用户ID不变。对组ID的处理方式与此相同。 7个函数中只有execve是系统调用，其他6个是库函数。 8.11 更改用户ID和更改组IDUNIX系统中，特权以及访问控制是基于用户ID和组ID的。一般而言，在设计应用时，我们总是试图使用最小特权模型。 可使用setuid函数设置实际用户ID和有效用户ID，用setgid函数设置实际组ID和有效组ID。 1234#include &lt;unistd.h&gt;int setuid(uid_t uid);int setgid(gid_t gid); 更改用户ID的规则： 若进程具有超级用户特权，则 setuid 函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为 uid。 若进程没有超级用户特权，但是 uid 等于实际用户ID或保存的设置用户ID，则 setuid 只将有效用户ID设置为 uid。不更改实际用户ID和保存的设置用户ID。 如果上面两个条件都不满足，则 errno 设置为 EPERM，并返回-1。 关于内核维护的3个用户ID，还需要注意以下几点： 只有超级用户进程可以更改实际用户ID。通常，实际用户ID是在用户登陆时，由login程序设置的，而且决不会改变它。因为login是一个超级用户进程，当它调用 setuid 时，设置所有3个用户ID。 仅当对程序文件设置了设置用户ID位时，exec 函数才设置有效用户ID。如果设置用户ID位没有设置，exec函数不会改变有效用户ID，而将维持现有值。任何时候都可以调用setuid，将有效用户ID设置为实际用户ID或保存的设置用户ID。自然地，不能将有效用户ID设置为任一随机值。 保存的设置用户ID是由exec复制有效用户ID而得到的。如果设置了文件的设置用户ID，则在exec根据文件的用户ID设置了进程的有效ID后，这个副本就被保存起来了。 函数 setreuid 和 setregidsetreuid用于交换实际用户ID和有效用户ID的值。 12345#include &lt;unistd.h&gt;/* 若成功，返回0；’若出错，返回-1 */int setreuid(uid_t ruid, uid_t euid);int setregid(gid_t rgid, git_t egid); 若其中任一参数值为-1，则表示相应的ID应当保持不变。 规则很简单：一个非特权用户总能交换实际用户ID和有效用户ID。这就允许一个设置用户ID程序交换成用户的普通权限，以后又可再次交换回设置用户ID权限。 函数 seteuid 和 setegid只更改有效用户ID和有效组ID。 12345#include &lt;unistd.h&gt;/* 若成功，返回0；若出错，返回-1 */int seteuid(uid_t uid);int setegid(gid_t gid); 一个非特权用户可将其有效用户ID设置为其实际用户ID或其保存的设置用户ID。对于一个特权用户，则可以将有效用户ID设置为uid。 8.13 函数system123#include &lt;stdlib.h&gt;int system(const char *cmdstring); 如果cmdstring是一个空指针，仅当系统支持system函数时，返回非0值。这一特征用来检测在给定的操作系统上是否支持system函数。 system在其实现中调用了fork、exec和waitpid，因此有3中返回值: fork失败或者waitpid返回除EINTR之外的出错，则system返回-1，并且设置errno以指示错误类型。 如果exec失败，则其返回值如同shell执行了exit(127)。 否则所有3个函数都成功，那么system的返回值是shell的终止状态。 设置用户ID程序如果在一个设置用户ID程序中调用system，那会发生什么呢？这是一个安全方面的漏洞，决不应当这样做。 8.17 进程时间在1.10节中我们介绍了可以度量的3个时间：时钟时间、用户CPU时间和系统CPU时间。任一进程都可调用times函数获得它自己以及已终止子进程的上述值。 1234#include &lt;sys/times.h&gt;/* 若成功，返回流逝的墙上时钟时间（以时钟滴答数为单位）；若出错，返回-1 */clock_t times(struct tms *buf); 此函数填写由 buf 指向的tms结构，该结构定义如下： 123456struct tms &#123; clock_t tms_utime; /* user CPU time */ clock_t tms_stime; /* system CPU time */ clock_t tms_cutime; /* user CPU time, terminated children */ clock_t tms_cstime; /* system CPU time, terminated children */&#125;; 注意，此结构没有包含墙上时钟时间，times函数返回墙上时钟时间作为其函数值。此值是相对于过去的某一时刻度量的，所以不能用绝对值而必须使用其相对值，即两次调用times，用两次返回的差值作为墙上时钟时间。 所有由此函数返回的clock_t值都用_SC_CLK_TCK转换成秒数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &quot;apue.h&quot;#include &lt;sys/times.h&gt;static void pr_times(clock_t, struct tms*, struct tms*);static void do_cmd(char *);int main(int argc, char *argv[])&#123; int i; setbuf(stdout, NULL); for (i = 1; i &lt; argc; i++) do_cmd(argv[i]); exit(0);&#125;static void do_cmd(char *cmd)&#123; struct tms tmsstart, tmsend; clock_t start, end; int status; printf(&quot;\\ncommand: %s\\n&quot;, cmd); if ((start = times(&amp;tmsstart)) == -1) err_sys(&quot;times_error&quot;); if ((status = system(cmd)) &lt; 0) err_sys(&quot;system() error&quot;); if ((end = times(&amp;tmsend)) == -1) err_sys(&quot;times error&quot;); pr_times(end-start, &amp;tmsstart, &amp;tmsend); pr_exit(status);&#125;static void pr_times(clock_t real, struct tms *tmsstart, struct tms *tmsend)&#123; static long clktck = 0; if (clktck == 0) if ((clktck = sysconf(_SC_CLK_TCK)) &lt; 0) // 获取转换进制 err_sys(&quot;sysconf error&quot;); printf(&quot; real: %7.2f\\n&quot;, real / (double)clktck); printf(&quot; user: %7.2f\\n&quot;, (tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime) / (double)clktck); printf(&quot; sys: %7.2f\\n&quot;, (tmsend-&gt;tms_stime - tmsstart-&gt;tms_stime) / (double)clktck); printf(&quot; child user: %7.2f\\n&quot;, (tmsend-&gt;tms_cutime - tmsstart-&gt;tms_cutime) / (double)clktck); printf(&quot; child sys: %7.2f\\n&quot;, (tmsend-&gt;tms_cstime - tmsstart-&gt;tms_cstime) / (double)clktck);&#125; 第9章 进程关系9.1 引言本章将更详细地说明进程组以及会话的概念，还将介绍登陆shell和所有从登陆shell启动的进程之间的关系。 9.2 终端登陆先说明当我们登陆到UNIX系统时所执行的各个程序。终端或者是本地的，或者是远程的，登陆都经由内核中的终端设备驱动程序。因为连接到主机上的终端设备数是固定的，所以同时的登陆数也就有了已知的上限。 系统管理者创建通常名为/etc/ttys的文件，其中，每个终端设备都有一行，每一行说明设备名和传到getty程序的参数。当系统自举时，内核创建进程ID为1的init进程。init进程是系统进入多用户模式。init读取文件/etc/ttys，对每一个允许登陆的终端设备，init调用一次fork，它所生成的子进程则exec getty程序。图9-1中所有进程的实际用户ID和有效用户ID都是0，init以空环境exec getty程序。 getty对终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0、1、2就被设置到该设备。然后getty输出“login：”之类的信息，并等待用户键入用户名。 当用户键入用户名后，getty的工作就完成了。然后它以类似于下列的方式调用login程序： 1execle(&quot;/bin/login&quot;, &quot;login&quot;, &quot;-p&quot;, username, (char*)0, envp); init以一个空环境调用getty，getty以终端名和在gettytab中说明的环境字符串为login创建一个环境（envp参数）。-p标志通知login保留传递给它的环境，也可将其他环境字串加到该环境中，但是不要替换它。 因为最初的init进程具有超级用户权限，所以图9-2中的所有进程都有超级用户权限。图9-2中底部3个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且，除了最初的init进程，所有进程的父进程ID都是1。 login能处理多项工作。因为它得到了用户名，所以能调用getpwnam取得相应的口令文件登录项。然后getpass以显示提示“Password：”，接着读用户键入的口令。它调用crypt将用户键入的口令加密，并与该用户在阴影口令文件中登录想的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数l调用exit表示登陆过程失败。父进程（init）了解到子进程的终止情况后，将再次调用fork，其后又执行了getty，对终端重复上述过程。 如果用户登陆正确，login就将完成如下工作： 将当前工作目录更改为该用户的起始目录 调用chown更改该终端的所有权，使登陆用户成为它的所有者 将对该终端设备的访问权限改变成“用户读和写” 调用setgid及initgroups设置进程的组ID 用login得到的所有信息初始化环境：起始目录（HOME）、shell（SHELL）、用户名（USER和LOGNAME）以及一个系统默认路径（PATH） login进程更改登陆用户的用户ID（setuid）并调用该用户的登陆shell，其方式类似于： 1execl(&quot;/bin/sh&quot;, &quot;-sh&quot;, (char *)0); argv[0]的第一个字符负号“-”是一个标志，表示该shell被作为登陆shell调用。 至此，登陆用户的登陆shell开始运行。 9.3 网络登陆网络登陆时，在终端和计算机之间的连接不再是点到点的。在网络登陆情况下，login仅仅是一种可用的服务，这与其他网络服务（如FTP或SMTP）的性质相同。所有登录都经由内核的网络接口驱动程序（如以太网驱动程序），并且事先并不知道将会有多少这样的登陆。 系统使用伪终端的软件驱动程序，仿真串行终端的运行行为，并将终端操作映射为网络操作。 作为系统启动的一部分，init调用一个shell，使其执行shell脚本/etc/rc，由此shell脚本启动一个守护进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后生成的子进程exec适当的程序。 telnetd进程打开一个伪终端设备，并用fork分成两个进程。父进程处理网络连接的通信，子进程则执行login程序。父进程和子进程通过伪终端相连接。在调用exec之前，子进程使用其文件描述符0、1、2与伪终端相连。如果登陆正确，login就执行9.2节中所述的同样步骤——更改当前工作目录为起始目录、设置登陆用户的组ID、用户ID以及初始环境。然后login调用exec将其自身替换为登陆用户的登陆shell。 需要理解的重点是：当通过终端或网络登陆时，我们得到一个登陆shell，其标准输入、标准输出和标准错误要么连接到一个终端设备，要么连接到一个伪终端设备上。这一登陆shell是一个会话的开始，而此终端或伪终端则是会话的控制终端。 9.4 进程组进程组是一个或多个进程的集合，通常，它们是在同一作业中结合起来的，同一进程组中的各进程接受来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。 1234567#include &lt;unistd.h&gt;// 返回调用进程的进程组IDpid_t getpgrp(void);// 若成功，返回进程组ID；若出错，返回-1pid_t getpgid(pid_t pid); getpgid(0)等效于getpgrp()。 每个进程组都有一个组长进程。组长进程的进程组ID等于其进程ID。 进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。 进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组。 1234#include &lt;unistd.h&gt;/* 若成功，返回0；若出错，返回-1 */int setpgid(pid_t pid, pid_t pgid); setpgid函数将pid进程的进程组ID设置为pgid。如果这两个参数相等，则由pid指定的进程变成进程组组长。如果pid是0，则使用调用者的进程ID。另外，如果pgid是0，则由pid指定的进程ID用作进程组ID。一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后，它就不再更改该子进程的进程组ID。 9.5 会话会话（session）是一个或多个进程组的集合。 通常是由shell的管道将几个进程编成一组的。上图所示的安排可能是由下列形式的shell命令形成的： 12$ proc1 | proc2 &amp;$ proc3 | proc4 | proc5 进程调用setsid函数建立一个新会话： 1234#include &lt;unistd.h&gt;/* 若成功，返回进程组ID；若出错，返回-1 */pid_t setsid(void); 如果调用此函数的进程不是一个进程组的组长，则函数创建一个新会话，具体会发生以下三件事： 该进程变成新会话的首进程。此时，该进程是新会话中的唯一进程。 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。 该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断。 如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。 1234#include &lt;unistd.h&gt;/* 若成功，返回会话首进程的进程组ID；若出错，返回-1 */pid_t getsid(pid_t pid); 如若pid是0，getsid返回调用进程的会话首进程的进程组ID。如果pid并不属于调用者所在的会话，那么调用进程就不能得到该会话首进程的进程组ID。 9.6 控制终端会话和进程组还有一些其他特性： 一个会话可以有一个控制终端。这通常是终端设备或伪终端内设备。 建立与控制终端连接的会话首进程被称为控制进程。 一个会话中的几个进程组可以被分成一个前台进程组以及一个或多个后台进程组。 如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。 无论何时键入终端的中断键，都会将中断信号发送至前台进程组的所有进程。 无论何时键入终端的退出键，都会将退出信号发送至前台进程组的所有进程。 无论终端接口检测到调制解调器（或网络）已经断开，则将挂断信号发送至控制进程（会话首进程）。 登陆时，将自动建立控制终端。 9.8 作业控制作业控制允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下3种形式的支持： 支持作业控制的shell 内核中的终端驱动程序必须支持作业控制 内核必须提供对某些作业控制信号的支持 第10章 信号10.1 引言信号是软件中断。信号提供了一种处理异步事件的方法。 10.2 信号概念每个信号有一个名字，这些名字都以3个字符SIG开头，如： SIGABRT：夭折信号，当进程调用abort函数时产生这种信号 SIGALRM：闹钟信号，由alarm函数设置定时器超时后将产生此信号 头文件signal.h中，信号名都被定义为正整数常量。不存在编号为0的信号，POSIX.1将此信号编号值称为空信号。 信号产生： 终端产生（Ctrl+C） 硬件异常（除以0） kill函数或kill命令 软件条件（管道读进程已终止后，一个进程写此管道） 信号处理方式： 忽略此信号：大多数信号都可用这种方式处理，但有两种信号却绝不能被忽略：SIGKILL和SIGSTOP。 捕捉信号：为做到这一点，要通知内核在某种信号发生时，调用一个用户函数，执行事件处理。 执行系统默认动作：大多数信号的系统默认动作是终止该进程。 10.3 函数signal1234#include &lt;signal.h&gt;/* 若成功，返回以前的信号处理配置；若出错，返回SIG_ERR */void (*signal(int signo, void (*func)(int)))(int); signo是上一节所说的信号名。func的值是常量SIG_IGN、常量SIG_DFL或当接到此信号后要调用的函数的地址，该函数被称为信号处理程序或信号捕捉函数。 signal函数返回一个函数指针，而该指针所指向的函数无返回值，带一个整型参数。 上述声明太复杂，下面是简化的声明： 12typedef void Sigfunc(int);Sigfunc *signal(int, Sigfunc *); 当执行一个程序时，所有信号的状态都是系统默认或忽略。通常，所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。确切地讲，exec函数将原先设置为要捕捉的信号都更改为默认动作，其他信号的状态则不变（一个进程原先要捕捉的信号，当其执行一个新程序后，就不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义）。 signal函数的限制：不改变信号的处理方式就不能确定信号的当前处理方式。 10.4 不可靠信号早期的UNIX版本中，信号是不可靠的，信号可能会丢失：一个信号发生了，但进程却可能不知道这一点。同时，进程对信号的控制能力也很差，它能捕捉信号或忽略它。 有时用户希望通知内核阻塞某个信号：不要忽略该信号，在其发生时记住它，然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备。 10.5 中断的系统调用早期UNIX系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为EINTR。这样处理是因为一个信号发生了，进程捕捉到它，这意味着已经发生了某些事情，所以是个好机会应当唤醒阻塞的系统调用。 低速系统调用：可能会使进程永远阻塞的一类系统调用。 与被中断的系统调用相关的问题是必须显式地处理出错返回： 123456again: if ((n = read(fd, buf, BUFFSIZE)) &lt; 0) &#123; if (errno = EINTR) goto again; /* just an interrupted system call */ /* handle other errors */ &#125; 为帮助应用程序使其不必处理被中断地系统调用，引进了某些被中断系统调用的自动重启动：ioctl、read、readv、write、writev、wait和waitpid。 10.6 可重入函数 没有列入上表的大多数函数是不可重入的。 10.8 可靠信号术语和语义当造成信号的事件发生时，为进程产生一个信号，这个过程叫做信号产生。信号产生时，内核通常在进程表中以某种形式设置一个标志，这个过程叫做信号递送。 在信号产生和递送之间的时间间隔内，称信号是未决的（pending）。 进程可以选用“阻塞信号调用”。如果为进程产生了一个阻塞的信号，而且对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对此信号解除了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时，才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。 进程调用sigpending函数来判定哪些信号是设置为阻塞并处于未决状态的。 10.9 函数kill和raisekill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。 12345#include &lt;signal.h&gt;/* 若成功，返回0；若出错，返回-1 */int kill(pid_t pid, int signo);int raise(int signo); 调用raise(signo)等价于调用kill(getpid(), signo)。 kill的pid参数有以下4种不同的情况 pid &gt; 0：将该信号发送给进程ID为pid的进程 pid == 0：将该信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID等于发送进程的进程组ID），而且发送进程具有权限向这些进程发送信号。 pid &lt; 0：将该信号发送给其他进程组ID等于pid绝对值，而且发送进程具有权限向其发送信号的所有进程。（所有进程不包括系统进程集中的进程） pid == -1：将该信号发送给发送进程有权限向他们发送信号的所有进程。（所有进程并不包括系统进程集中的进程） 如上所述，进程将信号发送给其他进程需要权限。 POSIX.1将信号编号为0定义为空信号。如果signo参数是0，则kill仍执行正常的错误检查，但不发送信号。这常被用来确定一个特定进程是否仍然存在。如果向一个并不存在的进程发送空信号，则kill返回-1，errno被设置为ESRCH。 10.10 函数alarm和pausealarm函数可以设置一个定时器，在将来的某个时刻该定时器会超时。当定时器超时时，产生SIGALRM信号。如果忽略或不捕捉信号，则其默认动作是终止调用该alarm函数的进程。 1234#include &lt;unistd.h&gt;/* 返回0或以前设置的闹钟时间的余留秒数 */unsigned int alarm(unsigned int seconds); 每个进程只能有一个闹钟时间。如果在调用alarm时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次alarm函数调用的值返回。以前注册的闹钟时间则被新值代替。如果本次调用的seconds值为0，则取消以前的闹钟时间，将其余留值作为本次alarm调用的返回值。 pause函数使调用进程挂起直至捕捉到一个信号。 123#include &lt;unistd.h&gt;int pause(void); 只有执行一个信号处理程序并从其返回时，pause才返回。在这种情况下，pause返回-1，errno设置为EINTR。 10.11 信号集我们需要一个能表示多个信号——信号集的数据类型。sigset_t用于表示信号集，且定义了下列5种处理信号集的函数。 12345678910#include &lt;signal.h&gt;/* 若成功，返回0；若出错，返回-1 */int sigemptyset(sigset_t *set); // 初始化set，清除所有信号int sigfillset(sigset_t *set); // 初始化set，使其包含所有信号int sigaddset(sigset_t *set, int signo);int sigdelset(sigset_t *set, int signo);/* 若真，返回1；若假，返回0 */int sigismember(const sigset_t *set, int signo); 所有应用程序在使用信号集前，要对该信号集调用sigemptyset或sigfillset一次。 这些函数以及sigset_t实际都是使用位操作实现的，某一位代表一个信号。 10.12 函数sigprocmask一个进程的信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集。调用函数sigprocmask可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。 1234#include &lt;signal.h&gt;/* 若成功，返回0；若失败，返回-1 */int sigprocmask(int how, const sigset_t *set, sigset_t *oset); how参数指示如何修改当前信号屏蔽字，可选值如下表： SIG_BLOCK是或操作，而SIG_SETMASK则是赋值操作。注意，不能阻塞SIGKILL和SIGSTOP信号。 如果oset是非空指针，那么进程的当前信号屏蔽字通过oset返回。 若set是一个非空指针，则参数how指示如何修改当前信号屏蔽字。 如果set是一个空指针，则不改变该进程的信号屏蔽字，how的值也无意义。 10.13 函数ispendingsigpending函数返回一信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因而也一定是当前未决的。该信号集通过set参数返回。 1234#include &lt;signal.h&gt;/* 若成功，返回0；若出错，返回-1 */int sigpending(sigset_t, *set); 10.14 sigactionsigaction函数的功能是检查或修改（或检查并修改）与指定信号相关联的处理动作。 1234#include &lt;signal.h&gt;/* 若成功，返回0；若出错，返回-1 */int sigaction(int signo, const struct sigaction *act, struct sigaction oact); signo是要检测或修改其具体动作的信号编号。若act指针非空，则要修改其动作。如果oact指针非空，则系统经由oact指针返回该信号的上一个动作。 12345678struct sigaction &#123; void (*sa_handler)(int); /* addr of signal handler */ sigset_t sa_mask; /* additional signals to block */ int sa_flags; /* signal options, Figure 10.16 */ /* alternate handler */ void (*sa_sigaction)(int siginfo_t *, void *);&#125;; 10.15 函数sigsetjmp和函数siglongjmpsigsetjmp、siglongjmp与setjmp、longjmp之间的区别在于sigsetjmp多了一个参数savemask，当此参数为非0值使，sigsetjmp在env中保存进程的当前信号屏蔽字。当从setlongjmp跳回时，恢复保存的信号屏蔽字。 12345#include &lt;setjmp.h&gt;/* 若直接调用，返回0；若从siglongjmp调用返回，则返回非0 */int sigsetjmp(sigjmp_buf env, int savemask);void siglongjmp(sigjmp_buf env, int val); 10.16 函数sigsuspend在一个原子操作中先恢复信号屏蔽字，然后使进程休眠，这种功能使由sigsuspend函数提供的。 1234#include &lt;signal.h&gt;/* 返回-1，并将errno设置为EINTR */int sigsuspend(const sigset_t *sigmask); sigsuspend相当于先屏蔽sigmask，接着pause，在接收到一个信号后并处理，pasue返回，然后将屏蔽字恢复到设置sigmask之前。注意，是设置屏蔽字SIG_SETMASK，而不是添加SIG_BLOCK。 例子1：保护代码临界区，不被特定信号中断 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;apue.h&quot;static void sig_int(int);int main()&#123; sigset_t newmask, oldmask, waitmask; pr_mask(&quot;program start: &quot;); if (signal(SIGINT, sig_int) == SIG_ERR) err_sys(&quot;signal(SIG_INT) error&quot;); sigemptyset(&amp;waitmask); sigaddset(&amp;waitmask, SIGUSR1); sigemptyset(&amp;newmask); sigaddset(&amp;newmask, SIGINT); if (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; 0) err_sys(&quot;SIG_BLOCK error&quot;); pr_mask(&quot;in critical region: &quot;); // 屏蔽SIGUSR1，返回后恢复原来的状态 if (sigsuspend(&amp;waitmask) != -1) err_sys(&quot;sigsuspend error&quot;); pr_mask(&quot;after return from sigsuspend: &quot;); if (sigprocmask(SIG_SETMASK, &amp;oldmask, NULL) &lt; 0) err_sys(&quot;SIG_SETMASK error&quot;); pr_mask(&quot;program exit: &quot;); exit(0);&#125;static void sig_int(int signo)&#123; pr_mask(&quot;program exit: &quot;);&#125; 例子2：等待一个信号处理程序设置一个全局变量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;apue.h&quot;volatile sig_atomic_t quitflag;static void sig_int(int signo)&#123; if (signo == SIGINT) printf(&quot;\\ninterrupt\\n&quot;); else if (signo == SIGQUIT) quitflag = 1;&#125;int main()&#123; sigset_t newmask, oldmask, zeromask; if (signal(SIGINT, sig_int) == SIG_ERR) err_sys(&quot;signal (SIGINT) error&quot;); if (signal(SIGQUIT, sig_int) == SIG_ERR) err_sys(&quot;signal (SIGQUIT) error&quot;); sigemptyset(&amp;zeromask); sigemptyset(&amp;newmask); sigaddset(&amp;newmask, SIGQUIT); /* * block SIGQUIT and save current signal mask. */ if (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; 0) err_sys(&quot;SIG_BLOCK error&quot;); while (quitflag == 0) sigsuspend(&amp;zeromask); quitflag = 0; /* * Reset signal mask whick unblocks SIGQUIT */ if (sigprocmask(SIG_SETMASK, &amp;oldmask, NULL) &lt; 0) err_sys(&quot;SIG_SETMASK error&quot;); exit(0);&#125; 例子3：使用信号实现父、子进程之间的同步： 第11章 线程11.1 引言本章将进一步深入理解进程，了解如何使用多个控制线程在单进程环境中执行多个任务。一个进程中的所有线程都可以访问该进程的组成部件，如文件描述符和内存。本章的最后将讨论目前可用的同步进制，防止多个线程在共享资源时出现不一致的问题。 11.2 线程概念每个线程都包含有表示执行环境所必须的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行代码、程序的全局内存、栈以及文件描述符。 11.3 线程标识每个线程有一个线程ID，线程ID只有在它所属的进程上下文中才有意义。 线程ID是用pthread_t数据结构来表示的。 1234#include &lt;pthread.h&gt;/* 若相等，返回非0数值；否则，返回0 */int pthread_equal(pthread_t tid1, pthread_t tid2); 线程可以调用pthread_self函数获得自身的线程ID： 1234#include &lt;pthread.h&gt;/* 返回调用线程的线程ID */pthread_t pthread_self(void); 11.4 线程创建1234#include &lt;pthread.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_create(pthread_t *tidp, const pthread_attr_t *attr, void *(*start_rtn)(void *), void *arg); 当pthread_create成功返回时，新创建线程的线程ID会被设置成tidp指向的内存单元。attr参数用于定制各种不同的线程属性，为NULL时表示创建一个具有默认属性的线程。新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无指针类型参数arg。如果需要向start_rtn函数传递的参数有一个以上，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg参数传入。 线程运行时并不能保证哪个线程会先运行：是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。 11.5 线程终止如果进程中的任意线程调用了exit、_Exit或者_exit，那么整个进程就会终止。 单个线程可以通过3种方式退出，因此可以在不中止整个进程的情况下，停止它的控制流。 线程可以简单地从启动例程中返回，返回值是线程地退出码。 线程可以被同一进程中地其他线程取消。 线程调用pthread_exit。 123#include &lt;pthread.h&gt;void pthread_exit(void *rval_ptr); rval_ptr参数是一个无类型指针，与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用pthread_join函数访问到这个指针。 1234#include &lt;pthread.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_join(pthread_t thread, void **rval_ptr); 例子1：获取已终止的线程的退出码 12345678910111213141516171819202122232425262728293031323334353637#include &quot;apue.h&quot;#include &lt;pthread.h&gt;void *thr_fn1(void *arg)&#123; printf(&quot;thread 1 returning\\n&quot;); return ((void *)1);&#125;void *thr_fn2(void *arg)&#123; printf(&quot;thread 2 exiting\\n&quot;); pthread_exit((void *)2);&#125;int main()&#123; int err; pthread_t tid1, tid2; void *tret; err = pthread_create(&amp;tid1, NULL, thr_fn1, NULL); if (err != 0) err_exit(err, &quot;can&#x27;t create thread 1&quot;); err = pthread_create(&amp;tid2, NULL, thr_fn2, NULL); if (err != 0) err_exit(err, &quot;can&#x27;t create thread 2&quot;); err = pthread_join(tid1, &amp;tret); if (err != 0) err_exit(err, &quot;can&#x27;t join with thread 1&quot;); printf(&quot;thread 1 exit code %ld\\n&quot;, (long)tret); err = pthread_join(tid2, &amp;tret); if (err != 0) err_exit(err, &quot;can&#x27;t join with thread 2&quot;); printf(&quot;thread 2 exit code %ld\\n&quot;, (long)tret); exit(0);&#125; 例子2：自动变量作为pthread_exit的参数时出现的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &quot;apue.h&quot;#include &lt;pthread.h&gt;struct foo &#123; int a, b, c, d;&#125;;void printfoo(const char *s, const struct foo *fp)&#123; printf(&quot;%s&quot;, s); printf(&quot; structure at 0x%lx\\n&quot;, (unsigned long)fp); printf(&quot; foo.a = %d\\n&quot;, fp-&gt;a); printf(&quot; foo.b = %d\\n&quot;, fp-&gt;b); printf(&quot; foo.c = %d\\n&quot;, fp-&gt;c); printf(&quot; foo.d = %d\\n&quot;, fp-&gt;d);&#125;void *thr_fn1(void *arg)&#123; struct foo foo = &#123;1, 2, 3, 4&#125;; printfoo(&quot;thread 1:\\n&quot;, &amp;foo); pthread_exit((void *)&amp;foo);&#125;void *thr_fn2(void *arg)&#123; printf(&quot;thread 2: ID is %lu\\n&quot;, (unsigned long)pthread_self()); pthread_exit((void *)0);&#125;int main()&#123; int err; pthread_t tid1, tid2; struct foo *fp; err = pthread_create(&amp;tid1, NULL, thr_fn1, NULL); if (err != 0) err_exit(err, &quot;can&#x27;t create thread 1&quot;); err = pthread_join(tid1, (void *)&amp;fp); if (err != 0) err_exit(err, &quot;can&#x27;t join with thread 1&quot;); sleep(1); printf(&quot;parent starting second thread\\n&quot;); err = pthread_create(&amp;tid2, NULL, thr_fn2, NULL); if (err != 0) err_exit(err, &quot;can&#x27;t create thread 2&quot;); sleep(1); printfoo(&quot;parent:\\n&quot;, fp); exit(0);&#125; 线程可以通过调用pthread_calcel函数来请求取消同一进程中的其他线程。 1234#include &lt;pthread.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_calcel(pthread_t tid); 默认情况下，pthread_calcel函数会使得由tid标识的线程的行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit函数，但是，线程可以选择忽略取消或者控制如何被取消。 线程可以安排它退出时需要调用的函数，这与进程在退出时可以调用atexit函数安排退出是类似的。这样的函数称为线程清理处理程序。一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们注册时相反。 1234#include &lt;pthread.h&gt;void pthread_cleanup_push(void (*rtn)(void *), void *arg);void pthread_cleanup_pop(int execute); 当线程执行以下动作时，清理函数rtn是由pthread_cleanup_push函数调度的，调用时只有一个参数arg： 调用pthread_exit时 响应取消请求时 用非零execute参数调用pthread_cleanup_pop时 如果execute参数设置为0，清理函数将不被调用。不管发生上述哪种情况，pthread_cleanup_pop都将删除上次pthread_cleanup_push调用建立的清理处理程序。 例子：线程清理程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;apue.h&quot;#include &lt;pthread.h&gt;void cleanup(void *arg)&#123; printf(&quot;cleanup: %s\\n&quot;, (char *)arg);&#125;void *thr_fn1(void *arg)&#123; printf(&quot;thread 1 start\\n&quot;); pthread_cleanup_push(cleanup, &quot;thread 1 first handler&quot;); pthread_cleanup_push(cleanup, &quot;thread 1 second handler&quot;); printf(&quot;thread 1 push complete\\n&quot;); if (arg) return ((void *)1); pthread_cleanup_pop(0); pthread_cleanup_pop(0); return ((void *)1);&#125;void *thr_fn2(void *arg)&#123; printf(&quot;thread 2 start\\n&quot;); pthread_cleanup_push(cleanup, &quot;thread 2 first handler&quot;); pthread_cleanup_push(cleanup, &quot;thread 2 second handler&quot;); printf(&quot;thread 2 push complete\\n&quot;); if (arg) pthread_exit((void *)2); pthread_cleanup_pop(0); pthread_cleanup_pop(0); pthread_exit((void *)2);&#125;int main()&#123; int err; pthread_t tid1, tid2; void *tret; err = pthread_create(&amp;tid1, NULL, thr_fn1, (void *)1); if (err != 0) err_exit(err, &quot;can&#x27;t create thread 1&quot;); err = pthread_create(&amp;tid2, NULL, thr_fn2, (void *)1); if (err != 0) err_exit(err, &quot;can&#x27;t create thread 2&quot;); err = pthread_join(tid1, &amp;tret); if (err != 0) err_exit(err, &quot;can&#x27;t join with thread 1&quot;); printf(&quot;thread 1 exit code %ld\\n&quot;, (long)tret); err = pthread_join(tid2, &amp;tret); if (err != 0) err_exit(err, &quot;can&#x27;t join with thread 2&quot;); printf(&quot;thread 2 exit code %ld\\n&quot;, (long)tret); exit(0);&#125; 线程函数与进程函数的相似之处： 默认情况下，线程的终止状态会保存直到对该线程调用ptrhead_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被收回。在线程被分离后，我们不能用pthread_join函数等待它的终止状态，因为对分离状态的线程调用pthread_join会产生未定义行为。可以调用pthread_detach分离线程： 1234#include &lt;pthread.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_detach(pthread_t tid); 11.6 线程同步 11.6.1 互斥量互斥量（mutex）从本质上来说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。在对互斥量进行加锁后，任何其他试图再次对互斥量加锁的线程都会阻塞直到当前线程释放该互斥锁。pthread_mutex_t要初始化为PTHREAD_MUTEX_INITIALIZER（只适用于静态分配的互斥量），或通过pthread_mutex_init函数进行初始化。 12345#include &lt;pthread.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);int pthread_mutex_destroy(pthread_mutex_t *mutex); 加锁、解锁： 12345#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex); // 不阻塞int pthread_mutex_unlock(pthread_mutex_t *mutex); 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;struct foo &#123; int f_count; pthread_mutex_t f_lock; int f_id;&#125;;struct foo *foo_alloc(int id)&#123; struct foo *fp; if ((fp = malloc(sizeof(struct foo))) != NULL) &#123; fp-&gt;f_count = 1; fp-&gt;f_id = id; if (pthread_mutex_init(&amp;fp-&gt;f_lock, NULL) != 0) &#123; free(fp); return NULL; &#125; &#125; return fp;&#125;void foo_hold(struct foo *fp)&#123; pthread_mutex_lock(&amp;fp-&gt;f_lock); fp-&gt;f_count++; pthread_mutex_unlock(&amp;fp-&gt;f_lock);&#125;void foo_rele(struct foo *fp)&#123; pthread_mutex_lock(&amp;fp-&gt;f_lock); if (--fp-&gt;f_count == 0) &#123; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_destroy(&amp;fp-&gt;f_lock); free(fp); &#125; else &#123; pthread_mutex_unlock(&amp;fp-&gt;f_lock); &#125;&#125; 11.6.2 避免死锁可以通过仔细控制互斥量的顺序来避免发生死锁。有时候，应用程序的结构使得对互斥量进行排序是很困难的。如果涉及了太多的锁和数据结构，可用的函数并不能把它转换成简单的层次，那么就需要采用另外的方法。这种情况下，可以先释放占用的锁，然后过一段时间再试。如果不能获取锁，可以先释放已经占用的锁，做好清理工作，然后过一段时间再重新试。 11.6.3 函数pthread_mutex_timedlock当线程试图获得一个已加锁的互斥量时，pthread_mutex_timedlock互斥量原语允许绑定线程阻塞时间。pthread_mutex_timedlock函数与pthread_mutex_lock函数基本等价，但是在到达超时时间值时，pthread_mutex_timedlock不会对互斥量进行加锁，而是返回错误码ETIMEDOUT。 12345#include &lt;pthread.h&gt;#include &lt;time.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *tsptr); 例子：用pthread_mutex_timedlock避免永久阻塞 12345678910111213141516171819202122232425262728293031#include &quot;apue.h&quot;#include &lt;pthread.h&gt;int main()&#123; int err; struct timespec tout; struct tm *tmp; char buf[64]; pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_lock(&amp;lock); printf(&quot;mutex is locked\\n&quot;); clock_gettime(CLOCK_REALTIME, &amp;tout); tmp = localtime(&amp;tout.tv_sec); strftime(buf, sizeof(buf), &quot;%r&quot;, tmp); printf(&quot;current time is %s\\n&quot;, buf); tout.tv_sec += 10; err = pthread_mutex_timedlock(&amp;lock, &amp;tout); clock_gettime(CLOCK_REALTIME, &amp;tout); tmp = localtime(&amp;tout.tv_sec); strftime(buf, sizeof(buf), &quot;%r&quot;, tmp); printf(&quot;the time is now %s\\n&quot;, buf); if (err == 0) printf(&quot;mutex locked again!\\n&quot;); else printf(&quot;can&#x27;t lock mutex again:%s\\n&quot;, strerror(err)); exit(0);&#125; 11.6.4 读写锁读写锁（reader-writer lock）与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有3种状态： 读模式下加锁状态 写模式下加锁状态 不加锁状态 一次只有一个线程可以占用写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。 当读写锁处于写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁处于读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。 读写锁非常适合对于数据结构读的次数远大于写的情况。 读写锁也叫共享互斥锁（shared-exclusive lock）。当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住时，就可以说成是以互斥锁模式锁住的。 12345#include &lt;pthread.h&gt;/* 若成功，返回0；若出错，返回错误编号 */int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 除了可以使用pthread_rwlock_init函数对其进行初始化之外，还可对静态变量使用PTHREAD_RWLOCK_INITIALIZER常量进行初始化。 12345#include &lt;pthread.h&gt;int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); // 加读锁int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); // 加写锁int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); // 解锁 读写锁原语的条件版本： 12345#include &lt;pthread.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 可以获取锁时，这两个函数返回0。否则，它们返回错误EBUSY。这两个函数可以用于我们前面讨论的遵守某种锁层次但还不能完全避免死锁的情况。 例子：作业请求队列由单个读写锁保护 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;struct job &#123; struct job *j_next; struct job *j_prev; pthread_t j_id;&#125;;struct queue &#123; struct job *q_head; struct job *q_tail; pthread_rwlock_t q_lock;&#125;;/* * Initialize a queue. */int queue_init(struct queue *qp)&#123; int err; qp-&gt;q_head = NULL; qp-&gt;q_tail = NULL; err = pthread_rwlock_init(&amp;qp-&gt;q_lock, NULL); if (err != 0) return err; return 0;&#125;/* * Insert a job at the head of the queue. */void job_insert(struct queue *qp, struct job *jp)&#123; pthread_rwlock_wrlock(&amp;qp-&gt;q_lock); jp-&gt;j_next = qp-&gt;q_head; jp-&gt;j_prev = NULL; if (qp-&gt;q_head != NULL) qp-&gt;q_head-&gt;j_prev = jp; else qp-&gt;q_tail = jp; qp-&gt;q_head = jp; pthread_rwlock_unlock(&amp;qp-&gt;q_lock);&#125;/* * Append a job on the tail of the queue. */void job_append(struct queue *qp, struct job *jp)&#123; pthread_rwlock_wrlock(&amp;qp-&gt;qlock); jp-&gt;j_next = NULL; jp-&gt;j_prev = qp-&gt;q_tail; if (qp-&gt;tail != null) qp-&gt;tail-&gt;j_next = jp; else qp-&gt;q_head = jp; qp-&gt;q_tail = jp; pthread_rwlock_unlock(&amp;qp-&gt;qlock);&#125;/* * Remove the given job from a queue. */void job_remove(struct queue *qp, struct job *jp)&#123; pthread_rwlock_wrlock(&amp;qp-&gt;qlock); if (jp == qp-&gt;q_head) &#123; qp-&gt;q_head = jp-&gt;j_next; if (qp-&gt;tail == jp) qp-&gt;q_tail = NULL; else jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev; &#125; else if (jp == qp-&gt;q_tail) &#123; qp-&gt;q_tail = jp-&gt;j_prev; jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next; &#125; else &#123; jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next; jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev; &#125; pthread_rwlock_unlock(&amp;qp-&gt;qlock);&#125;/* * Find a job for the given thread ID. */struct job *job_find(struct queue *qp, pthread_t id)&#123; struct job *jp; if (pthread_rwlock_rdlock(&amp;qp-&gt;q_lock) != 0) return NULL; for (jp = qp-&gt;q_head; jp != NULL; jp = jp-&gt;j_next) if (pthread_equal(jp-&gt;j_id, id)) break; pthread_rwlock_unlock(&amp;qp-&gt;q_lock); return jp;&#125; 11.6.5 带有超时的读写锁与互斥量一样，Single UNIX Specification提供了带有超时的读写锁加锁函数，使应用程序在获取读写锁时避免陷入永久阻塞状态。这两个函数是pthread_rwlock_timedrdlock和pthread_rwlock_timedwrlock。 123456#include &lt;pthread.h&gt;#include &lt;time.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock, const struct timespec *tsptr);int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *tsptr); 超时返回ETIMEDOUT错误。 11.6.6 条件变量初始化与反初始化： 12345#include &lt;pthread.h&gt;/* 成功返回0，出错返回错误编号 */int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);int pthread_cond_destroy(pthread_cond_t *cond); 可使用PTHREAD_COND_INITIALIZER对pthread_cond_t的静态变量进行初始化。 等待条件变量变为真： 12345#include &lt;pthread.h&gt;/* 成功返回0，出错返回错误编号 */int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *tsptr); 传递给pthread_cond_wait的互斥量对条件进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。pthread_cond_wait返回时，互斥量再次被锁住。 有两个函数可以用于通知线程条件已经满足。pthread_cond_signal函数至少能唤醒一个等待该条件的线程，而pthread_cond_broadcast函数则能唤醒等待该条件的所有线程。 12345#include &lt;pthread.h&gt;/* 成功返回0，出错返回错误编号 */int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond); 在调用pthread_cond_signal或者pthread_cond_broadcast时，我们说这是在给线程或者条件发信号。必须注意，一定要在改变条件状态以后再给线程发信号。 例子：结合条件变量和互斥量对线程进行同步 123456789101112131415161718192021222324252627282930313233343536#include &lt;pthread.h&gt;struct msg &#123; struct msg *m_next;&#125;;struct msg *workq; // 工作队列pthread_cond_t qready = PTHREAD_COND_INITIALIZER;pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;void process_msg()&#123; struct msg *mp; for (;;) &#123; pthread_mutex_lock(&amp;qlock); while (workq == NULL) pthread_cond_wait(&amp;qready, &amp;qlock); mp = workq; workq = mp-&gt;m_next; pthread_mutex_unlock(&amp;qlock); &#125;&#125;/* * 把消息放入工作队列 */void enqueue_msg(struct msg *mp)&#123; pthread_mutex_lock(&amp;qlock); // 把消息放到工作队列时，需要占有互斥量 mp-&gt;next = workq; workq = mp; pthread_mutex_unlock(&amp;qlock); pthread_cond_signal(&amp;qready); // 在给等待线程发信号时，不需要占有互斥量&#125; 11.6.7 自旋锁自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前已知处于忙等阻塞状态。自旋锁可以用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。 当线程自旋锁等待锁变为可用时，CPU不能做其他的事情。这也是自旋锁只能够被持有一小段时间的原因。 12345678#include &lt;pthread.h&gt;/* 若成功，返回0；否则，返回错误编号 */int pthread_spin_init(pthread_spinlock_t *lock, int pshared);int pthread_spin_destroy(pthread_spinlock_t *lock);int pthread_spin_lock(pthread_spinlock_t *lock);int pthread_spin_trylock(pthread_spinlock_t *lock);int pthread_spin_unlock(pthread_spinlock_t *lock); 11.6.8 屏障屏障（barrier）是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都能到达某一个点，然后从该点继续执行。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。 屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作。 1234#include &lt;pthread.h&gt;int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count);int pthread_barrier_destroy(pthread_barrier_t *barrier); 初始化屏障时，可以使用count参数指定，在允许所有线程继续运行之前，必须达到屏障的线程数目。 可以使用pthread_barrier_wait函数来表明，线程已完成工作，准备等所有其他线程赶上来。 1234#include &lt;pthread.h&gt;/* 若成功，返回0或者PTHREAD_BARRLER_SERIAL_THREAD；否则，返回错误编号 */int pthread_barrier_wait(pthread_barrier_t *barrier); 调用pthread_barrier_wait的线程在屏障计数未满足条件时，会进入休眠状态。如果该线程是最后一个调用pthread_barrier_wait的线程，就满足了屏障计数，所有的线程都被唤醒。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &quot;apue.h&quot;#include &lt;pthread.h&gt;#include &lt;limits.h&gt;#include &lt;sys/time.h&gt;#define NTHR 8 // number of threads#define NUMNUM 8000000L // number of numbers to sort#define TNUM (NUMNUM/NTHR) // number of sort per threadlong nums[NUMNUM];long snums[NUMNUM];pthread_barrier_t b;#ifdef SOLARIS#define heapsort qsort#elseextern int heapsort(void *, size_t, size_t, int (*)(const void *, const void *));#endif/* * Compare two long integers (helper function for heapsort) */int complong(const void *arg1, const void *arg2)&#123; long l1 = *(long *)arg1; long l2 = *(long *)arg2; if (l1 == l2) return 0; else if (l1 &lt; l2) return -1; else return 1;&#125;/* * Worker thread to sort a portion of the set of numbers. */void *thr_fn(void *arg)&#123; long idx = (long)arg; heapsort(&amp;nums[idx], TNUM, sizeof(long), complong); pthread_barrier_wait(&amp;b); /* * Go off and perform more work ... */ return ((void *)0);&#125;/* * Merge the results of the individual sorted ranges. */void merge()&#123; long idx[NTHR]; long i, minidx, sidx, num; for (i = 0; i &lt; NTHR; i++) idx[i] = i * TNUM; for (sidx = 0; sidx &lt; NUMNUM; sidx++) &#123; num = LONG_MAX; for (i = 0; i &lt; NTHR; i++) &#123; if ((idx[i] &lt; (i + 1) * TNUM) &amp;&amp; (nums[idx[i]] &lt; num)) &#123; num = nums[idx[i]]; minidx = i; &#125; &#125; snums[sidx] = nums[idx[minidx]]; idx[minidx]++; &#125;&#125;int main()&#123; unsigned long i; struct timeval start, end; long long startusec, endusec; double elapsed; int err; pthread_t tid; /* * Create the initial set of numbers to sort. */ srandom(1); for (i = 0; i &lt; NUMNUM; i++) nums[i] = random(); /* * Create 8 threads to sort the numbers. */ gettimeofday(&amp;start, NULL); pthread_barrier_init(&amp;b, NULL, NTHR + 1); for (i = 0; i &lt; NTHR; i++) &#123; err = pthread_create(&amp;tid, NULL, thr_fn, (void *)(i * TNUM)); if (err != 0) err_exit(err, &quot;can&#x27;t create thread&quot;); &#125; pthread_barrier_wait(&amp;b); merge(); gettimeofday(&amp;end, NULL); /* * Print the sorted list. */ startusec = start.tv_sec * 1000000 + start.tv_usec; endusec = end.tv_sec * 1000000 + end.tv_usec; elapsed = (double)(endusec - startusec) / 1000000.0; printf(&quot;sort took %.4f seconds\\n&quot;, elapsed); for (i = 0; i &lt; NUMNUM; i++) printf(&quot;%ld\\n&quot;, snums[i]); exit(0);&#125; 第16章 网络IPC：套接字16.1 引言本章将描述套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论是在同一台计算机上还是在不同的计算机上。 16.2 套接字描述符应用程序用套接字描述符访问套接字，套接字描述符被当作一种文件描述符，许多处理文件描述符的函数可以用于处理套接字描述符。 为创建一个套接字，调用socket函数： 1234#include &lt;sys/socket.h&gt;/* 若成功，返回文件描述符；若出错，返回-1 */int socket(int domain, int type, int protocol); domain参数确定通信的特征，包括地址格式： type参数确定套接字的类型： 参数protocol通常为0，标识为给定的域和套接字类型选择默认协议，如domain=AF_INET且type=SOCK_STREAM时默认协议是TCP协议，domain=AF_INET且type=SOCK_DGRAM时默认协议是UDP协议。 虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可接受套接字描述符，如lseek不能以套接字为描述符参数，因为参数不支持文件偏移量的概念。 调节字通信是双向的。可以采用shutdown函数来禁止一个套接字的I/O： 1234#include &lt;sys/socket.h&gt;/* 若成功，返回0；若出错，返回-1 */int shutdown(int sockfd, int how); how参数： SHUT_RD：关闭读端 SHUT_WR：关闭写端 SHUT_RDWR：关闭读写端 16.3 寻址如何标识一个目标通信进程？IP地址+端口号。 16.3.1 字节序 字节序是一个处理器架构特性，用于指示数据类型内部的字节如何排序。 大端字节序：最大字节地址出现在最低有效字节上 小端字节序：最低有效字节包含最小字节地址 注意，不管字节如何排序，最高有效字节（MSB）总是在左边，最低有效字节（LSB）总是在右边。如0x04030201，无论字节序如何，最高有效字节都将包含4，最低有效字节都将包含1。接下来想将一个字符指针（cp）强制转换到这个整数地址，就会看到字节序的不同。小端字节序，cp[0]将包含1，大端字节序，cp[0]将包含4。 网络协议执行了字节序，因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCP/IP协议栈使用大端字节序。应用程序交换格式化数据时，字节序问题就会出现。对于TCP/IP地址用网络字节序来表示，所以应用程序有时需要在处理器的字节序与网络字节序之间转换他们。 123456#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostint32); /* 以网络字节序表示的32位整数 */uint16_t htons(uint16_t hostint16); /* 以网络字节序表示的16位整数 */uint32_t ntohl(uint32_t netint32); /* 以主机字节序表示的32位整数 */uint16_t ntohs(uint16_t netint16); /* 以主机字节序表示的16位整数 */ 16.3.2 地址格式一个地址标识一个特定通信域的套接字端点，地址格式与这个特定的通信域相关。为使不同格式地址能够传入到套接字函数，地址会被强制转换成一个通用的地址结构sockaddr： 1234567#include &lt;sys/socket.h&gt; /* In Linux */struct sockaddr &#123; sa_family_t sa_family; /* address family, AF_xxxx */ char sa_data[14]; /* variable-length address */&#125;; IPv4的地址使用sockaddr_in表示，IPv6的地址使用sockaddr_in6表示： 1234567891011121314151617181920212223#include &lt;netinet/in.h&gt;struct in_addr &#123; in_addr_t s_addr; /* IPv4 address */&#125;;struct in6_addr &#123; uint8_t&#125;// struct sockaddr_in &#123;// sa_family_t sin_family; /* address family */// in_port_t sin_port; /* port number */// struct in_addr sin_addr; /* IPv4 address */// &#125;;/* In Linux */struct sockaddr_in &#123; sa_family_t sin_family; /* address family */ in_port_t sin_port; /* port number */ struct in_addr sin_addr; /* IPv4 address */ unsigned char sin_zero[8]; /* filler */&#125;; in_addr_t定义成uint32_t，in_port_t定义成uint16_t。 有时，需要打印出能被人理解而不是计算机所理解的地址格式。BSD网络软件包含函数inet_addr和inet_ntoa，用于二进制地址格式与点分十进制字符表示之间的互相转换，但这些函数仅适用于IPv4地址。有两个新函数inet_ntop和inet_pton具有相似的功能，而且同时支持IPv4地址和IPv6地址。 123456#include &lt;arpa/inet.h&gt;/* 若成功，返回地址字符串指针；若出错，返回NULL */const char *inet_ntop(int domain, const void *addr, char *str, socklen_t size);/* 若成功，返回1；若格式无效，返回0；若出错，返回-1 */int inet_pton(int domain, const char str, void *addr); inet_ntop将网络字节序的二进制地址转换成文本字符串格式。inet_pton将文本字符串格式转换成网络字节序的二进制。 16.3.3 地址查询getaddrinfo函数允许将一个主机名和一个服务名映射到一个地址： 1234567#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;/* 若成功，返回0；若出错，返回非0错误码 */int getaddrinfo(const char *host, const char *service, const struct addrinfo *hint, struct addrinfo **res);void freeaddrinfo(struct addrinfo *ai); 需要提供主机名、服务名，或者两者都提供。如果仅仅提供一个名字，另外一个必须是一个空指针。主机名可以是一个节点名或点分格式的主机地址。getaddrinfo函数返回一个链表结构addrinfo，可用freeaddrinfo来释放一个或多个这种结构，这取决于ai_next字段链接起来的结构有多少。 addrinfo结构定义： hint是一个用于过滤的模板，包含ai_family、ai_flags、ai_protocal和ai_socktype字段。剩余的整数字段必须设置为0，指针字段必须为空。ai_flags: 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &quot;apue.h&quot;#if defined(SOLARIS)#include &lt;netinet/in.h&gt;#endif#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#if defined(BSD)#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#endifvoid print_family(struct addrinfo *aip)&#123; printf(&quot; family &quot;); switch(aip-&gt;ai_family) &#123; case AF_INET: printf(&quot;inet&quot;); break; case AF_INET6: printf(&quot;inet6&quot;); break; case AF_UNIX: printf(&quot;unix&quot;); break; case AF_UNSPEC: printf(&quot;unspecified&quot;); break; default: printf(&quot;unknown&quot;); &#125;&#125;void print_type(struct addrinfo *aip)&#123; printf(&quot; type &quot;); switch(aip-&gt;ai_socktype) &#123; case SOCK_STREAM: printf(&quot;stream&quot;); break; case SOCK_DGRAM: printf(&quot;datagram&quot;); break; case SOCK_SEQPACKET: printf(&quot;seqpacket&quot;); break; case SOCK_RAW: printf(&quot;raw&quot;); break; default: printf(&quot;unknown (%d)&quot;, aip-&gt;ai_socktype); &#125;&#125;void print_protocol(struct addrinfo *aip)&#123; printf(&quot; protocol &quot;); switch(aip-&gt;ai_protocol) &#123; case 0: printf(&quot;default&quot;); break; case IPPROTO_TCP: printf(&quot;TCP&quot;); break; case IPPROTO_UDP: printf(&quot;UDP&quot;); break; case IPPROTO_RAW: printf(&quot;raw&quot;); break; default: printf(&quot;unknown (%d)&quot;, aip-&gt;ai_protocol); &#125;&#125;void print_flags(struct addrinfo *aip)&#123; printf(&quot;flags&quot;); if (aip-&gt;ai_flags == 0) &#123; printf(&quot; 0&quot;); &#125; else &#123; if (aip-&gt;ai_flags &amp; AI_PASSIVE) printf(&quot; passive&quot;); if (aip-&gt;ai_flags &amp; AI_CANONNAME) printf(&quot; canon&quot;); if (aip-&gt;ai_flags &amp; AI_NUMERICHOST) printf(&quot; numhost&quot;); if (aip-&gt;ai_flags &amp; AI_NUMERICSERV) printf(&quot; numserv&quot;); if (aip-&gt;ai_flags &amp; AI_V4MAPPED) printf(&quot; v4mapped&quot;); if (aip-&gt;ai_flags &amp; AI_ALL) printf(&quot; all&quot;); &#125;&#125;int main(int argc, char *argv[])&#123; struct addrinfo *ailist, *aip; struct addrinfo hint; struct sockaddr_in *sinp; const char *addr; int err; char abuf[INET_ADDRSTRLEN]; if (argc != 3) err_quit(&quot;usage: %s nodename service&quot;, argv[0]); hint.ai_flags = AI_CANONNAME; hint.ai_family = 0; hint.ai_socktype = 0; hint.ai_protocol = 0; hint.ai_addrlen = 0; hint.ai_canonname = NULL; hint.ai_addr = NULL; hint.ai_next = NULL; if ((err = getaddrinfo(argv[1], argv[2], &amp;hint, &amp;ailist)) != 0) err_quit(&quot;getaddrinfo error: %s&quot;, gai_strerror(err)); for (aip = ailist; aip != NULL; aip = aip-&gt;ai_next) &#123; print_flags(aip); print_family(aip); print_type(aip); print_protocol(aip); printf(&quot;\\n\\thost %s&quot;, aip-&gt;ai_canonname?aip-&gt;ai_canonname:&quot;-&quot;); if (aip-&gt;ai_family == AF_INET) &#123; sinp = (struct sockaddr_in *)aip-&gt;ai_addr; addr = inet_ntop(AF_INET, &amp;sinp-&gt;sin_addr, abuf, INET_ADDRSTRLEN); printf(&quot; address %s&quot;, addr?addr:&quot;unknown&quot;); printf(&quot; port %d&quot;, ntohs(sinp-&gt;sin_port)); &#125; printf(&quot;\\n&quot;); &#125; exit(0);&#125; 16.3.4 将套接字与地址关联使用bind函数来关联地址和套接字： 1234#include &lt;sys/socket.h&gt;/* 若成功，返回0；若出错，返回-1 */int bind(int sockfd, const struct sockaddr *addr, socklen_t len); 可以调用getsockname函数来发现绑定到套接字上的地址： 1234#include &lt;sys/socket.h&gt;/* 若成功，返回0；若出错，返回-1 */int getsockname(int sockfd, struct sockaddr *addr, socklen_t *alenp); 如果套接字已经和对等方连接，可以调用getpeername函数来找到对方的地址： 123#include &lt;sys/socket.h&gt;int getpeername(int sockfd, struct sockaddr *addr, socklen_t *alenp); 16.4 建立连接如果要处理一个面向连接的网络服务（SOCK_STREAM或SOCK_SEQPACKET），那么在开始交换数据以前，需要在请求服务的进程套接字（客户端）和提供服务的进程套接字（服务器）之间建立一个连接。使用connect函数建立连接： 1234#include &lt;sys/socket.h&gt;/* 若成功，返回0；若出错，返回-1 */int connect(int sockfd, const struct sockaddr *addr, socklen_t len); addr是我们想与之通信的服务器地址。如果sockfd没有绑定到一个地址，connect会给调用者绑定一个默认地址。 服务器调用listen函数来宣告它愿意接受连接请求： 1234#include &lt;sys/socket.h&gt;/* 若成功，返回0；若出错，返回-1 */int listen(int sockfd, int backlog); 一旦服务器调用了listen，所用的套接字就能接受连接请求。使用accept函数获得连接请求并建立连接： 1234#include &lt;sys/socket.h&gt;/* 若成功，返回套接字描述符；若出错，返回-1 */int accept(int sockfd, struct sockaddr *addr, socklen_t *len); 16.5 数据传输123456#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags); flags: sendto可以在无连接的套接字上指定一个目标地址，sendmsg使用msghdr结构指定多重缓冲区。 12345#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *addr, socklen_t *addrlen);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); 实例：面向连接的ruptime 客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &quot;apue.h&quot;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#define BUFLEN 128#define MAXSLEEP 128int connect_retry(int domain, int type, int protocol, const struct sockaddr *addr, socklen_t alen)&#123; int numsec, fd; for (numsec = 1; numsec &lt;= MAXSLEEP; numsec &lt;&lt;= 1) &#123; if ((fd = socket(domain, type, protocol)) &lt; 0) return -1; if (connect(fd, addr, alen) == 0) &#123; return fd; &#125; close(fd); if (numsec &lt;= MAXSLEEP / 2) sleep(numsec); &#125; return -1;&#125;void print_uptime(int sockfd)&#123; int n; char buf[BUFLEN]; while ((n = recv(sockfd, buf, BUFLEN, 0)) &gt; 0) write(STDOUT_FILENO, buf, n); if (n &lt; 0) err_sys(&quot;recv error&quot;);&#125;int main(int argc, char *argv[])&#123; struct addrinfo *ailist, *aip; struct addrinfo hint; int sockfd, err; if (argc != 2) err_quit(&quot;usage: ruptime hostname&quot;); memset(&amp;hint, 0, sizeof(hint)); hint.ai_socktype = SOCK_STREAM; hint.ai_canonname = NULL; hint.ai_addr = NULL; hint.ai_next = NULL; if ((err = getaddrinfo(argv[1], &quot;ruptime&quot;, &amp;hint, &amp;ailist)) != 0) err_quit(&quot;getaddrinfo error: %s&quot;, gai_strerror(err)); for (aip = ailist; aip != NULL; aip = aip-&gt;ai_next) &#123; if ((sockfd = connect_retry(aip-&gt;ai_family, SOCK_STREAM, 0, aip-&gt;ai_addr, aip-&gt;ai_addrlen)) &lt; 0) &#123; err = errno; &#125; else &#123; print_uptime(sockfd); exit(0); &#125; &#125; err_exit(err, &quot;can&#x27;t connect to %s&quot;, argv[1]);&#125; 服务器1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/************************************************************************* &gt; File Name: ../server1.c &gt; Author: &gt; Mail: &gt; Created Time: Wed 26 May 2021 01:49:05 PM CST ************************************************************************/#include &quot;apue.h&quot;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;syslog.h&gt;#include &lt;sys/socket.h&gt;#define BUFLEN 128#define QLEN 10#ifndef HOST_NAME_MAX#define HOST_NAME_MAX 256#endifint initserver(int type, const struct sockaddr *addr, socklen_t alen, int qlen)&#123; int fd; int err = 0; if ((fd = socket(addr-&gt;sa_family, type, 0)) &lt; 0) return -1; if (bind(fd, addr, alen) &lt; 0) goto errout; if (type == SOCK_STREAM || type == SOCK_SEQPACKET) &#123; if (listen(fd, qlen) &lt; 0) goto errout; &#125; return fd;errout: err = errno; close(fd); errno = err; return -1;&#125;void server(int sockfd)&#123; int clfd; FILE *fp; char buf[BUFLEN]; set_cloexec(sockfd); for (;;) &#123; if ((clfd = accept(sockfd, NULL, NULL)) &lt; 0) &#123; syslog(LOG_ERR, &quot;ruptimed: accept error: %s&quot;, strerror(errno)); exit(1); &#125; set_cloexec(clfd); if ((fp = popen(&quot;/usr/bin/uptime&quot;, &quot;r&quot;)) == NULL) &#123; sprintf(buf, &quot;error: %s\\n&quot;, strerror(errno)); send(clfd, buf, strlen(buf), 0); &#125; else &#123; while (fgets(buf, BUFLEN, fp) != NULL) send(clfd, buf, strlen(buf), 0); pclose(fp); &#125; close(clfd); &#125;&#125;int main(int argc, char *argv[])&#123; struct addrinfo *ailist, *aip; struct addrinfo hint; int sockfd, err, n; char *host; if (argc != 1) err_quit(&quot;usage: ruptimed&quot;); if ((n = sysconf(_SC_HOST_NAME_MAX)) &lt; 0) n = HOST_NAME_MAX; /* malloc space for host to save hostname or address */ if ((host = malloc(n)) == NULL) err_sys(&quot;malloc error&quot;); daemonize(&quot;ruptimed&quot;); memset(&amp;hint, 0, sizeof(hint)); hint.ai_flags = AI_CANONNAME; hint.ai_socktype = SOCK_STREAM; hint.ai_canonname = NULL; hint.ai_addr = NULL; hint.ai_next = NULL; if ((err = getaddrinfo(host, &quot;ruptime&quot;, &amp;hint, &amp;ailist)) != 0) &#123; syslog(LOG_ERR, &quot;ruptimed: getaddrinfo error: %s&quot;, gai_strerror(err)); exit(1); &#125; for (aip = ailist; aip != NULL; aip = aip-&gt;ai_next) &#123; if ((sockfd = initserver(SOCK_STREAM, aip-&gt;ai_addr, aip-&gt;ai_addrlen, QLEN)) &gt;= 0) &#123; server(sockfd); exit(0); &#125; &#125; exit(1);&#125; 服务器的第二种方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &quot;apue.h&quot;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;syslog.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/wait.h&gt;#define QLEN 10#ifndef HOST_NAME_MAX#define HOST_NAME_MAX 256#endifint initserver(int, const struct sockaddr *, socklen_t, int);void serve(int sockfd);int main(int argc, char *argv[])&#123; struct addrinfo *ailist, *aip; struct addrinfo hint; int sockfd, err, n; char *host; if (argc != 1) err_quit(&quot;usage: ruptimed&quot;); if ((n = sysconf(_SC_HOST_NAME_MAX)) &lt; 0) n = HOST_NAME_MAX; /* malloc space for host to save hostname or address */ if ((host = malloc(n)) == NULL) err_sys(&quot;malloc error&quot;); daemonize(&quot;ruptimed&quot;); printf(&quot;\\033[32mDEBUG\\033[0m ==&gt; daemonize(\\&quot;ruptimed\\&quot;) successfully.\\n&quot;); memset(&amp;hint, 0, sizeof(hint)); hint.ai_flags = AI_CANONNAME; hint.ai_socktype = SOCK_STREAM; hint.ai_canonname = NULL; hint.ai_addr = NULL; hint.ai_next = NULL; printf(&quot;\\033[32mDEBUG\\033[0m ==&gt; initialize hint successfully\\n&quot;); if ((err = getaddrinfo(host, &quot;ruptime&quot;, &amp;hint, &amp;ailist)) != 0) &#123; syslog(LOG_ERR, &quot;ruptimed: getaddrinfo error: %s&quot;, gai_strerror(err)); exit(1); &#125; printf(&quot;\\033[32mDEBUG\\033[0m ==&gt; getaddrinfo successfully\\n&quot;); for (aip = ailist; aip != NULL; aip = aip-&gt;ai_next) &#123; if ((sockfd = initserver(SOCK_STREAM, aip-&gt;ai_addr, aip-&gt;ai_addrlen, QLEN)) &gt;= 0) &#123; serve(sockfd); exit(0); &#125; &#125; exit(1);&#125;int initserver(int type, const struct sockaddr *addr, socklen_t alen, int qlen)&#123; int fd; int err = 0; if ((fd = socket(addr-&gt;sa_family, type, 0)) &lt; 0) // 1. create socket return -1; if (bind(fd, addr, alen) &lt; 0) // 2. bind with address goto errout; if (type == SOCK_STREAM || type == SOCK_SEQPACKET) &#123; if (listen(fd, qlen) &lt; 0) // 3. listen goto errout; &#125; return fd;errout: err = errno; close(fd); errno = err; return -1;&#125;void serve(int sockfd)&#123; int clfd, status; pid_t pid; set_cloexec(sockfd); for (;;) &#123; if ((clfd = accept(sockfd, NULL, NULL)) &lt; 0) &#123; // 4. accept syslog(LOG_ERR, &quot;ruptimed: accpte error: %s&quot;, strerror(errno)); exit(1); &#125; if ((pid = fork()) &lt; 0) &#123; syslog(LOG_ERR, &quot;ruptimed: fork error: %s&quot;, strerror(errno)); exit(1); &#125; else if (pid == 0) &#123; // child process if (dup2(clfd, STDOUT_FILENO) != STDOUT_FILENO || dup2(clfd, STDERR_FILENO) != STDERR_FILENO) &#123; syslog(LOG_ERR, &quot;ruptimed: unexpected error&quot;); exit(1); &#125; close(clfd); execl(&quot;/usr/bin/uptime&quot;, &quot;uptime&quot;, (char *)0); syslog(LOG_ERR, &quot;ruptimed: unexpected return from exec: %s&quot;, strerror(errno)); &#125; else &#123; // parent process close(clfd); waitpid(pid, &amp;status, 0); &#125; &#125;&#125; 实例2：无连接的ruptime 客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;apue.h&quot;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#define BUFLEN 128#define TIMEOUT 20void sigalrm(int signo)&#123;&#125;void print_uptime(int sockfd, struct addrinfo *aip)&#123; int n; char buf[BUFLEN]; buf[0] = 0; if (sendto(sockfd, buf, 1, 0, aip-&gt;ai_addr, aip-&gt;ai_addrlen) &lt; 0) err_sys(&quot;sendto error&quot;); alarm(TIMEOUT); if ((n = recvfrom(sockfd, buf, BUFLEN, 0, NULL, NULL)) &lt; 0) &#123; if (errno != EINTR) alarm(0); err_sys(&quot;recv error&quot;); &#125; alarm(0); write(STDOUT_FILENO, buf, n);&#125;int main(int argc, char *argv[])&#123; struct addrinfo *ailist, *aip; struct addrinfo hint; int sockfd, err; struct sigaction sa; if (argc != 2) err_quit(&quot;usage: ruptime hostname&quot;); sa.sa_handler = sigalrm; sa.sa_flags = 0; sigemptyset(&amp;sa.sa_mask); if (sigaction(SIGALRM, &amp;sa, NULL) &lt; 0) err_sys(&quot;sigaction error&quot;); memset(&amp;hint, 0, sizeof(hint)); hint.ai_socktype = SOCK_DGRAM; hint.ai_canonname = NULL; hint.ai_addr = NULL; hint.ai_next = NULL; if ((err = getaddrinfo(argv[1], &quot;ruptime&quot;, &amp;hint, &amp;ailist)) != 0) err_quit(&quot;getaddrinfo error: %s&quot;, gai_strerror(err)); for (aip = ailist; aip != NULL; aip = aip-&gt;ai_next) &#123; if ((sockfd = socket(aip-&gt;ai_family, SOCK_DGRAM, 0)) &lt; 0) &#123; err = errno; &#125; else &#123; print_uptime(sockfd, aip); exit(0); &#125; &#125; fprintf(stderr, &quot;can&#x27;t cantact %s: %s\\n&quot;, argv[1], strerror(err)); exit(1);&#125; 服务器：","categories":[],"tags":[]},{"title":"C++ Primer Plus学习记录","slug":"C-Primer-Plus","date":"2021-05-09T11:06:02.000Z","updated":"2021-05-09T11:10:46.050Z","comments":true,"path":"2021/05/09/C-Primer-Plus/","link":"","permalink":"http://example.com/2021/05/09/C-Primer-Plus/","excerpt":"","text":"C++ Primer Plus第1章 预备知识1.1 C++简介C++融合了3种编程方式： 面向过程编程 面向对象编程 泛型编程 1.2 C++简史1.2.1 C语言汇编语言是一种低级语言，可以直接控制硬件，速度快，但依赖于特定的处理器所支持的指令集，可移植性差。高级语言致力于解决问题，而不针对特定的硬件。C语言将低级语言的效率、硬件访问能力和高级语言的通用性、可移植性融合在一起，依赖于不同平台的编译器将C语言源代码翻译为特定机器上的内部代码。 1.2.2 C语言编程原理程序 = 数据 + 算法。 过程化编程、结构化编程、自顶向下的设计。 1.2.3 面向对象编程OOP强调数据，其理念是设计与问题的本质特性相对应的数据格式，将数据和方法合并为类定义，有助于创建可重用的代码。 类、对象、抽象、封装、继承、多态。 1.2.4 C++和泛型编程OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。 1.2.5 C++的起源C++诞生于贝尔实验室，Bjarne Stroustrup于20世纪80年代开发出C++。 1.3 可移植性和标准 C++98 C++03 C++11 1.4 程序创建的技巧 1.4.1 预处理预处理用于处理宏定义指令、条件编译指令、头文件包含指令等，从源文件生成.i文件。 1g++ -E hello.cpp -o hello.i 1.4.2 编译编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。 1g++ -S hello.i -o hello.s 1.4.3 汇编汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C/C++语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。 1g++ -c hello.s -o hello.o 1.4.4 链接由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。 链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。 1g++ hello.o -o hello(.exe) 1.5 总结​ 随着计算机的功能越来越强大，计算机程序越来越庞大而复杂。为应对这种挑战，计算机语言也到了改进，以便编程过程更为简单。C语言新增了诸如控制结构和函数等特性，以便更好地控制程序流程，支持结构化和模块化程度更高的方法；而C++增加了对面向对象编程和泛型编程的支持，这有助于提高模块化和创建可重用代码，从而节省编程时间并提高程序的可靠性。 第2章 开始学习C++2.1 进入C++2.1.1 main函数 main()函数被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统之间的桥梁。main()函数的函数头描述的是main()和操作系统之间的接口。 1main() // original style 在C语言中，省略返回类型相当于说函数的类型为int，然而C++逐步淘汰了这种用法。 有些程序员使用下面的函数头，并省略返回语句： 1void main() 这在逻辑上是一致的，因为void返回类型意味着函数不返回任何值。该变体适用于很多系统，但由于它不是当前标准强制的一个选项，因此在有些系统上不能工作。因此，应该避免使用这种格式，而应使用C++标准格式。 此外，如果编译器到达main()函数末尾时没有遇到返回语句，则认为main()函数以如下语句结尾： 1return 0; 2.1.2 C++注释 单行注释 1// .... 多行注释 1/* ... */ 2.1.3 #include \\预处理过程将iostream的文件内容替换这一行内容。 2.1.4 using namespace stdusing编译指令使得命名空间std中的所有名称都可以直接使用，而不用加std::前缀。还可以有以下用法： 123using std::cin;using std::cout;using std::endl; 2.1.5 cout 2.2 C++语句2.2.1 声明语句1int carrots; 声明语句提供两项信息： 需要的内存空间 给存储单元指定名称 程序中的声明语句叫做定义声明（defining declaration）语句，简称为定义（definition），这意味着它将导致编译器为变量分配内存空间。在较为复杂的情况下，还可能有引用声明（reference declaration），这些声明命令计算机使用在其他地方定义的变量。声明不一定是定义。 Hint: 对于声明变量，C++的做法是尽可能在首次使用变量前声明它。 2.2.2 赋值语句1carrots = 25; =为赋值运算符，赋值语句将值赋给存储单元，赋值将从右向左进行。 2.3 其他C++语句cin不读取空白字符，需要使用cin.get()处理回车。 cin是istream类的对象，cout是ostream类的对象。对象之于类，如同变量之于类型。类描述了一种数据类型的全部属性（包括可使用它执行的操作），对象是根据这些描述创建的实体。 2.4 函数 2.4.1 函数原型C++程序应当为程序中使用的每个函数提供原型。在使用函数之前，C++编译器必须知道函数的参数类型和返回值类型。也就是说，函数是返回整数、字符、小数、有罪裁决还是别的什么东西？如果缺少这些信息，编译器将不知道如何解释返回值。C++提供这种信息的方式就是使用函数原型语句。 2.4.2 自定义函数 2.5 总结C++多种类型的语句： 声明语句：声明函数中使用的变量的名称和类型。 赋值语句：使用赋值运算符=给变量赋值。 消息语句：将消息发送给对象，激发某种行动。 函数调用：执行函数。被执行的函数执行完毕后，程序返回到函数调用语句后面的语句。 函数原型：声明函数的返回类型、函数接受的参数数量和类型。 返回语句：将一个值从被调用的函数那里返回到调用函数中。 第3章 处理数据本章介绍C++内置的数据类型。内置的C++类型分为两组：基本类型和复合类型。本章介绍基本类型，即整数和浮点数。 3.1 简单变量为把信息存储在计算机中，程序必须记录3个基本属性： 存储何种类型的信息 信息将存储在哪里 要存储什么值 12int braincount;braincount = 5; 这些语句告诉程序，它正在存储整数，并使用名称braincount来表示该整数的值（这里为5）。实际上，程序将找到一块能够存储整形的内存，将该内存单元 标记为braincount，并将5复制到该内存单元中，然后你可以通过braincount来访问该内存单元。 3.1.1 变量名C++命名规则： 在名称中只能使用数字、字母、下划线_。 名称的第一个字母不能是数字。 名称区分大小写。 不能将C++关键字用作名称。 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器以及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。 C++对于名称的长度没有限制，名称中的所有字符都有意义，但有些平台有长度限制。 关于倒数第二点，像__time_stop或_Donut这样的名称不会导致编译器错误，而会导致行为的不确定性。不出现编译器错误的原因是，这样的名称不是非法的，但要留给实现使用。 至于变量命名风格，由雇主决定。 3.1.2 整型C++基本整型（按宽度递增的顺序排列）分别是char, short, int, long, long long。其中每种类型都有符号版本和无符号版本。char类型较为特殊，用于表示字符。 C++提供了一种灵活的标准，确保了最小长度，如下所示： short 至少16位 int 至少与 short 一样长 long 至少32位，且至少与 int 一样长 long long 至少64位，且至少与 long 一样长 通常来讲，char为8位，short为16位，int为32位，long在windows上为32位，在Linux上跟随系统的位数，long long为64位。 以上均为符号类型，意味着可以取正，也可以取负。取值范围从$-2^{n-1}$到$2^{n-1}-1$，$n$为位数。无符号版本的取值范围为$0$到$2^{n}-1$。 头文件climits提供了关于整型限制信息，包括位数、取值范围。 符号常量 表示 CHAR_BIT char的位数 CHAR_MAX char的最大值 CHAR_MIN char的最小值 SCHAR_MAX signed char的最大值 SCHAR_MIN signed char的最小值 UCHAR_MAX unsigned char的最大值 SHRT_MAX short的最大值 SHRT_MIN short的最小值 USHRT_MAX unsigned short的最大值 INT_MAX int的最大值 INT_MIN int的最小值 UINT_MAX unsigned int的最大值 LONG_MAX long的最大值 LONG_MIN long的最小值 ULONG_MAX unsigned long的最大值 LLONG_MAX long long的最大值 LLONG_MIN long long的最小值 ULLONG_MAX unsigned long long的最大值 溢出行为： 3.1.3 初始化初始化将声明与赋值结合在一起。C++三种初始化语法： 等号初始化 1234int n_int = INT_MAX;int uncles = 5;int aunts = uncles;int chairs = aunts + uncles + 4; 小括号初始化 1int wrens(432); 大括号初始化器（C++11） 1234int hamburgers = &#123;24&#125;; // set humbrugers to 24int emus&#123;7&#125;; // set emus to 7int rocs = &#123;&#125;; // set rocs to 0int psychics&#123;&#125;; // set psychics to 0 大括号初始化器既可用于单值变量，也可用于数组、结构体，更广泛地讲，可以用于任何类型。可以使用等号，也可以不使用等号。 3.1.4 整型字面值整形字面值（常量）是显示地书写地常量，如212或176。C++整型的三种不同的计数方式： 十进制 八进制，以数字0开头 十六进制，以0X或0x开头 cout对象可以调整输出格式（默认情况下以十进制输出）： 十进制：dec 八进制：oct 十六进制：hex 3.1.5 C++如何确定常量的类型通常情况下，一个整数如1492，编译器将其视为int类型。 特殊后缀：l或L表示long, ll或LL表示long long，ul或UL表示unsigned long, ull或ULL表示unsigned long long。 考察长度（对于以下规则，现在的编译器好像已经不太一样）： 对于不带后缀的十进制，使用下面几种类型中能够存储该数的最小类型来表示：int、long或long long。 对于不带后缀的八进制或十六进制，使用下面几种类型中能够存储该数的最小类型来表示：int、unsigned int、long、unsigned long、long long或unsigned long long。 3.1.6 char类型char类型归为整型中，占8位即1字节，存储的整型范围从$-128$到$127$，为符号类型，也有无符号类型，取值范围从$0$到$255$。char即可表现为signed char，也可表现为unsigned char，通常情况下表现为signed char，但具体取决于实现。char类型在内存中存储的值为整型，但输出时cout将其转换为ASCII码表中的对应字符。在标准输出输出一个字符使用cout.put()。 3.1.6.1 转义字符 3.1.6.2 通用字符名C++有一种表示特殊字符的机制，它独立于任何特定的键盘，使用的是通用字符名（universal character name）。通用字符名类似于转义序列，以\\u或\\U打头，\\u后接4位16进制数，\\U后接8位16进制数，这些位表示的是字符的ISO 10646码点（Unicode的一种实现）。 12int k\\u00F6rper;cout &lt;&lt; &quot;Let them eat g\\u00E2teau.\\n&quot;; 3.1.6.3 wchar_t程序需要处理的字符集可能无法用一个8位的字节表示，如日文汉字系统。对于这种情况，C++的处理方式有两种。 如果大型字符集是实现的基本字符集，则编译器厂商可以将char定义为一个16位的字节或更长的字节。 可以同时实现一个支持小型基本字符集和一个较大的扩展字符集。8位的char可以表示基本字符集，另一种类型wchar_t（宽字符类型）可以表示扩展字符集。 wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类型与另一种整型（底层（underlying）类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。 cin和cout将输入和输出看作是char流，因此不适于用来处理wchar_t类型。iostream头文件的最新版本提供了作用相似的工具——wcin和wcout，可以用于处理wchar_t流。另外，可以通过加上前缀L来知识宽字符常量和宽字符串。 12wchar_t bob = L&#x27;P&#x27;; // a wide-character constantwcout &lt;&lt; L&quot;tall&quot; &lt;&lt; endl; // outputting a wide-character string 3.1.6.4 char16_t和char32_twchar_t的长度和符号特征随实现而异。C++11新增了类型char16_t和char32_t，均为无符号的，长分别为16位和32位。C++11使用前缀u表示char16_t字符常量和字符串常量，如u&#39;C&#39;和u&quot;be good&quot;；并使用前缀U表示char32_t常量，如U&#39;R&#39;和U&quot;dirty rat&quot;。类型char16_t与\\u00F6形式的通用字符名匹配，而char32_t与\\U0000222B形式的通用字符名匹配。 12char16_t ch1 = u&#x27;q&#x27;;char32_t ch2 = U&#x27;\\U0000222B&#x27;; 3.1.7 bool类型布尔类型的变量值可以为true或false。字面值true和false都可以通过提升转换为int类型，true被转换为1，而false被转换为0。 任何数字值或指针值都可以被隐式转换（即不用显示强制转换）为bool值，任何非零值都被转换为true，而零值被转换为false。 12bool start = -100; // start assigned truebool stop = 0; // stop assigned false 3.2 const 限定符除了#define预处理命令外，C++有一种更好的处理符号常量的方法，这种方法就是使用const关键字来修改变量声明和初始化。 1const int Months = 12; 常量被初始化后，其值就被固定了，编译器将不允许修改该常量的值。关键字const叫做限定符，因为它限定了声明的含义。 使用const定义常量时必须在声明的同时进行初始化值。C++中可以使用const值来声明数组长度。 3.3 浮点数3.3.1 浮点数的类型C++有三种浮点类型： float double long double 这些类型时按它们可以表示的有小数位和允许的指数最小范围来描述的。C和C++对于位数的要求是：float至少32位，double至少48位，且不少于float，long double至少和double一样多。这三种类型的位数可以一样多，然而，通常，float为32位，double为64位，long double为80、96或128位。另外，这三种类型的指数范围至少是-37到37。可以从头文件cfloat中找到系统的限制。float保证6位有效位数，double保证15位有效位数。 3.3.2 浮点数的优缺点优点： 能表示整数之间的数 具有缩放因子，它们可以表示的范围大得多 缺点： 运算速度比整数慢 精度降低 3.3.3 类型分类 算数类型 整型 有符号整形：signed char, short, int, long, long long, 无符号整型：unsigned char, unsigned short, unsighed int, unsigned long, unsigned long long，char16_t，char32_t 不带符号：bool, wchar_t 浮点型：float, double, long double 3.4 C++算数运算符5个基本的算术运算符： + - * \\ ：如果两个操作数都是整数，则结果位商的整数部分，小数部分被丢弃。 % ：两个操作数必须为整数。结果的符号跟着左操作数。 优先级及结合性： *、\\、%位于同一优先级，+、-位于同一优先级且优先级更低，结合性均为从左往右。 3.5 类型转换C++自动执行很多类型转换： 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换； 表达式中包含不同的类型时，C+=将对值进行转换 将参数传递给函数时，C++将对值进行转换 不同情况下的类型转换： 初始化和赋值进行的转换 C++允许将一种类型的值赋给另一种类型的变量，这样做时，值将被转换为接受变量的类型。将一个值赋给取值范围更大的类型通常不会导致什么问题，只是占用更多的字节而已。然而，将一个很大的long值（如2111222333）赋给float变量将降低精度，因为float只有6位有效数字。因此有些转换是安全的，有些则会带来麻烦。 | 转换 | 潜在的问题 || —————————————————————————————- | —————————————————————————————— || 将较大的浮点类型转换为较小的浮点类型，如将double转换为float | 精度（有效数位）降低，值可能超出目标类型的取值范围，在这种情况下，结果是不确定的 || 将浮点类型转换为整型 | 小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果是不确定的 || 将整型转换为浮点类型 | 可能会降低精度 || 将较大的整型转换为较小的整型，如将long转换为short | 原来的值可能超出目标类型的取值范围，通常只赋值右边的字节 | 将0赋给bool变量时，将被转换为false；而非零值将被转换为true。 以{}方式初始化时进行的转换（C++11） C++将使用大括号的初始化称为初始化列表（list-initialization），因为这种初始化常用于给复杂的数据类型提供值列表。 列表初始化不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。例如，不允许将浮点型转换为整型。在不同的整型之间的转换或将整型转换为浮点型可能被允许，条件是编译器知道目标变量能够正确地存储赋给它地值。例如，可将long变量初始化为int值，因为long总是至少与int一样长；相反方向的转换可能被允许。只要int能够存储赋给它的long常量。 表达式中的转换 当一个表达式中包含两种不同的算数类型时： 一些类型在出现时便会自动转换 在计算表达式时，C++将bool、char、unsigned char、signed char 和 short 值转换为 int。这些转换被称为整型提升。 123short chickens = 20;short ducks = 35;short fowl = chickens + ducks; 第三条语句执行时，先将chickens和ducks提升为整型，做完加操作后转换为short类型赋给fowl。 C++11版本校验表： （1） 如果有一个操作数的类型是long double，则将另一个操作数转换为long double。 （2） 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double。 （3） 否则，如果有一个操作数类型是float，则将另一个操作数类型转换为float。 （4） 否则，说明操作数都是整型，因此执行整型提升。 （5） 在这种情况下，如果两个操作数都是有符号的或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型。 （6） 如果一个操作数为有符号，另一个操作数为无符号的，且无符号操作数级别比有符号操作数级别高，则将有符号操作数转换为无符号操作数所属类型。 （7） 否则，如果有符号类型可表示无符号类型的所有可能值，则将无符号操作数转换为有符号操作数所属类型。 （8） 否则，将两个操作数都转换为有符号类型的无符号版本。 所谓级别，对于有符号整型来讲从高到底以此为：long long, long, int, short, signed char。无符号与有符号的排列顺序相同。类型char、sighed char和unsigned char的级别相同。类型bool的级别最低。wchar_t、char16_t、char32_t的级别与其底层类型相同。 有些类型在与其他类型同时出现在表达式中时将被转换 传递参数时的类型转换 传递参数时的类型传递通常由C++函数原型控制。 强制类型转换 12typeName (value) // C++(typeName) value // C C++的想法是，让强制类型转化像函数调用。 此外，C++还引入了强制类型转换运算符，其中static_cast&lt;&gt;可用于将值从一种数值类型转换为另一种数值类型： 123static_cast&lt;long&gt; (thorn)static_cast&lt;typeName) (value) // converts value to typeName type 3.6 C++11 auto声明C++11 新增语法，将auto重新定义，让编译器能够根据初始值的类型推断变量的类型。 第4章 复合类型4.1 数组声明数组的通用格式： 1typeName arrayName[arraySize]; arraySize必须是整型常量或const值，也可以是常量表达式，即其中所有的值在编译时都是已知的，不能是变量，变量的值是在程序运行时设置的。 有效下标值的重要性：编译器不会检查使用的下标是否有效，但是在程序运行后，不合法的下标值将引发问题。 sizeof运算符用于数组名，得到的是整个数组中的字节数；用于数组元素，得到的是元素的长度（单位为字节）。 4.1.1 数组的初始化1 - 初始化规则数组名是一个只读变量，因此只能在定义数组时才能使用初始化，此后就不能用了，也不能将一个数组赋给另一个数组： 1234int cards[4] = &#123;3, 6, 8, 10&#125;; // okayint hards[4]; // okayhand[4] = &#123;5, 6, 7, 9&#125;; // not allowed, compile errorhand = cards; // not allowed, compile error 初始化数组时，如果提供的值少于数组的数目，则剩下的元素吧内编译器设置为0： 1float hotelTips[5] = &#123;5.0, 2.5&#125;; // okay, the third and later are set to zero 如果初始化时不提供长度，编译器将自动计算长度。 1short things[] = &#123;1, 5, 3, 8&#125;; 2 - C++11初始化方法 初始化数组时可以省略=。 大括号内可以没有任何东西，这将把所有的元素设置为零。 列表初始化禁止缩窄转换 123long plifs[] = &#123;25, 92, 3.0&#125;; // not allowed, float -&gt; intchar slifs[4] = &#123;&#x27;h&#x27;, &#x27;i&#x27;, 1122011, &#x27;\\0&#x27;&#125;; // not allowed, int -&gt; charchar tlifs[4] = &#123;&#x27;h&#x27;, &#x27;i&#x27;, 112, &#x27;\\0&#x27;&#125;; // allowed 4.2 字符串C++两种字符串：C风格字符串和string类库 C风格字符串使用字符数组存储，以\\0标识字符串的结束。区分字符数组和字符串。处理字符串是根据空字符的位置，而不是数组的长度。 字符串常量实际表示的是字符串所在的内存地址，因此不能将字符串赋给字符变量。使用sizeof对字符串字面值进行运算将返回字符串所有字符的总字节数（包括末尾的\\0），而不是一个指针的大小。 算字符串长度不把\\0纳入长度计算中，数组的长度要大于等于strlen(str) + 1。 4.1 字符串输入4.1.1 std::cincin读取输入时，以空白字符（空格、回车、换行等）为结束标志。当碰到空白字符时，cin停止读取，并将剩下的留在输入队列中，为之前读取的字符串加上\\0。cin可以读取输入队列中留下的空字符并丢弃，cin.geline和cin.get做不到。 4.1.2 std::cin.getline()cin.getline()函数读取整行，它使用通过回车键输入的换行符来确定输入结尾，然后丢弃换行符。该函数接受两个参数，一个是用来存储字符串的数组的名称，另一个是要读取的字符数，如果该参数为20，那最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。函数在读取到指定数目的字符或遇到换行符时停止读取。 4.1.3 std::cin.get()cin.get()是一个重载的函数，如果不提供任何参数，将读取一个字符并返回。如果第一个参数是字符串数组，第二个参数为读取的字符，则与cin.getline()一样，但是将回车保留在输入队列中，因此需要使用cin.get()进行处理。 4.1.4 空行和其他问题getline遇到空行时当作空字符串处理，读取的字符串长度为0，第1个字符为\\0。get()读取空行后将设置失效位（failbit），这意味着接下来的输入将被阻断，但可以使用cin.clear()来恢复。需要注意的是，即便恢复了输入，但是换行符还在队列中，如果不处理换行符，还是无法继续使用get(str, size)读取。 另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则getline()和get()将把剩余的字符留在输入队列中，而getline()还会设置失效位，并关闭后面的输入。 4.3 string类简介在很多方面，使用string对象的方式与使用C风格字符串的方式相同： 可以使用C-风格字符串来初始化string对象 可以使用cin来将标准输入存储到string对象中 可以使用cout来显示string对象 可以使用数组表示法来访问存储在string对象中的字符 string对象声明为简单变量，而不是数组。类设计让程序能够自动处理string的大小，使用string对象更方便，也更安全。 4.3.1 复制、拼接、附加和长度1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;int main()&#123; using namespace std; char charr1[20]; char charr2[20] = &quot;jaguar&quot;; string str1; string str2 = &quot;panther&quot;; // 赋值 str1 = str2; // 复制 strcpy(charr1, charr2); str1 += &quot; paste&quot;; // 附加 strcat(charr1, &quot; juice&quot;); int len1 = str1.size(); // 长度 int len2 = strlen(charr1); cout &lt;&lt; &quot;The string &quot; &lt;&lt; str1 &lt;&lt; &quot; contains &quot; &lt;&lt; len1 &lt;&lt; &quot; characters.\\n&quot;; cout &lt;&lt; &quot;The string &quot; &lt;&lt; charr1 &lt;&lt; &quot;contains &quot; &lt;&lt; len2 &lt;&lt; &quot; characters.\\n&quot;; return 0;&#125; 4.3.2 string的I/O操作getline函数从输入流读取一行放入string对象中，且丢弃结尾的换行符。使用getline函数读取输入字符串到string对象无需担心长度的问题。 4.3.3 其他形式的字符串 wchar_t char16_t char32_t 123wchar_t title[] = L&quot;Chief Astrogator&quot;;char16_t name[] = u&quot;Felonia Ripova&quot;;char32_t car[] = U&quot;Humber Super Snipe&quot;; Unicode字符编码方案UTF-8 在这种方案中，根据编码的数字值，字符可能存储为1~4个八位组。C++使用前缀u8来表示这种类型的字符串字面值。 原始(raw)字符串 cout &lt;&lt; R&quot;(Jim &quot;King&quot; Tutt uses &quot;\\n&quot; instead of endl.)&quot; &lt;&lt; &#39;\\n&#39;;将显示Jim &quot;King&quot; Tutt uses \\n instead of endl. 也就是说R&quot;(......)&quot;是原始字符串的标志，如果想在字符串中显示)&quot;，可以使用R&quot;+*(......)+*&quot;。这是自定义定界符，自定义定界符时，在默认定界符之间添加任意数量的基本字符，但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。 可将前缀R与其他字符串前缀结合使用，以标识wchar_t等类型的原始字符串，即RL或LR。 4.4 结构体简介一个结构体可以存储多种类型的数据。C++允许在声明结构体变量时省略关键字struct。定义结构体是在创造一种新的数据类型。 定义结构体的描述可以在外部，也可以在函数内部，后者只能在该函数中使用该结构体。C++不提倡使用外部变量，但提倡使用外部结构声明。 4.4.1 结构体变量的初始化使用初始化列表初始化： 12345678910struct inflatable&#123; char name[20]; float volume; double price;&#125;;inflatable a = &#123;&quot;Carlos Leo&quot;, 30.4f, 20.0&#125;;inflatable b &#123;&quot;Van Gandi&quot;, 45, 23&#125;;inflabable c &#123;&#125;; 大括号内未包含任何东西时，各成员都将被设置为0，name的每个字节都将设置为0，volume和price都被设置为0。 4.4.2 结构属性 .访问结构体成员 =可以赋值，这样结构中的每个成员都将设置为另一个结构中相应成员的值，即使成员是数组。注意，它并不是简单的对每个成员赋值，而是深拷贝。 参数传递 返回值 同时完成结构定义和创建结构变量以及结构变量初始化 123456789struct perks&#123; int key_number; char car[12];&#125;mr_glitz =&#123; 7, &quot;Packard&quot;&#125;; C++结构体的特性相比于C结构体的特性要更多，如C++结构体除了成员变量之外，还可以有成员函数。 4.4.3 结构体内存对齐结构体内存对齐的三条原则： （1）结构体变量的起始地址能够被其最宽的成员大小整除。 （2）结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节。 （3）结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节。 空结构体的占1个字节的空间。 4.4.4 结构体中的位字段与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段（bit field）。下面是一个例子： 1234567struct torgle_register&#123; unsigned int SN : 4; unsigned int : 4; bool goodIn : 1; bool goodTorgle : 1;&#125;; 可以像通常那样初始化这些字段，还可以使用标准的结构表示法来访问位字段： 1234torgle_register tr = &#123; 14, true, false &#125;;...if (tr.goodIn)... 位字段通常用在低级编程中。 4.5 共用体共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中一种类型。 123456union one4all&#123; int int_val; long long_val; double double_val;&#125;; 共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度成为其最大成员的长度。 匿名共用体没有名称，通常定义在结构体内，由于共用体成员的地址相同，不需要使用中间标识符。共用体常用于节省内存。 4.6 枚举枚举提供了一种定义符号常量的选择。定义枚举类型，是创建了一种新的类型，称为枚举类型，以及符号常量，称为枚举量。默认情况下，枚举量的值按照顺序从0开始，第一个枚举量的值为0，第二个枚举量的值为1，依此类推。也可以通过显示地指定整数值来覆盖默认值。可以使用枚举名作为类型名来声明变量： 123enum spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;spectrum band; // band is a variable of type spectrum 枚举变量具有一些特殊的性质： 在不进行强制类型转换时，只能将定义枚举时使用的枚举常量赋值给这种枚举类型的变量 12band = orange; // validband = 2000; // invalid, compile error 对于枚举，只定义了赋值运算符 123band = orange; // valid++band; // invalid, compile errorband = orange + red; // invalid, compile error 枚举量是整型，因此可以提升为int类型，但int类型不能自动转换为枚举类型 1234int color = blue; // validband = 3; // invalid, compile errorcolor = 3 + red; // valid, red converted to intcolor = orange + red; // valid 如果int的值是有效的，可以通过强制类型转换，将它赋给枚举变量。如果试图对一个不适当的值进行强制类型转换，结果是不确定的。 12band = spectrum(3); // valid, typecastband = spectrum(40003); // undefined, maybe 40003 实际上，枚举更常用来定义相关的符号常量，而不是新类型。如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称。 1enum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;; 4.6.1 设置枚举量的值可以使用赋值运算符来显示的设置枚举量的值，而且值可以是long或long long类型，但值只能是常量表达式，不能是变量。 1enum bits &#123;one = 1, two = 2, three, four = 4, eight = 8&#125;; 4.6.2 枚举的取值范围每个枚举都有取值范围，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举量。给定如下定义： 1enum bigstep &#123; zero = -6, first, second = 100, third&#125;; 上限：大于枚举量最大值的最小的2的幂，再减去1。对于枚举类型bigstep，最大值为101(third)，则上限为128 - 1，即127。 下限：如果最小枚举量的值大于或等于0，则下限为0。否则，取小于枚举量最小值的最大的2的幂，再加上1。对于枚举类型bigstep，最小值为-6(zero)，则下限为-8 + 1，即-7。 至于使用sizeof运算符计算其内存空间大小，是根据最大值所对应的最小整型类型的字节数确定的。 4.7 指针和自由存储空间Windows上，指针本身所占内存空间的大小取决于编译器是x86还是x64，二者分别为4字节和8字节。 警告：一定要在对指针应用解除引用运算符*之前，将指针初始化为一个确定的、适当的地址。编译器不会检查指针是否有被赋一个正确的地址。 指针不是整数！！！虽然计算机通常把地址当作整数来处理。从概念上看，指针与整数是截然不同的类型。指针描述的是位置，将两个地址相乘没有任何意义。因此，不能简单地将整数赋给指针。 123int *pt;pt = 0xB8000000; // 编译错误，类型不匹配pt = (int *)0xB8000000; // 强制类型转换 4.7.1 new关键字123456int main()&#123; int *pi = new int; double *pd = new double; ...&#125; 上面这段代码有几个要注意的点： pi、pd这两个变量是局部变量，存储在栈上，而pi、pd所指向的内存空间存储在堆上。 pi和pd所占字节数均为指针所占字节数，即4字节或8字节，取决于编译器的架构。而pi和pd所指向的空间即*pi和*pd分别占4字节、8字节。 new关键字在内存中找到一段合适的内存空间并返回这段空间的首地址。 4.7.2 delete关键字delete关键字用于释放使用new创建的内存空间，二者一定要配套使用，否则将发生内存泄漏。要注意一点： 12int *pi = new int;delete pi; 上面这段代码中delete只是释放了pi所指向的由new创建的内存空间，但pi这个变量本身并没有被删除。 几个注意点： 不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。 不能使用delete来释放声明变量所获得的内存，只能释放使用new分配的内存。 对空指针使用delete是安全的。 使用delete的关键在于，将它用于new分配的内存块，也就该内存块的地址，并不是说一定要将delete用于使用new的指针。 123int *ps = new int;int *pq = ps;delete pq; // delete with second pointer 4.7.3 使用new来创建动态数组使用new来创建动态数组，不能使用sizeof来确定动态分配的数组包含的字节数。 数组名的值不能修改，（我个人猜测数组名实际上是一个const指针），但指针是变量，因此可以修改它的值。 4.8 指针、数组和指针算数指针和数组基本等价的原因在于指针算数和C+=内部处理数组的方式。将整型变量加1，其值将加1。但指针变量加1后，增加的量等于它指向的类型的字节数。值得说明的一点是，C++将数组名解释为地址。 在多数情况下，C++将数组名解释为数组的第1个元素的地址。将指针变量加1后，其增加的值等于指向的类型占用的字节数。使用数组表示法表示数组元素时，C++都执行下面的转换： 1arrayname[i] becomes *(arrayname + i) 使用指针而不是数组名访问数组元素时，C++也执行同样的转换： 1pointername[i] becomes *(pointername + i) 数组名是常量。 使用sizeof对数组进行运算时，得到的是整个数组的内存大小，而使用sizeof对指针运算时，得到的是单个指针变量所占内存空间的大小。 4.8.1 数组的地址对数组取地址时，数组名不会被解释为其地址。数组名被解释为第一个元素的地址，而对数组名运用地址运算符时，得到的时整个数组的地址： 123short tell[10];cout &lt;&lt; tell &lt;&lt; endl; // display &amp;tell[0]cout &lt;&lt; &amp;tell &lt;&lt; endl; // display address of whole array 从数值上讲，这两个地址相同，但从概念上讲，&amp;tell[0]是一个2字节内存块的地址，而&amp;tell是一个20字节内存块的地址。因此tell = 1将地址值加2，而表达式&amp;tell + 1将地址值加20。因此，tell是一个指向short的指针，而&amp;tell是一个指向包含20个元素的数组的指针，而这样的指针必须使用下面的声明： 1short (*pas)[20] = &amp;tell; 如果省略括号，pas将先与[20]结合，导致pas成了一个数组，而数组的每个元素都是指向short的指针。 4.8.2 指针和C风格字符串在cout和多数C++表达式中，char数组名、char指针以及用括号括起的字符串常量都被解释为字符串的第一个字符的地址。 使用cout输出字符数组、字符串常量、字符指针时，都将输出字符串的内容，为了输出字符串的地址，必须使用强制类型转换void *（int *）也可以。 将字符串读入程序时，应使用已分配的内存地址。该地址可以是数组名，也可以是使用new初始化过的指针。 4.8.3 自动存储、静态存储和动态存储 自动存储 在函数内部定义的常规变量使用自动存储空间，被称为自动变量（automatic variable），这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。实际上，自动变量是一个局部变量，其作用域为包含它的代码块。 自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）。因此，在程序执行的过程中，栈将不断地增大和缩小。 栈帧的概念？ 静态存储 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它，另一种是在声明变量时使用关键字static。 动态存储 new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free space）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。数据的生命周期不完全受程序或函数的生存时间控制。 自动存储和静态存储的关键在于这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期，也可能只是在特定函数被执行时存在（自动变量）。new和delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。 4.8.4 类型组合注意一点： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;struct antarctica_years_end&#123; int year;&#125;;int main()&#123; antarctica_years_end s01, s02, s03; s01.year = 1998; antarctica_years_end *pa = &amp;s02; pa-&gt;year = 1999; antarctica_years_end trio[3]; trio[0].year = 2003; cout &lt;&lt; trio-&gt;year &lt;&lt; endl; const antarctica_years_end *arp[3] = &#123;&amp;s01, &amp;s02, &amp;s03&#125;; // 指针数组 cout &lt;&lt; arp[1]-&gt;year &lt;&lt; endl; const antarctica_years_end **ppa = arp; // 指向指针的指针 auto ppb = arp; // 自动类型推断 cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; endl; cout &lt;&lt; (*(ppb + 1))-&gt;year &lt;&lt; endl; return 0;&#125; 4.9 数组的替代品4.9.1 模板类vector模板类vector类类似于string类，也是一种动态数组，可以在运行时阶段设置vector对象的长度，可在末尾附加新数据，还可以在中间插入新数据。实际上，vector使用new和delete来管理内存，但这种工作是自动完成的。 1234567#include &lt;vector&gt;using namespace std;...vector&lt;int&gt; vi; // create a zero-size array of intint n;cin &gt;&gt; n;vector&lt;double&gt; vd(n); // create a n-size array of double 4.9.2 模板类array如果您需要的是长度固定的数组，可以使用模板类array类。与数组一样，array对象的长度是固定，也使用栈，而不是自由存储区，因此效率与数组相同，但更方便，更安全。 12345#include &lt;array&gt;using namespace std;...array&lt;int, 5&gt; ai; // create array object of 5 sizearray&lt;double, 4&gt; ad = &#123;1.2, 2.1, 3.43, 4.3&#125;; 数组长度不能是变量。 如果使用数组、array对象、vector对象都使用下标表示法取元素，则编译器均不检查错误的索引。但是array和vector提供了安全的访问访问方法： 1ai.at(1) = 2.3; 使用at()时，将在运期间捕获非法引用，而程序默认中断。这种额外检查的代价是运行时间更长。 第5章 循环和关系表达式5.1 表达式和语句5.1.1 表达式任何值或任有效的值和运算符的组合都是表达式，每个表达式都有值。C++将赋值表达式的值定义为左侧成员的值。当判定表达式的值这种操作改变了内存中的数据的值时，我们说表达式有副作用（side effect）。因此，判定赋值表达式会带来这样的副作用，即修改被赋值着的值。 5.1.2 语句只要加上分号，所有的表达式都可以称为语句，但不一定有编程意义。例如rodents + 6;。 5.1.3 非表达式和语句对任何表达式加上分号都可以称为语句，但是这句话反过来说就不对了。也就是说，从语句中删除分号，并不一定将它转换为表达式，如返回语句、声明语句和for语句。 123int toad;eggs = int toad * 1000; // invalid, not an expressioncin &gt;&gt; int toad; // can&#x27;t combine declaration with cin int toad不是表达式，因为它没有值。 5.1.4 顺序点顺序点(sequence point)是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估。如语句;就是一个顺序点。任何完整的表达式末尾都是一个顺序点。完整表达式是指不是另一个更大表达式的子表达式，如表达式语句中的表达式部分以及用作while循环中检测条件的表达式。 12while (guests++ &lt; 10) cout &lt;&lt; guests &lt;&lt; endl; 由于guests++ &lt; 10是一个完整的表达式，因此该表达式的末尾是一个顺序点，所以在循环判断结束guests就加了1。 1y = (4 + x++) + (6 + x++); 由于4 + x++不是一个完整的表达式，C++不保证x的值在计算子表达式4 + x++后立刻增加1。整条赋值语句的表达式是一个完整的表达式，分号标示了顺序点，因此C++只保证执行到下一条语句之前，x自加两次。 cout在显示bool值之前将它们转换为int，但cout.setf(ios::boolalpha)函数调用设置了一个标记，该标记命令cout显示true和false，而不是1和0。 5.2 复合语句代码块由一对花括号和它们包含的语句组成，被视为一条语句，称为复合语句。 如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完该语句块后，变量将被释放。 如果在一个语句块中声明一个变量，而外部语句块中也有一个同名变量，则在声明位置到内部语句块结束的范围之内，新变量将隐藏旧变量。 5.3 递增、递减运算符5.3.1 前缀格式和后缀格式递增、递减运算符分为前缀和后缀版本。前缀版本如++x、--x的值为执行递增或递减后的值，而后缀版本如x++、x--的值为原始的值，并且执行递增或递减。 此外，前缀格式的效率比后缀版本高。这是因为，用于这样定义前缀函数：将值加1然后返回；但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回。因此，对于类而言，前缀版本比后缀版本效率高。 5.3.2 递增/递减运算符和指针前缀递增、递减和解引用运算符优先级相同，以从右到左进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。 5.4 组合赋值运算符每个算数运算符都有其对应的组合赋值运算符（有的叫增强赋值运算符）。 5.5 逗号运算符逗号并不是逗号运算符，例如，下面这个声明语句中的逗号将变量列表中相邻的名称分开： 1int i, j; C++的逗号运算符特性： 逗号运算符是一个顺序点，确保先计算第一个表达式，然后计算第二个表达式 1i = 20, j = 2 * i; 逗号表达式的值是第二部分的值，如上面表达式的值为40，因为j = 2 * i的值为40。 在所有的运算符中，逗号运算符的优先级是最低的： 1cats = 17, 240; 上面的语句被解释为(cats = 17), 240，240不起作用。可以使用括号改变这一点：cats = (17, 240);，这样cats的值就是第二部分的值240。 5.6 关系运算符和关系表达式 关系运算符比算数运算符的优先级低。 关系表达式的结果要么为true，要么为false，因此整型提升就就是要么为1，要么为0。 5.7 for循环12for (initialization-expression; test-expression; update-expression) body for循环的组成部分： 设置初始值 执行测试，看看循环是否应当继续进行 执行循环操作 更新用于测试的值 C++语法将整个for看作一条语句，虽然循环体可以包含一条或多条语句。test-expression可以使用任意表达式，C++将把结果强制转换为bool类型。update-expression在每轮循环结束时执行，此时循环体已经执行完毕。 for循环是入口条件（entry-condition）循环，这意味着在每轮循环之前，都将计算测试表达式的值。 5.7.1 声明语句表达式for循环原始的语法为： 12for (expression; expression; expression) statement; 以前不可以在初始化部分声明变量，因为声明不是表达式。通过引入声明语句表达式（declaration-statement expression）来合法化。声明语句表达式不带分号声明，只能出现在for语句中。然而，这种调整已经被取消了，代之以将for语句的句法修改成下面这样： 12for (for-init-statement condition; expression) statement for-init-statement后面没有分号，因为其自身就是带分号的语句。对于for-init-statement来说，它既可以是表达式语句，也可以是声明语句。而使用该方式声明的变量，只能在for循环中存在，当程序离开循环后，这种变量将消失。 5.7.2 基于范围的for循环（C++11）C++11新增了一种循环：基于范围（range-based）的for循环。 123double prices[5] = &#123;4.99, 10.99, 6.87, 7.99, 8.49&#125;;for (double x : prices) cout &lt;&lt; x &lt;&lt; std::endl; 这里的x属于临时变量，要修改数组的元素，需要使用不同的循环变量语法： 12for (double &amp;x : prices) x = x * 0.80; 还可结合使用基于范围的for循环和初始化列表： 123for (int x : &#123;3. 5, 2, 8, 6&#125;) cout &lt;&lt; x &lt;&lt; &quot; &quot;;cout &lt;&lt; &#x27;\\n&#x27;; 5.8 while循环12while (test-condition) body ctime头文件中提供了时间类型，常用的是time_t和clock_t。clock_t的单位是CPU的时钟周期。 5.8.1 typedeftypedef用于类类型建立别名，但是typedef不会创建新类型，而只是为已有的类型建立一个新名称。 5.9 do while循环123do bodywhile (test-expression); do while不同于另外两种循环，因为它是出口条件（exit condition）循环，先执行循环体，然后再判定测试表达式。 5.10 文件尾条件检测到EOF（end of file）后，cin将两位（eofbit和failbit）都设置为1。可以通过成员函数eof()来查看eofbit是否被设置。同样，如果eofbit和failbit被设置为1，fail()成员函数返回true，否则返回false。 5.10.1 常见的字符输入做法每次读取一个字符，知道遇到EOF的输入循环的基本设计如下： 123456cin.get(ch);while (cin.fail() != false)&#123; ... cin.get(ch);&#125; 上述循环判断也可以改写为： 1while (!cin.fail()) 方法cin.get(char)的返回值是一个cin对象，然而，istream类提供了一个可以将istream对象转换为bool值得函数；当cin出现在需要bool值的地方，该转换函数将被调用。另外，如果最后一次读取成功了，则转换得到的bool值为true，否则为false。这意味着可以将上述while测试改写成这样： 1while (cin) 这比!cin.fail()或!cin.eof()更通用，因为它可以检测到其他失败原因，如磁盘故障。最后，由于cin.get(char)返回cin，因此可以将循环简化成这种格式： 1234while (cin.get(ch))&#123; ...&#125; 另外，cin.get()还可以这么用： 1char ch = cin.get(); 因此，循环还可以这样写： 123456char ch = cin.get();while (ch != EOF)&#123; ... ch = cin.get();&#125; EOF不表示输入中的字符，而是指出没有字符，其定义在stdio.h中，即#define EOF -1。 简化形式： 1234while ((ch = cin.get()) != EOF)&#123; ...&#125; 5.11 嵌套循环和二维数组 第6章 分支语句和逻辑运算符6.1 if语句12if (test-condition) statement if测试条件也将被强制转换成bool值。整个if语句被视为一条语句。 通常情况下，测试条件都是关系表达式。 6.1.1 if-else语句 1234if (test-condition) statement1else statement2 整个if-else结构被视为一条语句。 6.1.2 if-elseif-else结构1234567if (test-condition1) statement1else if (test-condition2) statement2...else statementn 6.2 逻辑表达式C++提供3中逻辑运算符，来组合或修改已有的表达式。 逻辑或|| 逻辑与&amp;&amp; 逻辑非! 运算符优先级： 逻辑非!高于所有关系运算符和算数运算符，而逻辑与&amp;&amp;高于逻辑或||。 6.3 字符函数库cctype 6.4 条件运算符?:1expression1 ? expression2 : expression3 6.5 switch语句1234567switch(integer-expression)&#123; case label1: statement(s); case label2: statement(s); .... default: statement(s);&#125; integer-expression必须是一个结果为整数值的表达式，另外，每个标签都必须是整数常量表达式，最常见的是int或char常量（如1或’q’），也可以是枚举量。 switch语句中的每一个case标签都必须是一个单独的值，另外，这个值必须是整数，因此switch无法处理浮点测试。另外，case标签值还必须是常量。 6.5.1 枚举量用作标签当switch语句将int值和枚举常量标签进行比较时，将枚举量提升为int。另外，在while循环测试条件中，也会将枚举量提升为int类型。 6.6 break和continuebreak使得程序结束循环，而continue使得程序跳过当前循环，进入下一轮循环。 6.7 读取数字的循环输入错误和文件尾EOF都将导致cin返回false。对于下面的程序： 12int n;cin &gt;&gt; n; 如果用户输入一个单词，而不是一个数，则类型不匹配，此时： n值保持不变 不匹配的输入将被留在输入队列中 cin对象的一个错误标记被设置 对cin方法的调用将返回false（如果被转换为bool类型） 方法返回false意味着可以使用非数字输入来结束读取数字的循环。非数字输入设置错误标志意味着必须重置该标记，程序才能继续读取输入。clear()方法重置错误输入标记，同时也重置文件尾（EOF条件）。 这段代码就是错误处理，把本行剩下的输入都读完，且直到输入正确为止。 6.8 简单文件输入/输出这里讨论的输入输出都是基于文本文件的输入输出，而非二进制文件。 6.8.1 文本I/O和文本文件使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据——文本数据。cin负责将文本转换为其他类型。下面看示例： 假设有如下输入行： 138.5 19.2 下面看看使用不同的数据类型的变量来存储时，cin是如何处理的： char 12char ch;cin &gt;&gt; ch; 上面的代码使得cin看到第一个字符为3，并将其对应的字符编码存储在ch中。输入和目标变量都是字符，因此不需要任何转换。执行完上述步骤后，输入队列的下一个字符为8。 int 12int n;cin &gt;&gt; n; 上面的代码使得cin将不断读取，直到遇到第一个非数字字符.，因此它将读取3和8，.成为输入队列中的下一个字符。cin通过计算发现，这两个字符对应数值38，因此将数值38的二进制编码赋值进变量n中。 double 12double x;cin &gt;&gt; x; 上面的代码使得cin不断读取，知道遇到第一个不属于浮点数的字符。也就是说cin将读取3、8、.、5，空格成为输入队列的下一个字符。cin通过计算发现，这四个字符对应数值38.5，因此将38.5的二进制编码（浮点格式）复制到变量x中。 字符数组 12char word[50];cin &gt;&gt; word; 上面这段代码使得cin不断读取知道遇到空白字符，也就是说它将读取3、8、.、5，使得空格成为输入队列中的下一个字符。然后，cin将这4个字符的字符编码存储到word数组中，并在末尾加上一个\\0。这里不需要进行任何的转换。 输入一行到字符数组 12char word[50];cin.getline(word, 50); 这里假设输入行少于50个字符。cin将不断读取知道遇到换行符，并将换行符丢弃，将换行符之前读取的所有字符复制到word数组中并在结尾加上\\0。输入队列中的下一个字符是下一行中的第一个字符。 对于输出，将执行相反的转换。 6.8.2 输出文件流ofstream头文件fstream提供了文件输出流类ofstream。通过open方法打开文件后就可以像使用cout一样向文件中写入数据。用完后记得使用close方法关闭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// outfile.cpp -- writing to a file#include &lt;iostream&gt;#include &lt;fstream&gt; // step1: include header fileint main() &#123; using namespace std; char automobile[50]; int year; double a_price; double d_price; // step2: declaration ofstream object ofstream outFile; // step3: open file outFile.open(&quot;carinfo.txt&quot;); cout &lt;&lt; &quot;Enter the make and model of automobile: &quot;; cin.getline(automobile, 50); cout &lt;&lt; &quot;Enter the model year: &quot;; cin &gt;&gt; year; cout &lt;&lt; &quot;Enter the original asking price: &quot;; cin &gt;&gt; a_price; d_price = 0.913 * a_price; // display information on screen with cout cout &lt;&lt; fixed; cout.precision(2); cout.setf(ios_base::showpoint); cout &lt;&lt; &quot;Make and Model: &quot; &lt;&lt; automobile &lt;&lt; endl; cout &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt; endl; cout &lt;&lt; &quot;Was asking $&quot; &lt;&lt; a_price &lt;&lt; endl; cout &lt;&lt; &quot;Now asking $&quot; &lt;&lt; d_price &lt;&lt; endl; // step4: now do exact same things using outFile instead of cout outFile &lt;&lt; fixed; outFile.precision(2); outFile.setf(ios_base::showpoint); outFile &lt;&lt; &quot;Make and Model: &quot; &lt;&lt; automobile &lt;&lt; endl; outFile &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt; endl; outFile &lt;&lt; &quot;Was asking $&quot; &lt;&lt; a_price &lt;&lt; endl; outFile &lt;&lt; &quot;Now asking $&quot; &lt;&lt; d_price &lt;&lt; endl; // step5: close the stream outFile.close(); return 0;&#125; 这里需要注意的是，打开已有的文件，以接受输出时，默认将其长度阶段为零，因此原来的内容将丢失。 6.8.3 输入文件流ifstream头文件fstream提供了文件输入流ifstream类，同样需要先声明一个ifstream对象，使用open函数打开文件，随后可以像使用cin一样使用它来从文件读入数据。 如果试图打开一个不存在的文件用于输入，将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功打开的首先方法是使用is_open()。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;fstream&gt; // step1: include header file &quot;fstream&quot;#include &lt;cstdlib&gt;const int SIZE = 60;int main() &#123; using namespace std; char filename[SIZE]; ifstream inFile; // step2: declare a ifstream object cout &lt;&lt; &quot;Enter name of data file: &quot;; cin.getline(filename, SIZE); inFile.open(filename); // step3: open file if (!inFile.is_open()) &#123; // step4: judge whether is opened successfully cout &lt;&lt; &quot;Could not open the file &quot; &lt;&lt; filename &lt;&lt; endl; cout &lt;&lt; &quot;Program terminating.\\n&quot;; exit(EXIT_FAILURE); &#125; double value; double sum = 0.0; int count = 0; // step5: read stream and test error inFile &gt;&gt; value; // 没有任何错误发生，读成功时，good()返回true while (inFile.good()) &#123; ++count; sum += value; inFile &gt;&gt; value; &#125; // 判断是否到了文件尾 if (inFile.eof()) cout &lt;&lt; &quot;End of file reached.\\n&quot;; // 判断是否时输入错误 else if (inFile.fail()) cout &lt;&lt; &quot;Input terminated by data mismatch.\\n&quot;; else cout &lt;&lt; &quot;Input terminated for unknown reason.\\n&quot;; if (count == 0) cout &lt;&lt; &quot;No data processed.\\n&quot;; else &#123; cout &lt;&lt; &quot;Items read: &quot; &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; &quot;Average: &quot; &lt;&lt; sum / count &lt;&lt; endl; &#125; // step6: close stream inFile.close(); // 关闭打开的文件 return 0;&#125; 上述的good()循环可以简化为： 1234while (inFile &gt;&gt; value)&#123; ...&#125; 第7章 函数——C++的编程模块7.1 复习函数基础知识创建自己的函数时，必须自行处理3个方面： 函数定义 函数原型 函数调用 对于有返回值的函数，通常，函数将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。 7.1.1 函数原型和函数定义 为什么需要函数原型？ 原型描述了函数到编译器的接口，它将函数返回值的类型以及参数的类型和数量告诉编译器。如果调用函数时提供的参数数量不对、类型不匹配（无法自动转换），原型使得编译器能捕获这些错误。当函数返回时，将值存储在CPU的寄存器或是内存中，由于原型提供了返回值类型，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。 避免使用函数原型的唯一方法，在首次使用函数之前定义它，但这并不是总是可行的。 原型的语法 1returnType functionName(param1Type, param2Type, ...); 函数原型是一条语句，因此必须以分号结束。获得原型的最简单方式是复制函数定义的函数头，并添加分号。然而，函数原型并不要求提供变量名，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。 原型的功能 原型可以帮助编译器完成许多工作，也可以帮助程序员极大的降低程序出错的几率： 编译器正确处理函数返回值。 编译器检查使用的参数数目是否正确。 编译器检查使用的参数类型是否正确。如果不正确，将转换为正确的类型（如果可能的话）。 通常，原型自动将被传递的参数强制转换为期望的类型。自动类型转换并不能避免所有可能的错误。当较大的类型被自动转换为较小的类型时，有些编译器将发出警告，指出这可能会丢失数据。仅当有意义时，原型化才会导致类型转换。 在编译阶段进行的原型化被称为静态类型检查（static type checking）。可以看出，静态类型检查可以捕获许多在运行阶段非常难以捕获的错误。 7.2 函数参数和按值传递函数按值传递，不同函数函数中的局部变量互不影响。 7.3 函数和数组1int sum_arr(int arr[], int n); 上述的声明中，arr实际上并不是一个数组，而是一个指针。在C++中，当且仅当用于函数头或函数原型中，int *arr和int arr[]的含义是相同的，它们都意味着arr是一个指针。在其他上下文中，int *arr和int arr[]的含义并不相同。 将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，那么使用拷贝的系统开销将非常大。 7.3.1 指针和const 让指针指向一个常量对象，防止使用该指针来修改所指向的值，简称指向const的指针。 12int age = 39;const int *pt = &amp;age; 该声明指出，pt指向一个const int，因此不能使用pt来修改这个值。换句话说，*pt的值为const，不能被修改： 12*pt += 1; // INVALIDcin &gt;&gt; *pt; // INVALID pt的声明并不意味着它指向的就是一个常量，而是只意味着对pt而言，这个值是常量。在这里，pt指向age，但age并不是常量，可以直接通过age变量修改age的值，但不能使用pt指针来修改它： 12*pt = 20; // INVALIDage = 20; // VALID 但你可以修改指针的指向，将其指向另一个变量，但是修改指向后仍不能使用指针修改变量的值。 四种情况： 将常规变量的地址赋给常规指针 将常规变量的地址赋给指向const的指针 将const变量的地址赋给指向const的指针 将const变量的地址赋给常规指针 上述四种情况下，最后一种情况是不可行的。如果最后一种情况可行，那可以通过常规指针解引用来改变const变量的值，那这个const变量的const还有什么意义呢？（但可以使用强制类型转换类突破这种限制——const_cast） 数组元素如果为const类型，则禁止将数组赋给非const指针： 123const int arrays[5] = &#123;1, 2, 3, 4, 5&#125;;int *pt = arrays; // INVALIDconst int *cpt = arrays; // Valid 尽可能使用const 将指针参数声明为指向常量数据的指针有2条理由： 这样可以避免由于无意间修改数据而导致的编程错误； 使用const使得函数能够处理const和非const实参，否则只能接受非const数据。 如果条件允许，则应将指针形参声明为指向const的指针。 将指针本身声明为常量，防止改变指针的位置，简称const指针 123int sloth = 3;const int *ps = &amp;sloth;int * const finger = &amp;sloth; ps为指向const的指针，不能用来修改sloth的值，只能重新指向别的变量。而finger不能修改指向，但可以使用*finger修改sloth的值。 如果愿意，还可以声明指向const对象的const指针： 12double trouble = 2.0E30;const double * const stick = &amp;trouble; 7.4 函数和二维数组假设有如下代码： 12int data[3][4] = &#123;&#123;1, 2, 3, 4&#125;, &#123;9, 8, 7, 6&#125;, &#123;2, 4, 6, 8&#125;&#125;;int total = sum(data, 3); sum的原型中第一个参数应该如何声明？data为二维数组，该数组有3个元素，第一个元素本身是一个数组，有4个int值组成。因此data的类型是指向由4个int组成的数组的指针，因此正确的原型如下： 123int sum(int (*ar2)[4], int size);或int sum(int ar2[][4], int size); 其中的括号必不可少。在前面几章出现过指向数组的指针，在这里是同样的道理。这两种原型含义完全相同，第二种原型的可读性更强。而这两个原型都指出，ar2是指针，而不是数组。还需注意的是，指针类型指出，它指向由4个int组成的数组。因此，指针类型执行了列数，这就是没有将列数作为独立的函数参数进行传递的原因。 7.5 函数和C风格字符串123456789101112131415161718192021222324252627282930313233// strgback.cpp -- a function that returns a pointer to char#include &lt;iostream&gt;const char *buildstr(char c, int n);int main()&#123; using namespace std; int times; char ch; cout &lt;&lt; &quot;Enter a character: &quot;; cin &gt;&gt; ch; cout &lt;&lt; &quot;Enter an integer: &quot;; cin &gt;&gt; times; const char *ps = buildstr(ch, times); cout &lt;&lt; ps &lt;&lt; endl; delete[] ps; ps = buildstr(&#x27;+&#x27;, 20); cout &lt;&lt; ps &lt;&lt; &quot;-DONE-&quot; &lt;&lt; ps &lt;&lt; endl; delete[] ps; return 0;&#125;const char *buildstr(char c, int n)&#123; char *pstr = new char[n + 1]; pstr[n] = &#x27;\\0&#x27;; while (n-- &gt; 0) pstr[n] = c; return pstr;&#125; 这里省略所有的const也是可以的。加const是为了防止修改字符串的值。 7.6 递归1234567891011121314151617181920212223242526272829303132333435363738// ruler.cpp -- using recursion to subdivde a ruler#include &lt;iostream&gt;const int Len = 66;const int Divs = 6;void subdivide(char ar[], int low, int high, int level);int main()&#123; char ruler[Len]; int i; for (i = 1; i &lt; Len - 2; i++) ruler[i] = &#x27; &#x27;; ruler[Len - 1] = &#x27;\\0&#x27;; int max = Len - 2; int min = 0; ruler[min] = ruler[max] = &#x27;|&#x27;; std::cout &lt;&lt; ruler &lt;&lt; std::endl; for (i = 0; i &lt;= Divs; i++) &#123; subdivide(ruler, min, max, i); std::cout &lt;&lt; ruler &lt;&lt; std::endl; for (int j = 1; j &lt; Len - 2; j++) ruler[j] = &#x27; &#x27;; &#125; return 0;&#125;void subdivide(char ar[], int low, int high, int level)&#123; if (level == 0) // 递归边界 return; int mid = (low + high) / 2; ar[mid] = &#x27;|&#x27;; subdivide(ar, low, mid, level - 1); subdivide(ar, mid, high, level - 1);&#125; 输出： 12345678| || || | || | | | || | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| 7.7 函数指针与数据项相似，函数也有地址。函数的地址是存储在其机器语言代码的内存的开始地址。 7.10.1 函数指针的基础知识 获取函数的地址 获取函数的地址很简单：只要使用函数名即可。也就是说，如果think()是一个函数，则think就是该函数的地址。要将函数作为参数进行传递，必须传递函数名。 声明函数指针 声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指定函数的返回类型以及函数的特征标（参数列表）。也就是说，声明应像函数原型那样指出有关函数的信息。 通常，要声明指向特定类型的函数的指针，可以先编写这种函数的原型，然后用(*pf)替换函数名。这样，pf就是这类函数的指针。 12345// a function declarationdouble pam(int);// a pointer point to function pamdouble (*pf)(int) = pam; 函数的特征标和返回类型必须与函数指针一致。如果不相同，编译器将拒绝这种赋值。 1234567double ned(double);int ted(int);double (*pf)(int);pf = ned; // INVALID -- mismatched signaturepf = ted; // INVALID -- mismatched return types 使用指针来调用函数 将函数指针看作函数名即可。 12345double pam(int);double (*pf)(int);pf = pam;double x = pam(4);double y = *(pf)(5) // calling by function pointer 实际上，C++也允许像使用函数名那样使用pf: 1double y = pf(5); 7.10.2 深入探讨函数指针先看三个函数原型： 123const double *f1(const double ar[], int n);const double *f2(const double [], int);const double *f3(const double *, int); 实际上，上面三个原型是一样的，特征表看似不同，实际上相同。接下来声明一个指针，它可指向这三个函数之一： 1const double *(*p1)(const double *, int); 可在声明的同时进行初始化： 123456const double *(*p1)(const double *, int) = f1;auto p2 = f2; // C++11 automatic type deduction// using cout &lt;&lt; (*p1)(av, 3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*p1)(av, 3) &lt;&lt; endl;cout &lt;&lt; p2(av, 3) &lt;&lt; &quot;: &quot; &lt;&lt; *p2(av, 3) &lt;&lt; endl; 函数返回const double *为指针类型，因此使用解引用符号取得值。 函数指针数组 12345678const double *(*pa[3])(const double *, int) = &#123;f1, f2, f3&#125;;auto pb = pa;const double *px = pa[0](av, 3);const double *py = (*pb[1])(av, 3);double x = *pa[0](av, 3);double y = *(*pb[1])(av, 3); 指向函数指针数组的指针 123auto pc = &amp;pa; // C++11const double *(*(*pd)[3])(const double *, int) = &amp;pa; 一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;const double *f1(const double ar[], int n);const double *f2(const double [], int);const double *f3(const double *, int);int main()&#123; using namespace std; double av[3] = &#123;1112.3, 1542.6, 2227.9&#125;; const double *(*p1)(const double *, int) = f1; auto p2 = f2; cout &lt;&lt; &quot;Using prointers to functions:\\n&quot;; cout &lt;&lt; &quot; Address Value\\n&quot;; cout &lt;&lt; (*p1)(av, 3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*p1)(av, 3) &lt;&lt; endl; cout &lt;&lt; p2(av, 3) &lt;&lt; &quot;: &quot; &lt;&lt; *p2(av, 3) &lt;&lt; endl; // 函数指针数组 const double *(*pa[3])(const double *, int) = &#123;f1, f2, f3&#125;; auto pb = pa; cout &lt;&lt; &quot;\\nUsing an array of pointers to functions:\\n&quot;; cout &lt;&lt; &quot; Address Value\\n&quot;; for (int i = 0; i &lt; 3; i++) cout &lt;&lt; pa[i](av, 3) &lt;&lt; &quot;: &quot; &lt;&lt; *pa[i](av, 3) &lt;&lt; endl; cout &lt;&lt; &quot;\\nUsing a pointer to a pointer to a function:\\n&quot;; cout &lt;&lt; &quot; Address Value\\n&quot;; for (int i = 0; i &lt; 3; i++) cout &lt;&lt; pb[i](av, 3) &lt;&lt; &quot;: &quot; &lt;&lt; *pb[i](av, 3) &lt;&lt; endl; cout &lt;&lt; &quot;\\nUsing pointers to an array of pointers:\\n&quot;; cout &lt;&lt; &quot; Address Value\\n&quot;; // 指向函数指针数组的指针 auto pc = &amp;pa; cout &lt;&lt; (*pc)[0](av, 3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*pc)[0](av, 3) &lt;&lt; endl; const double *(*(*pd)[3])(const double *, int) = &amp;pa; const double *pdb = (*pd)[1](av, 3); cout &lt;&lt; pdb &lt;&lt; &quot;: &quot; &lt;&lt; *pdb &lt;&lt; endl; cout &lt;&lt; (*(*pd)[2])(av, 3) &lt;&lt; &quot;: &quot; &lt;&lt; *((*pd)[2])(av, 3) &lt;&lt; endl; return 0;&#125;const double *f1(const double *arr, int n)&#123; return arr;&#125;const double *f2(const double ar[], int n)&#123; return ar + 1;&#125;const double *f3(const double ar[], int n)&#123; return ar + 2;&#125; 第8章 函数探幽本章重点内容： 内联函数 引用 函数的默认值参数 函数重载 函数模板 函数模板具体化 8.1 C++内联函数内联函数是C++为提高程序运行速度所做的一项改进。编译过程的最终产品是可执行程序——右一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时，碰到循环或分支语句时，将跳过一些指令，想前或向后跳到特定的地址。常规函数调用也使程序跳到另一个地址——函数的地址，并在函数结束时返回。 执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到地址被保存的指令处。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 C++内联函数提供了另一种选择，以空间换时间，内联函数不进行上述的跳跃过程，编译器将使用相应的函数代码替换函数调用，因此内联函数的运行速度比常规函数快，但代价是占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。 应该有选择地使用内联函数，如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代码执行的时间很短，则内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。 要使用这项特性，必须采取下述措施之一： 在函数声明前加上关键字inline 在函数定义前加上关键字inline 通常的做法是省略原型，将整个定义放在本应提供原型的地方。 内联函数不能为递归函数。程序员请求将函数作为内联函数时，编译器不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己，因此不将它作为内联函数。有些编译器没有启用或实现这种特性。 8.2 引用变量引用是已定义的变量的别名。（引用的实现方式为const指针，且隐含着解引用）。引用变量的主要用途是用作函数的形参。通过将引用变量作为参数，函数将使用原始数据，而不是副本。 引用必须在其声明时初始化，而不像指针可以先声明后初始化。此后，每次对引用变量使用赋值运算符，仅仅是在赋值，而不是将引用重新指向一个新的变量。 使用引用作为形参时，由于参数为传进来的实参的引用，因此修改该参数的值，将修改实参的值。为了避免这种情况，可以使用const修饰符。如此一来，当编译器发现修改引用的值时，编译器将报错。 当参数是基本类型时，使用值传递；如果为结构体变量或类对象时，使用引用传递。 8.2.1 临时变量、引用参数和const如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这样做，但以前不这样。 如果引用参数是const，则编译器将在下面两种情况下生成临时变量： 实参的类型正确，但不是左值； 实参的类型不正确，但可以转换为正确的类型 左值：可被引用的数据对象，例如变量、数组元素、结构成员、引用和解引用的指针等。 非左值：字面常量、包含多项的表达式。 常规变量和const变量都可视为左值，因为可以通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可修改的左值。 1234double refcube(const double &amp;ra)&#123; return ra * ra * ra;&#125; 123456789101112double side = 3.0;double *pd = &amp;side;double &amp;rd = side;long edge = 5L;double lens[4] = &#123;2.0, 5.0, 10.0, 12.0&#125;;double c1 = refcube(side); // ra is sicedouble c2 = refcube(lens[2]); // ra is lens[2]double c3 = refcube(rd); // ra is rd is sidedouble c4 = refcube(*pd); // ra is *pd is sidedouble c5 = refcube(edge); // ra is temporary variable, type is not match, but can be converteddouble c6 = refcube(7.0); // ra is temporary variable, type is match, but is not left valuedouble c7 = refcube(side + 10.0); // ra is temporary variable, type is match, but is not left value edge虽然是变量，是左值，但是一个long类型，类型不对；7.0和 side + 10.0类型都对，但不是左值，没有名称。在这些情况下，编译器都将生成一个临时匿名变量，并让ra指向该临时变量。这些临时变量只在函数调用期间存在，此后编译器变可以随意将其删除。 现在来看refcube()函数，该函数的目的只是使用传递的值，而不是修改它们，因此临时变量不会造成任何不利的影响，反而会使函数在可处理的参数种类方面更通用。因此，如果将引用声明为const类型，C++将在必要时产生临时变量。实际上，对于形参为const引用的C++参数，如果实参类型不匹配，则其行为类似于按值传递，为确保原始数据不被改变，将使用临时变量来存储值。 应尽可能使用const 使用const可以避免无意中修改数据的编程错误； 使用const使函数能够处理const和非const实参，否则只能接受非const数据； 使用const引用使函数能够正确生成并使用临时变量。 8.2.2 右值引用C++新增了另一种引用——右值引用（rvalue refrence）。这种引用可以指向右值，使用&amp;&amp;声明。 12345double &amp;&amp;rref = std::sqrt(36.00);double j = 15.0;double &amp;&amp;jref = 2.0 * j + 18.5;std::cout &lt;&lt; rref &lt;&lt; std::endl;std::cout &lt;&lt; jref &lt;&lt; std::endl; 8.2.3 返回引用返回引用的函数实际上是被引用的变量的别名。 返回引用时最重要的一点，应避免返回函数终止时不再存在的内存单元引用。应该避免编写下面的代码： 123456const free_throws &amp;clone2(free_throws &amp;ft)&#123; free_throws newguy; newguy = ft; return newguy;&#125; 该函数返回一个指向临时变量的引用，函数运行完毕后它将不复存在。为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数传递的引用将指向调用函数使用的数据，因此返回的引用也指向这些数据。另一种方法是使用new来分配新的存储空间。 返回const引用使得无法对函数调用语句进行赋值： 1234567free_throws &amp;accumulate(free_throws &amp;target, const free_throws &amp;source)&#123; // ... return target;&#125;accumulate(dup, four) = three; // dup = three; 上面这条个函数原型指示返回值是一个free_throws的引用，因此可以对其赋值，因为返回的为左值； 1const free_throws &amp;accumulate(free_throws &amp;target, const free_throws &amp;source) 上面这条语句便无法对函数调用进行赋值，因为返回值不再是左值，而是const修饰的引用，无法修改值，为右值。 8.2.4 对象、继承和引用基类引用可以指向派生类对象，而无需进行强制类型转换，常用于函数参数。举个简单的例子，ofstream类继承ostream类，因此指向ostream类的引用也可以指向ofstream类。 8.2.5 何时使用引用参数使用引用参数的两个原因： 程序员能够修改调用函数中的数据对象 通过传递引用而不是整个对象，可以提高程序的运行速度 指导原则： 对于使用传递的值而不作修改的函数 如果数据对象很小，如内置数据类型或小型结构，则按值传递 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针 如果数据对象是较大的结构，则使用指向const的指针或const引用 如果数据对象是对象，则使用const引用 对于修改调用函数中数据的函数： 如果数据对象是内置数据类型，则使用指针 如果数据对象是数组，则使用指针 如果数据都对象是结构，则使用引用或指针 如果数据对象是类对象，则使用引用 8.3 默认参数默认参数通过函数原型设置并告知程序。对于带参数列表的函数，必须从右向左添加默认值，也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值。 8.4 函数重载可以通过函数重载来设计一系列函数——它们完成相同的工作，但使用不同的参数列表。函数重载的关键是参数列表——也称为特征标。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名和返回值类型是无关紧要的。 编译器在检查函数特征标时，将把类型和引用本身视为同一特征标。 8.4.1 重载引用参数123void stove(double &amp;r1);void stove(const double &amp;r2);void stove(double &amp;&amp;r3); 上面有3个函数原型，左值引用参数r1与可修改的左值参数匹配；const左值引用参数r2可与修改的左值、const左值参数和右值参数匹配；右值引用参数r3与右值匹配。如果重载使用这三种参数的函数，结果将如何？答案是将调用最匹配的版本： 12345double x = 55.5;const double y = 32.0;stove(x); // call stove(double &amp;)stove(y); // call stove(const double &amp;)stove(x + y); // call stove(double &amp;&amp;) 如果没有定义stove(double &amp;&amp;)，stove(x + y)将调用stove(const double &amp;)。 8.4.2 何时使用函数重载仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。有时，默认参数可以达到相同的目的，且能少些一个函数。 8.4.3 名称修饰编译器根据函数原型中指定的形参类型对每个函数名进行加密，如在64位Windows上，且编译器架构为x86_64，使用nm命令查看目标文件，可以看到函数经编译器进行名称修饰后的结果： 12unsigned long left(unsigned long num, unsigned ct);char *left(const char *str, int n = 1); 8.5 函数模板函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。 模板并不创建任何函数，而是告诉编译器如何定义函数。当指定类型时，编译器将按模板创建对应类型的函数，这被称为模板实例化。 函数模板不能缩短可执行程序，最终编译器会根据模板创建出多个不同类型的函数定义，而最终的代码不包含任何模板。 8.5.1 重载的模板需要多个对不同类型使用同一种算法的函数时，可使用模板。然而，并非所有的类型都使用相同的算法。为满足这种需求，可以像重载常规函数定义那样重载模板定义。和常规重载一样，被重载的模板的函数特征标必须不同。 8.5.2 模板的局限性模板应配合运算符重载，才可将通用的操作用于不同的类型。或者，为特定类型提供具体化的模板定义。 8.5.3 显示具体化可以提供一个具体化函数定义——显示具体化(explicit specialization)，其中包含所需的代码。当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。 对于给定的函数名，可以有非模板函数、模板函数和显示具体化模板函数以及它们的重载版本。 显示具体化的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型。 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。 12345678910// 非模板函数void Swap(job &amp;, job&amp;);// 模板函数template &lt;typename T&gt;void Swap(T &amp;, T &amp;);// 显示具体化template &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;); // &lt;job&gt;可选，因为函数的参数类型表明，这是job的一个具体化template &lt;&gt; void Swap(job &amp;, job &amp;); // 因此可以这样写 8.5.4 实例化和具体化在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的使模板示例（instantiation）。模板并非函数定义，但使用int的模板实例是函数定义。 实例化 隐式实例化 12int a = 10, b = 20;Swap(a, b); 显示实例化 12Swap&lt;int&gt;(a, b);template void Swap&lt;int&gt;(int, int); 该声明的意思是，使用Swap模板生成int类型的函数定义。 具体化 显示具体化使用下面两个等价的声明之一： 12template &lt;&gt; void Swap&lt;int&gt;(int &amp;, int &amp;); // explicit specializationtemplate &lt;&gt; void Swap(int &amp;, int &amp;); // explicit specialization 这两个声明的意思是，不要使用Swap模板来生成函数定义，而应使用专门为int类型显式定义的函数定义。 警告：试图在同一个文件（或转换单元）中使用同一种类型的显示实例化和显示具体化将出错。 隐式实例化、显示实例化和显示具体化统称为具体化。它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。 一段代码总结隐式实例化、显示实例化和显示具体化： 123456789101112131415161718192021222324252627282930// .../* template prototype */template &lt;typename T&gt;void Swap(T &amp;, T&amp;);/* explicit specialization for job */template &lt;&gt;void Swap&lt;job&gt;(job &amp;, job &amp;);int main()&#123; // ... /* explicit instantiation for char */ template void Swap&lt;char&gt;(char &amp;, char &amp;); short a, b; // ... Swap(a, b); // implicit template instantiation for short job n, m; // ... Swap(n, m); // use explicit specialization for job char g, h; // ... Swap(g, h); // use explicit template instantiation for char // ...&#125; 8.5.5 编译器选择使用哪个函数版本对于函数重载、函数模板以及函数模板重载，C++需要一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时。这个过程称为重载解析（overloading resolution）。 第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。 第2步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为double，从而与double形参匹配，而模板可以为float生成一个实例。 第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。 完全匹配和最佳匹配完全匹配允许某些“无关紧要的转换”。 如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译器将生成一条错误信息，该消息可能会使用诸如“ambiguous（二义性）”这样的词语。 然而，有时候，即使两个函数都完全匹配，仍可完成重载解析： 指向非const数据的指针和引用优先于指向const的指针和引用 非模板函数将优先于模板函数（包括显示具体化） 术语最具体并不一定意味着显示具体化，而是指编译器推断使用哪种类型时执行的转换最少。 自己选择使用less&lt;&gt;(m, n)显示指定编译器应使用模板，而不是非模板。 8.5.6 模板函数的发展是什么类型编写模板函数时，一个问题是并非总能知道应在声明中使用哪种类型： 1234567tempalte &lt;typename T1, typename T2&gt;void ft(T1 x, T2 y)&#123; ... ?type? xpy = x + y; ...&#125; xpy应为什么类型？ 关键字decltype（C++11）语法： 1decltype(expression) var; 使用decltype，可以解决上述问题： 1234567tempalte &lt;typename T1, typename T2&gt;void ft(T1 x, T2 y)&#123; ... decltype(x + y) xpy = x + y; ...&#125; decltype核对表： 第1步：如果expression是一个没有括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符： 1234567double x = 5.5;double y = 7.9;double &amp;rx = x;const double *pd;decltype(x) w; // w is type of doubledecltype(rx) u = y; // u is type of double &amp;decltype(pd) v; // v is type of const double * 第2步：如果expression是一个函数调用，则var的类型与函数的返回类型相同： 12long indeed(int);decltype(indeed(3)) m; // m is type of int 注意，并不会实际调用函数。编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数。 第3步：如果expression是一个被括号括起的标识符，则var为指向其类型的引用： 123double xx = 4.4;decltype((xx)) r2 = xx; // r2 is type of double &amp;decltype(xx) w = xx; // w is type of double 第4步：如果前面条件都不满足，则var的类型与expression的类型相同 123456int j = 3;int &amp;k = j;int &amp;n = j;decltype(j + 6) i1; // i1 type intdecltype(100L) i2; // i2 type longdecltype(k + n) i3; // i3 type int 如果需要多次声明，可使用typedef定义别名： 12345678910tempalte &lt;typename T1, typename T2&gt;void ft(T1 x, T2 y)&#123; ... typedef decltype(x + y) xytype; xytype xpy = x + y; xytype arr[10]; xytype &amp;rxy = arr[2]; ...&#125; 另一种函数声明语法（C++11后置返回类型）有一个问题是decltype本身无法解决的： 123456tempalte &lt;typename T1, typename T2&gt;?type? ft(T1 x, T2 y)&#123; ... return x + y;&#125; 声明返回值类型时，此时还未声明参数x和y，它们不在作用域内。使用后置返回类型可以解决： 12345678tempalte &lt;typename T1, typename T2&gt;auto ft(T1 x, T2 y) -&gt; decltype(x + y)&#123; ... return x + y;&#125;auto h(int x, float y) -&gt; double; 后置返回类型可用于原型和定义。 第9章 内存模型和命名空间9.1 单独编译头文件中常包含的内容： 函数原型 使用#define或const定义的符号常量 结构声明 类声明 模板声明 内联函数 被声明为const的数据和内联函数有特殊的链接属性，因此可以将其放在头文件中。 上面这段文字也是为什么C++调用C的库函数时需要使用extern &quot;C&quot;的原因。 9.2 存储持续性、作用域和链接性C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间。 9.2.1 作用域和链接作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。 局部代码块 全局文件作用域 函数原型作用域 类作用域 命名空间作用域 链接性（linkage）描述了名称如何在不同的翻译单元间共享。 外部链接性：可在文件间共享 内部链接性：只能在一个文件的函数共享 无链接性：不能共享 9.2.2 自动存储持续性默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。当程序开始执行这些变量所属的代码块时，将为其分配内存，但其作用域的起点为其声明位置；当函数结束时，这些变量都将消失。 1. 自动变量的初始化只声明而不初始化，其值是垃圾数据。 2. 自动变量和栈自动变量存储在栈上。栈的默认大小取决于具体的实现，编译器通常提供改变栈长度的选项。当函数被调用时，自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束后，栈顶指针被重置问函数被调用前的值，从而释放新变量使用的内存。新值没有被删除，但不再被标记。 3. registerC++11之前，register关键字用来指示使用寄存器存储变量，目的在于提高访问变量的速度。C++11中，register关键字只是显式地指出变量是自动的。 9.2.3 静态存储持续性静态存储持续性变量有3中链接性： 外部链接性：全局变量 内部链接性：static修饰的全局变量 无链接性：static修饰的局部变量 由于静态存储持续性变量（简称静态变量）的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。 下面是三种静态变量的创建方式： 123456789...int global = 1000; // static duration, external linkagestatic int one_file = 50; // static duration, internal linkage...void func(int n)&#123; static int count = 0; // static duration, no linkage ...&#125; 1. 静态持续性变量的初始化规则如果没有显示初始化静态变量，编译器将把它们所有位初始化为0，这种变量被称为零初始化的（zero-initialized）。默认情况下，静态数组和结构将每个元素或成员的所有位设置为0。对于指针而言，0初始化可能并不是将指针的值设置为0，而是初始化为空指针在系统的内部表示。 零初始化和表达式初始化统称为静态初始化。这意味着在编译器处理翻译单元时初始化变量。动态初始化意味着变量将在编译后初始化。 对于所有的静态变量，无论是否有显示初始化，先进行零初始化。接下来，如果使用常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可计算表达式，编译器将执行常量表达式初始化。必要时，编译器执行简单计算。如果没有足够的信息，变量将被动态初始化。 123456#include &lt;cmath&gt;int x; // 零初始化int y = 5; // 常量表达式初始化long z = 13 * 13; // 常量表达式初始化const double pi = 4.0 * atan(1.0); // 动态初始化int enough = 2 * sizeof(long) + 1; // 常量表达式初始化 2. 静态持续性、外部链接性单定义规则 一方面，在每个使用外部变量的文件中，都必须声明它；另一方面，C++有“单定义规则”，该规则指出，变量只能有一次定义。 定义声明，简称定义，不给变量分配存储空间，因为它引用已有的变量。 引用声明，简称声明，给变量分配存储空间。使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间。 注意，单定义规则并非意味着不能有多个变量的名称相同。例如，在不同函数中声明的同名自动变量是彼此独立的，它们都有自己的地址。局部变量可能隐藏同名的全局变量。虽然程序中可包含多个同名的变量，但每个变量都只有一个定义。 局部变量隐藏同名的全局变量时，可使用作用域解析运算符::来访问全局变量。 3. 静态持续性，内部链接性使用static修饰全局变量，其链接性由外部链接性变成了内部链接性，且不与其他文件中的同名外部链接性全局变量冲突。 4. 静态持续性，无链接性使用static修饰局部变量，其链接性仍为无链接性，但其存储持续性由自动存储持续性变为静态存储持续性。 9.2.4 说明符和限定符存储说明符（storage class specifier）: auto（在C++11中已不再是说明符） register static extern thread_local mutable 1 - cv限定符 const volatile 2 - mutable可以用mutable指出，即使结构或类变量为const，其某个成员也可以被修改。例如： 123456789struct data&#123; char name[30]; mutable int accesses; ...&#125;const data veep = &#123;&quot;Claybourne Clodde&quot;, 0, ...&#125;;veep.accesses++; // allowed 3 - 再谈constconst除了使被其修饰的变量不可修改，只可读不可写，还使全局变量的链接性变成内部链接性。因此可以在头文件中定义一组const变量，并在同一个程序的多个文件中包含该头文件。 出于某种原因，如果程序员希望某个全局const变量的链接性为外部的，可以使用extern关键字来覆盖默认的内部链接性： 1extern const int states = 50; // 定义声明，外部链接性 9.2.5 函数和链接性所有函数的存储持续性为静态存储持续性。 函数的链接性默认为外部链接性，同样遵循单定义原则，只能有一个定义，可以有多个声明。将函数原型写在头文件中，并在其他使用该函数的文件中包含该头文件，就是多个声明，一个定义。可以使用static关键字修饰函数，使得其链接性为内部链接性，在原型和定义上都加上static。 内联函数不受但定义规则的约束，可能是因为inline关键字与const关键字和static关键字一样，将外部链接性改为了内部链接性，因此内联函数可以防在头文件中。 9.2.6 语言的链接性语言的链接性就是我们之前提到的C++不能直接调用C语言的库，因为编译器的名称修饰不同。更广泛的说，不同编译器编译出的目标文件不能直接相互链接，因为一个编译器与另一个编译器的名称修饰不同，导致找不到函数定义。 9.2.7 存储方案和动态分配动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制，内存分配和释放顺序取决于new和delete在何时以何种方式被使用。 通常，编译器使用三块内存： 静态变量 自动变量 动态存储 1 - 使用new运算符初始化C++98: 括号语法，也适用于有合适构造函数的类。 12int *pi = new int (6); // *pi is 6double *pd = new double (99.99); // *pd set to 99.99 C++11：初始化列表 12345struct where &#123; double x; double y; double z; &#125;;where *one = new where &#123;2.5, 5.3, 7.2&#125;;int *ar = new int [4] &#123;2, 4, 6, 7&#125;;int *pin = new int &#123;6&#125;;int *pdo = new double &#123;99.99&#125;; 2 - new失败时在最初的十年中，C++在这种情况下让new返回空指针，但现在将引发异常std::bad_alloc。 3 - new: 运算符、函数和替换函数运算符new和new[]分别调用如下函数： 12void * operator new(std::size_t);void * operator new[](std::size_t); 这些函数被称为分配函数，位于全局命名空间中。同样，也有由delete和delete[]调用的释放函数： 12void operator delete(void *);void operator delete[](void *); int *pi = new int;将被转换成int *pi = new(sizeof(int));；而int *pa = new int [40];将被转换成int *pa = new(40 * sizeof(int));。 同样，对于delete pi;，将转换成函数调用delete(pi);。 4 - 定位new运算符定位new运算符能够让程序员指定要使用的位置。要使用定位new运算符，首先需要包含头文件new，它提供了这种版本的new运算符的原型，然后将new运算符用于提供了所需地址的参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// newplace.cpp -- using placement new#include &lt;iostream&gt;#include &lt;new&gt;const int BUF = 512;const int N = 5;char buffer[BUF];int main()&#123; using namespace std; double *pd1, *pd2; int i; cout &lt;&lt; &quot;Calling new and placement new:\\n&quot;; pd1 = new double[N]; pd2 = new (buffer) double[N]; for (i = 0; i &lt; N; i++) pd2[i] = pd1[i] = 1000 + 20.0 * i; cout &lt;&lt; &quot;Memory addresses:\\n&quot; &lt;&lt; &quot; heap: &quot; &lt;&lt; pd1 &lt;&lt; &quot; static: &quot; &lt;&lt; (void *)buffer &lt;&lt; endl; cout &lt;&lt; &quot;Memory contents:\\n&quot;; for (i = 0; i &lt; N; i++) &#123; cout &lt;&lt; pd1[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd1[i] &lt;&lt; &quot;; &quot;; cout &lt;&lt; pd2[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd2[i] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;\\nCalling new and placement new a second time:\\n&quot;; double *pd3, *pd4; pd3 = new double[N]; // find new address pd4 = new (buffer) double[N]; // overwrite old data for (i = 0; i &lt; N; i++) pd4[i] = pd3[i] = 1000 + 40.0 * i; cout &lt;&lt; &quot;Memory contents:\\n&quot;; for (i = 0; i &lt; N; i++) &#123; cout &lt;&lt; pd3[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd3[i] &lt;&lt; &quot;; &quot;; cout &lt;&lt; pd4[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd4[i] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;\\nCalling new and placement new a third time:\\n&quot;; delete[] pd1; pd1 = new double[N]; pd2 = new (buffer + N * sizeof(double)) double[N]; for (i = 0; i &lt; N; i++) pd2[i] = pd1[i] = 1000 + 60.0 * i; cout &lt;&lt; &quot;Memory contents:\\n&quot;; for (i = 0; i &lt; N; i++) &#123; cout &lt;&lt; pd1[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd1[i] &lt;&lt; &quot;; &quot;; cout &lt;&lt; pd2[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd2[i] &lt;&lt; endl; &#125; delete[] pd1; delete[] pd3; return 0;&#125; 上面是一段示例程序，输出结果如下： 12345678910111213141516171819202122232425Calling new and placement new:Memory addresses: heap: 0x1c1440 static: 0x408040Memory contents:1000 at 0x1c1440; 1000 at 0x4080401020 at 0x1c1448; 1020 at 0x4080481040 at 0x1c1450; 1040 at 0x4080501060 at 0x1c1458; 1060 at 0x4080581080 at 0x1c1460; 1080 at 0x408060Calling new and placement new a second time:Memory contents:1000 at 0x1c1470; 1000 at 0x4080401040 at 0x1c1478; 1040 at 0x4080481080 at 0x1c1480; 1080 at 0x4080501120 at 0x1c1488; 1120 at 0x4080581160 at 0x1c1490; 1160 at 0x408060Calling new and placement new a third time:Memory contents:1000 at 0x1c1440; 1000 at 0x4080681060 at 0x1c1448; 1060 at 0x4080701120 at 0x1c1450; 1120 at 0x4080781180 at 0x1c1458; 1180 at 0x4080801240 at 0x1c1460; 1240 at 0x408088 对于常规new运算符而言，如果不使用delete释放已分配的堆上内存，则再次使用new运算符分配内存时，将会在堆上寻找一块新的内存空间。使用常规new运算符分配的内存空间要使用delete释放，否则会发生内存泄漏。 对于定位new运算符而言，上面的代码所给出的地址为静态存储区的地址，因此不能使用delete运算符进行释放，delete只能用于指向常规new运算符分配的堆内存。另外，定位new运算符不会检查给它的地址空间已被使用，而是直接使用该地址进行覆盖分配。 定位new运算符可与初始化结合使用，从而将信息放在特定的硬件地址处。 默认的定位new运算符工作原理：它只是返回传递给它的地址，并将其强制转换为void *，以便能够赋给任何指针类型。当然，这只是默认定位new运算符，C++允许程序员重载定位new函数。 原型： 9.3 名称空间9.3.1 传统的C++名称空间 声明区域（declaration region）：声明区域是可以在其中进行声明的区域 潜在作用域（potential scope）：变量的潜在作用域从声明点开始，到其声明区域的结尾 作用域（scope）：变量对程序而言可见的范围被称为作用域 潜在作用域比声明区域小，这是由于变量必须定义后才能使用。变量并非在其潜在作用域内的任何位置都是可见的，例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏，或者在函数中声明的局部变量将隐藏在同一个文件中声明的全局变量。 C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。在一个函数中声明的局部变量不会与另一个函数中声明的局部变量发生冲突。 9.3.2 新的名称空间特性C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个新的声明名称的区域。一个名称空间中的名称不会与另一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。 名称空间可以是全局的，也可位于另一个名称空间中，但不能位于代码块中。默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。 除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间（global namespace）。它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。 任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。 访问方式：作用域解析符::。 1 - using声明和using编译指令C++提供两种机制（using声明和using编译指令）来简化对名称空间中名称的使用。 using声明使特定的标识符可用：using声明将特定的名称添加到它所属的声明区域中。using std::cin;。 using编译指令使整个名称空间可用。using namespace std;。 2 - using编译指令和using声明之比较使用using编译指令导入一个名称空间中所有的名称与使用多个using声明是不一样的，using编译指令更像是大量使用作用域解析运算符。 使用using声明时，就好像声明了相应的名称一样，如果某个名称已经在函数中声明了，则不能使用using声明导入相同的名称。 然而，使用using编译指令时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。看下面的代码就能明白： 12345678910111213141516171819202122232425262728293031namespace Jill &#123; double bucket(double n) &#123; ... &#125; double fetch; struct Hill &#123; ... &#125;;&#125;char fetch; // global namespaceint main()&#123; using namespace Jill; // hide global fetch Hill Thrill; // create a type Jill::Hill structure double water = bucket(2); // use Jill::bucket(); double fetch; // not an error; hides Jill::fetch cin &gt;&gt; fetch; // read a value into the local fetch cin &gt;&gt; ::fetch; // read a value into the global fetch cin &gt;&gt; Jill::fetch; // read a value into Jill::fetch ...&#125;void foo()&#123; Hill top; // error Jill::Hill crest; // Valid&#125;void bar()&#123; double fetch; using Jill::fetch; // error&#125; 在函数中使用using编译指令时，命名空间变量覆盖全局变量，而局部变量覆盖命名空间变量。 3 - 名称空间的其他特性可以将名称空间声明进行嵌套： 123456789namespace elements&#123; namespece fire &#123; int flame; ... &#125; float water;&#125; 可以在名称空间中使用using编译指令和using声明： 1234567namespace myth&#123; using Jill::fetch; using namespace elelemts; using std::cout; using std::cin;&#125; uisng编译指令时可以传递的： 12345using namespace myth;// 等价于using namespace myth;using namespace elements; 可以给名称空间创建别名： 123namespace alias = myth;namespace MEF = myth::elements::file;using MEF::flame; 4 - 未命名的名称空间可以通过省略名称空间的名称来创建未命名的名称空间： 12345namespace&#123; int ice; int bandycoot;&#125; 这就像后面跟着using编译指令一样，也就是说，在该名称空间声明的名称的潜在作用域为从声明点到该声明区域末尾。从这个方面看，它们与全局变量相似，但是，由于没有名称，因此不能显示使用using编译指令或using声明来使它们在其他位置都可用。具体地说，不能在未命名名称空间所属文件之外地其他文件中，使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品。 1234567891011static int counts;int other();int main()&#123; ...&#125;int other()&#123; ...&#125; 采用名称空间的方法： 1234567891011121314namespace&#123; int counts;&#125;int other();int main()&#123; ...&#125;int other()&#123; ...&#125; 5 - 命名空间及其用途多个文件中，多个同名的名称空间实际上都是一个名称空间，这就是为什么名称空间可以写在头文件中的原因。 下面是当前的一些指导原则： 老式头文件（如stdio.h）没有使用命名空间，但新头文件cstdio使用了名称空间。 第10章 对象和类面向对象4大特性： 抽象 封装 继承 多态 10.1 抽象和类10.1.1 - 类型是什么？基本类型完成了三项定义工作： 决定数据对象需要的内存数量 决定如何解释内存中的位 决定可使用数据对象执行的操作或方法 10.1.2 - C++中的类类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。一般来说，类规范由两个部分组成： 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述共有接口 类方法定义：描述如何实现类成员函数 简单地说，类声明提供了类的蓝图，而方法定义则提供了细节。通常，C++程序员将类定义放在头文件中，并将类方法的代码放在源代码中。 数据隐藏是一种封装，将实现的细节隐藏在私有部分中。将类函数定义和类声明放在不同的文件中也是封装。 C++类的成员访问控制权限默认为private。 10.1.3 实现类的成员函数成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数，但它们还有两个特殊的特征： 定义成员函数时，使用作用域解析运算符::来标识函数所属的类 类的成员函数可以访问类的private组件 内联方法定义位于类声明中的函数都将自动成为内联函数。类声明常将短小的成员函数作为内联函数。 如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此，只需在类实现部分中定义函数时使用inline限定符即可。 根据改写规则（rewrite rule），在类声明中定义方法等同于用原型替换方法定义，然后再类声明的后面将定义改写为内联函数。也就是说，下面两段代码实际上是等价的： 123456789101112// stock00.h#pragma once#ifndef STOCK00_H_#define STOCK00_H_class Stock&#123;public: void set_tot() &#123; total_val = shares * share_val; &#125;&#125;;#endif 123456789101112131415161718// stock00.h#pragma once#ifndef STOCK00_H_#define STOCK00_H_class Stock&#123;public: void set_tot();&#125;;#endif// stock00.cppinline void Stock::set_tot()&#123; total_val = shares * share_val;&#125; 类对象所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享一组类方法，即每个方法只有一个副本。 10.3 类的构造函数和析构函数10.3.1 声明和定义构造函数构造函数没有返回类型，连void都不能带，函数名为类名。 10.3.2 使用构造函数显示调用： 1Stock food = Stock(&quot;World Cabbage&quot;, 250, 1.25); 隐式调用： 1Stock food(&quot;World Cabbage&quot;, 250, 1.25); 显示调用和隐式调用二者是等价的。 创建指针变量： 1Stock *pstock = new Stock(&quot;Electroshock Games&quot;, 18, 19.0); 无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。因此构造函数被用来创建对象，而不能通过对象来调用。 10.3.3 默认构造函数默认构造函数是不带参数的构造函数。当且仅当没有显示提供任何构造函数，则C++将自动提供默认构造函数。而编译器提供的默认构造函数的函数体不做任何初始化工作： 1Stock::Stock() &#123; &#125; 如果提供了非默认构造函数，则编译器不再提供默认构造函数，如果需要，需要自己动手写，否则，在未提供默认构造函数的情况下调用默认构造函数将出错。 定义默认构造函数的方式有两种： 给已有的构造函数的所有参数提供默认值： 1Stock(const string &amp;co = &quot;&quot;, int n = 0, double pr = 0.0) &#123; ... &#125; 通过函数重载来定义另一个构造函数——一个没有参数的构造函数： 1Stock() &#123; ... &#125; 由于只能有一个默认构造函数，因此不要同时采用这两种方式。 在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数。 123456Stock first; // OK, call default constructor implicitlyStock second(); // Declare a function, a function prototypeStock third = Stock(); // OK, call default constructor explicitlyStock forth = Stock; // INVALIDStock *prelief = new Stock; // OK, call default constructor implicitlyStock *ps = new Stock(); // OK, call default constructor explicitly 10.3.4 析构函数用构造函数创建过对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的成员函数，该函数叫做析构函数。析构函数完成清理工作，因此实际上很有用。例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。 如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除地代码后，提供默认析构函数的定义。 析构函数的名称为~加上类名，且不带任何参数，无返回类型： 12345// prototype~Stock();// definitionStock::~Stock() &#123; ... &#125; 什么时候应调用析构函数呢？这由编译器决定。通常不应在代码中显示地调用析构函数（也有例外情况）。 如果创建的是静态存储类对象，则其析构函数在程序结束时自动被调用。 如果创建的是自动存储类对象，则其析构函数在程序执行完代码块（该对象是在其中定义的）时自动被调用。 如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。 程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。 12Stock stock1 = Stock(&quot;Boffo Objects&quot;, 2, 2.0); // initialization, maybe create a temporary variable, maybe notstock1 = Stock(&quot;Nifty Foods&quot;, 10, 50.0); // assignment, a temporary variable created. 10.3.5 C++11列表初始化123Stock hot_tip = &#123;&quot;Derivatives Plus Plus&quot;, 100, 45.0&#125;; // 调用有参构造函数Stock jock &#123;&quot;Sport Age Storage, Inc&quot;&#125;; // 调用有参构造函数Stock temp &#123;&#125;; // 调用默认构造函数 10.3.6 const成员函数const对象将无法调用共有的常规成员函数，因为常规成员函数无法保证const对象不被修改。为此，C++的解决方案是将const关键字放在函数的括号后面。 1234567891011class Stock&#123;public: ... void show() const;&#125;;void Stock::show() const&#123; ...&#125; 以这种方式声明和定义的成员函数被称为const成员函数。只要成员方法不修改调用对象，就应该将其声明为const。 const对象只能调用const成员函数，而非const对象既可以调用非const成员函数，也可以调用const成员函数。该const实际上是将成员函数的this指针限定为const。 10.4 this指针this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。一般来讲，所有的类方法都将this指针设置为调用它的对象的地址。 每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式*this。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。 10.5 对象数组要创建对象数组，这个类必须有默认构造函数。初始化对象数组的方案是，首先使用默认构造函数创建数组元素，如果有列表初始化，则花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。 1234567Stock mystuff[4]; // create 4 Stock object by default constructor.Stock stocks[4] = &#123; // create 4 Stock object by default constructor and copy from temporary object Stock(&quot;NanoSmart&quot;, 12.5, 20), Stock(), Stock(&quot;Monolithic Obelisks&quot;, 130, 3.25), Stock(&quot;Fleep Enterprises&quot;, 60, 6.5)&#125;; 10.6 类作用域C++引入了一种新的作用域：类作用域。在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只会在该类中是已知的，在类外是不可知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。要调用公有成员函数，必须通过对象。而在定义成员函数时，必须使用作用域解析运算符。 10.6.1 作用域为类的常量在类中无法直接使用const声明常量。也就是说，下面的代码将会编译错误： 1234567class Bakery&#123;private: const int Months = 12; double costs[Months]; // compile error ...&#125;; 错误信息为”非静态成员引用必须与特定对象相对”。声明类只是描述了对象的形式，并没有创建对象，在创建对象前，将没有用于存储值的空间。 在类中定义常量有两种方式： 在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称 1234567class Bakery&#123;private: enum &#123; Months = 12 &#125;; double costs[Months]; ...&#125;; 注意，用这种方式声明枚举不会创建类数据成员，也就是说，所有对象中都不包含枚举。Months只是一个符号名称，在作用域为整个类的代码中遇到它时，编译器将用12来替换它。 使用static关键字 1234567class Bakery&#123;private: static const int Months = 12; double costs[Months]; ...&#125;; 这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Bakery对象共享。在C++98中，只能使用这种技术声明值为整数或枚举的静态常量，而不能存储double常量。C++11消除了这种限制。 10.6.2 作用域内枚举（C++11）传统枚举存在一些问题，其中之一是两个枚举定义中的枚举量可能发生冲突: 12enum egg &#123; Small, Medium, Large, Jumbo &#125;;enum t_shirt &#123; Small, Medium, Large, Xlarge &#125;; 这无法通过编译，因为egg的Small和t_shirt的Small位于同一作用域内，它们将发生冲突。作用域内枚举： 12345enum class egg &#123; Small, Medium, Large, Jumbo &#125;;enum class t_shirt &#123; Small, Medium, Large, Xlarge &#125;;egg choice = egg::Large;t_shirt Floyd = t_shirt::Large; 作用域枚举消除了冲突，此外，还提高了枚举的类型安全，不能隐式转换为整型： 12345678910enum egg_old &#123; Small, Medium, Large, Jumbo &#125;;enum class t_shirt &#123; Small, Medium, Large, Xlarge &#125;;egg_old one = Medium;t_shirt rolf = t_shirt::Large;int king = one; // OKint ring = rolf; // INVALIDif (king &lt; Jumbo) // OK ...if (king &lt; t_shirt::Medium) // INVALID ... 但必要时，可执行强制类型转换： 1int Frodo = int(t_shirt::Small); // OK, Frodo set to 0 枚举用某种底层整型类型表示，在C++98中，如何选择取决于实现，因此包含枚举的结构的长度可能随系统而异。对于作用域内枚举，C++11消除了这种依赖性。默认情况下，C++11作用域内枚举的底层类型为int。另外，还提供了一种语法，可用于做出不同的选择： 12// underlying type for pizza is shortenum class : short pizza &#123; Small, Medium, Large, XLarge &#125;; : short将底层类型指定为short。在C++11中，也可使用这种语法来指定常规枚举类型的底层类型。 10.7 抽象数据类型抽象数据类型(abstract data type, ADT)，以通用的方式描述数据类型，而没有引入语言或实现细节，是一种非常友好的方式。 第11章 使用类11.1 运算符重载一个简单的例子： 123456789101112131415161718192021222324252627282930313233343536// mytime1.h#pragma once#ifndef MYTIME0_H_#define MYTIME0_H_class Time&#123;public: Time(); Time(int h, int m = 0); ... Time operator+(const Time &amp;t) const; ...private: int minutes; int hours;&#125;;#endif// mytime1.cpp#include &lt;iostream&gt;#include &quot;mytime1.h&quot;...Time Time::operator+(const Time &amp;t) const&#123; Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum;&#125; 经过上面的函数声明和函数定义，可以对Time对象使用+运算符： 1234Time coding(2, 40);Time fixing(5, 55);Time total;total = coding + fixing; 注意一个点： 12Time t1, t2, t3, t4;t4 = t1 + t2 + t3; t4 = t1 + t2 + t3;等价于t4 = t1.operator+(t2 + t3);，进而等价于t4 = t1.operator+(t2.operator+(t3));。 1.11.1 重载限制多数C++运算符都可以使用上述的方式重载。重载的运算符不必是成员函数（有些情况例外），但必须至少有一个操作数是用于定义的类型。 重载后的运算符至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。 使用运算符时不能违反运算符原来的句法规则，也不能修改运算符的优先级。 不能创建新的运算符。 不能重载下面的运算符： sizeof .：成员运算符 .*：成员指针运算符 ::：作用域解析运算符 ?:：条件运算符 typeid：一个RTTI运算符 const_cast dynamic_cast reinterpret_cast static_cast 表11.1中大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载 = () [] -&gt; 11.2 友元通常，只能通过类的公有方法访问类对象的私有部分，友元提供了访问类的私有成员的新方式。友元有3种： 友元函数 友元类 友元成员函数 可以通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。这里先介绍友元函数。 友元函数的应用场景大多在与二元运算符重载。如果使用成员函数进行运算符重载，那么只能是对象在前，如： 123456789class Time&#123;public: ... Time operator*(double n); ...&#125;;A = B * 2.75; 上面的语句将被转换成下面的成员函数调用： 1A = B.operator*(2.75); 但是，下面这样写就不行了： 1A = 2.75 * B; 如此只能使用非成员函数来重载运算符，但是非成员函数无法访问类对象的私有成员，因此需要使用友元函数。 创建友元函数的第一步是将函数原型放在类声明中，并在原型前加上关键字friend： 1234567class Time&#123;public: ... friend Time operator*(double n, const Time &amp; t); ...&#125;; 虽然operator*函数是在类中声明的，但它不是成员函数，因此不能使用成员运算符来调用。然而，虽然不是成员函数，但是访问权限同成员函数。 第二步是编写函数定义，由于它不是成员函数，所以不要使用类作用域限定符 实际上，也可以使用非友元函数调用成员函数： 1234Time operator*(double m, const Time &amp;t)&#123; return t * m; // use t.operator*(m);&#125; 11.2.1 常用的友元：重载&lt;&lt;运算符重载&lt;&lt;运算符可直接使用cout作用于类对象以实现对类的信息的输出。 12345678910111213class Time&#123;public: ... friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Time &amp;t); ...&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;os, const Time &amp;t)&#123; os &lt;&lt; t.hours &lt;&lt; &quot; hours, &quot; &lt;&lt; t.minutes &lt;&lt; &quot; minutes&quot;; return os;&#125; 11.3 重载运算符：作为成员函数还是非成员函数非成员函数版本的重载运算符函数所需的形参数目与运算符使用的操作数目相同；而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象（this指针）。 11.3.1 随机数标准ANSI C库（C++也有）中有一个rand()函数，它返回一个从0到某个值（取决于实现）之间的随机整数。rand()函数将一种算法用于一个初始种子值来获得随机数，该随机值将用作下一个函数调用的种子，依此类推。srand()函数允许覆盖默认的种子值，重新启动另一个随机数序列。time(0)返回当前时间，通常为从1970年1月1日0点到当前时间的描述，返回值类型为time_t。使用srand(time(0))在每次程序运行时，都设置不同的种子。 1234567891011#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;int main()&#123; srand(time(0)); for (int i = 0; i &lt; 10; i++) std::cout &lt;&lt; rand() % 100 &lt;&lt; std::endl; return 0;&#125; 11.4 类的自动转换和强制类型转换能接受一个参数的构造函数可以作为转换函数，为将类型与该参数类型相同的值转换为类提供了蓝图。可以使用explicit关键字关闭这种自动类型转换，但仍然允许强制类型转换。 只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则也可以用于隐式转换。 1234567class Stonewt&#123;public: ... Stonewt(double lbs); ...&#125;; 1Stonewt st = 30.0; // the same as Stonewt st(30.0); 在不使用explicit关闭自动类型转换时，将在以下时刻执行参数类型到类类型自动类型转换： 将类类型对象初始化为参数类型值时 1Stonewt st = 30.0; // the same as Stonewt st(30.0); 将参数类型值赋值给类类型对象时 1st = 25.3; // use Stonewt(25.3) to create a temporary object, then call operator = 将参数类型值传递给接受类类型参数的函数时 123void func(Stonewt st);func(25.3); 返回值被声明为类类型的函数试图返回参数类型值时 123456Stonewt func2(double n)&#123; double temp; ... return temp;&#125; 在上述任意一种情况下，使用可转换为参数类型的内置类型时 123Stonewt s1 = 30;s1 = 4;func(3); 这3条语句将先将int类型转换为double类型，再调用Stonewt(double)构造函数。然而，当且仅当转换不存在二义性时，才会进行这种二步转换。也就是说，如果这个类还定义了构造函数Stonest(long)，则编译器将拒绝这些语句，因为int可被转换为long或double，因此调用存在二义性。 11.4.1 转换函数上面介绍了从参数类型到类类型的自动类型转换，那么是否可以执行相反的转换？可以，需要在类中定义转换函数。转换函数的原型如下： 1operator typeName(); 注意点： 转换函数必须是类方法 转换函数不能指定返回类型 转换函数不能有参数 typeName指出了要转换成的类型，因此不需要指定返回类型。转换函数是类方法，意味着它需要通过对象来调用，从而告知函数要转换的值。因此，函数不需要参数。对转换函数的定义使用类作用域解析运算符时，是写在operator前： 1234className::operator typeName()&#123; ...&#125; 如果定义多个转换函数，在cout时如果不显示写出类型转换，将会出现二义性。只定义一个转换函数则不会。赋值情况也是如此，如果定义了对double和int的转换函数，那么赋给long类型将会出现二义性。 同样，转换函数在C++11中可对转换函数的原型使用explicit关键字取消自动类型转换。 11.4.2 转换函数和友元函数一个简单的例子解释二义性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// stonewt.h#pragma once#ifndef __STONEWT_H__#define __STONEWT_H__class Stonewt&#123;private: enum &#123; LBS_PER_STN = 14 &#125;; int stone; double pds_left; double pounds;public: Stonewt() &#123; stone = pds_left = pounds = 0; &#125; Stonewt(int stn, double lbs); Stonewt(double lbs); ~Stonewt() &#123;&#125; void show_lbs() const; void show_stn() const; // conversion functions // operator int(); operator double(); // 运算符重载 // Stonewt operator+(const Stonewt &amp;st) const; // 成员函数 friend Stonewt operator+(const Stonewt &amp;st1, const Stonewt &amp;st2); // 友元函数&#125;;#endif// stonewt.cpp#include &quot;stonewt.h&quot;#include &lt;iostream&gt;using std::cout;Stonewt::Stonewt(int stn, double lbs)&#123; stone = stn; pds_left = lbs; pounds = stone * LBS_PER_STN + pds_left;&#125;Stonewt::Stonewt(double lbs)&#123; cout &lt;&lt; &quot;call constructor with one argument\\n&quot;; stone = int(lbs) / LBS_PER_STN; pds_left = int(lbs) % LBS_PER_STN + lbs - int(lbs); pounds = lbs;&#125;void Stonewt::show_lbs() const&#123; cout &lt;&lt; pounds &lt;&lt; &quot; pounds\\n&quot;;&#125;void Stonewt::show_stn() const&#123; cout &lt;&lt; stone &lt;&lt; &quot; stones, &quot; &lt;&lt; pds_left &lt;&lt; &quot; pounds\\n&quot;;&#125;Stonewt::operator int()&#123; return int(pounds + 0.5); // 四舍五入&#125;Stonewt::operator double()&#123; return pounds;&#125;// Stonewt Stonewt::operator+(const Stonewt &amp;st) const// &#123;// double pds = pounds + st.pounds;// // Stonewt sum(pds);// // return sum;// return pds;// &#125;Stonewt operator+(const Stonewt &amp;st1, const Stonewt &amp;st2)&#123; double pds = st1.pounds + st2.pounds; return pds;&#125;// main.cpp#include &lt;iostream&gt;#include &quot;stonewt.h&quot;using namespace std;int main()&#123; Stonewt st1 = 30.0; Stonewt st2 = 30.0; Stonewt sum = 20.0 + 30.0; // 生成临时对象，并调用拷贝构造函数 Stonewt sum2 = 20.0 + st1; // compile error return 0;&#125; 上面的代码会发生编译错误，原因在于main函数中sum2所在行代码。这里，有两种解释： 编译器检查是否对+做了运算符重载，代码中使用友元函数对+运算符进行了重载，于是看类型，20.0为double类型，而友元函数的第一个参数为const Stonewt类型的引用，于是检查是否定义了接受一个double类型参数的构造函数，确实定义了，因此将20.0通过该构造函数生成一个Stonewt类型的对象，进而执行对Stonewt类型的加法。 由于类中定义了特殊的成员函数——转换函数，因此st1将转换为double类型，执行对double类型的加法。 于是乎，存在二义性，编译报错。 应谨慎地使用隐式转换函数。通常，最好选择仅在被显示调用时才会执行的函数。 第12章 类和动态内存分配12.1 动态内存和类12.1.1 类的静态成员123456789101112// stringbad.hclass StringBad&#123;private: static int num_strings; ...&#125;;// strinbad.cpp#include &quot;stringbad.h&quot;int StringBad::num_strings = 0; 静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类，且不需要加static关键字。但如果静态成员是const整型或枚举类型，则可以在类声明中初始化。 至于为什么不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。 类的静态成员为类所有，为所有对象共用，只有一份数据拷贝。 在构造函数中使用new类分配内存时，必须在相应的析构函数中使用delete释放内存。如果使用new[]来分配内存，则应使用delete[]来释放内存。 12.1.2 特殊成员函数C++自动提供了下面这些成员函数： 默认构造函数，如果没有定义构造函数 默认析构函数，如果没有定义 复制构造函数，如果没有定义 赋值运算符，如果没有定义 地址运算符，如果没有定义 更准确地说，编译器将生成上述最后三个函数的定义——如果程序使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对象，编译器将提供赋值运算符的定义。 隐式地址运算符返回调用对象的地址(即this指针的值)。 C++11提供了另外两个特殊成员函数： 移动构造函数 移动赋值运算符 1 - 默认构造函数如果没有提供任何构造函数，C++将创建默认构造函数： 12345678class ClassName&#123;...public: ClassName() &#123;&#125; ......&#125;; 如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时不显示地对它进行初始化，必须显示定义默认构造函数。 带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。但不能同时定义一个无参构造函数和所有参数都有默认值的构造函数，这会导致二义性。 2 - 复制构造函数复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程（包括按值传递参数），而不是常规的赋值过程。类的复制构造函数原型通常如下： 1ClassName(const ClassName &amp;); 对于复制构造函数，需要明确两点：何时调用、有何功能。 何时调用： 新建一个对象并将其初始化为同类现有对象时、按值传递函数参数时、返回对象时以及编译器生成临时对象时，复制构造函数都将被调用： 1234StringBad ditto(motto);StringBad metoo = motto;StringBad also = StringBad(motto);String *psb = new StringBad(motto); 中间两种可能会使用复制构造函数直接创建metoo和also，也可能先使用复制构造函数生成临时对象，再调用赋值运算符，这两种情况将取决于具体的实现，通常现在的编译器采取第一种做法。 有何功能： 默认的复制构造函数逐个复制非静态成员，复制的是成员的值，为浅复制。如果成员本身就是类对象，则使用这个类的复制构造函数来复制成员对象。静态成员不受影响，因为它们属于整个类，而不是某个对象。 如果类中包含这样的静态数据成员，即其值将再新对象被创建时发生变化，则应该提供一个显式复制构造函数来处理计数问题。 如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。复制的另一种形式（成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入“挖掘”以复制指针引用的结构。 3 - 赋值运算符ASCI C允许结构赋值，而C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符的原型如下： 1ClassName &amp;operator=(const ClassName &amp;); 它接受并返回一个指向类对象的引用。 赋值运算符的功能是将已有对象赋给另一个对象，即将已有的对象赋给另一个对象时，将使用重载的赋值运算符： 123StringBad knot;knot = headline1;knot = StringBad(...); 初始化对象时，并不一定会使用赋值运算符。 与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个赋值，如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来赋值该成员，但静态数据成员不受影响。当然，默认的赋值运算符重载也是浅复制。 12.2 静态类成员函数、更多的运算符重载12.2.1 静态类成员函数可以将成员函数声明为静态的，函数声明必须包含关键字static，如果函数定义是独立的，则其中不能包含关键字static。 不能通过对象调用静态成员函数。实际上，静态成员函数甚至不能使用this指针。如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它。 由于静态成员函数不与特定的对象关联，因此只能使用静态数据成员。 12.2.2 重载[]可以对[]运算符进行重载，使得类对象能够像访问数组元素一样使用下标访问自身的数据。注意两种形式： 1234567891011121314151617181920212223// String.hclass String&#123;private: char *str; int len; ...public: ... char &amp;operator[](int index); // 1 const char &amp;opeartor[](int index) const; // 2&#125;;// String.cppchar &amp;String::operator[](int index)&#123; return str[index];&#125;const char &amp;String::operator[](int index) const&#123; return str[index];&#125; 方式1的重载可以使得String类的对象可以像数组一样使用下标访问和修改数据。而方式二可以使得const String类对象使用下标访问数据，但是不能修改数据。 12.2.3 进一步重载赋值运算符对于String类来讲，如果经常使用st = &quot;hello&quot;;这种语句，调用单参数构造函数生成临时对象，再调用赋值运算符重载进行拷贝，则不如定义一个针对const char*类型的赋值运算符重载： 1234567891011String &amp;operator=(const char *s);String &amp;String::operator=(const char *s)&#123; delete [] str; str = null; len = strlen(s); str = new char[len + 1]; strcpy(str, s); return *this;&#125; 这样一来，可以省去调用一次构造函数生成临时对象，提高执行效率。 12.3 使用指向对象的指针12.3.1 析构函数调用时机在下述情况下析构函数将被调用： 如果对象是自动变量，当执行完定义该对象的程序块时，将调用该对象的析构函数。 如果对象是静态变量，则在程序结束时将调用对象的析构函数。 如果对象是用new创建的，则仅当显示使用delete删除对象时，其析构函数才会被调用。 12.3.2 指针和对象小结 使用常规表示法来声明指向对象的指针： 1String *glamour; 可以将指针初始化为指向已有对象： 1String *first = &amp;sayings[0]; 可以使用new来初始化指针，这将创建一个对象： 1String *favorite = new String(sayings[choice]); 对类使用new将调用相应的类构造函数来初始化新创建的对象： 12String *gleep = new String; // 调用默认构造函数String *glop = new String(&quot;my my my&quot;); // 调用String(const char *)构造函数 可以使用-&gt;运算符通过指针访问类方法： 1if (sayings[i].length() &lt; shortest-&gt;length()) 可以对对象指针应用解除引用运算符*来获得对象： 12if (sayings[i] &lt; *first) first = &amp;sayings[i]; 12.3.3 再谈定位new运算符delete可与new运算符配套使用，但不能与定位new运算符配套使用。如果将对象使用定位new运算符创建在了某段内存上，将不能使用delete来释放它。如此，对象得不到释放，无法调用析构函数。因此，使用定位new运算符创建的对象需要显示调用析构函数，这是显示调用析构函数的一种情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// placenew1.cpp -- new, placement new, no delete#include &lt;iostream&gt;#include &lt;new&gt;#include &lt;string&gt;using namespace std;const int BUF = 512;class JustTesting&#123;private: string words; int number;public: JustTesting(const string &amp;s = &quot;Just Testing&quot;, int n = 0) &#123; words = s; number = n; cout &lt;&lt; words &lt;&lt; &quot; constructed\\n&quot;; &#125; ~JustTesting() &#123; cout &lt;&lt; words &lt;&lt; &quot; destroyed\\n&quot;; &#125; void Show() const &#123; cout &lt;&lt; words &lt;&lt; &quot;, &quot; &lt;&lt; number &lt;&lt; endl; &#125;&#125;;int main()&#123; char *buffer = new char[BUF]; // get a block of memory in heap JustTesting *pc1, *pc2; pc1 = new (buffer) JustTesting; // place object in buffer pc2 = new JustTesting(&quot;Heap1&quot;, 20); cout &lt;&lt; &quot;Memory block addresses:\\n&quot; &lt;&lt; &quot;buffer: &quot; &lt;&lt; (void *)buffer &lt;&lt; &quot; heap: &quot; &lt;&lt; pc2 &lt;&lt; endl; cout &lt;&lt; &quot;Memory contents:\\n&quot;; cout &lt;&lt; pc1 &lt;&lt; &quot;: &quot;; pc1-&gt;Show(); cout &lt;&lt; pc2 &lt;&lt; &quot;: &quot;; pc2-&gt;Show(); JustTesting *pc3, *pc4; pc3 = new (buffer) JustTesting(&quot;Bad Idea&quot;, 6); pc4 = new JustTesting(&quot;Heap2&quot;, 10); cout &lt;&lt; &quot;Memory contents:\\n&quot;; cout &lt;&lt; pc3 &lt;&lt; &quot;: &quot;; pc3-&gt;Show(); cout &lt;&lt; pc4 &lt;&lt; &quot;: &quot;; pc4-&gt;Show(); delete pc2; delete pc4; delete[] buffer; cout &lt;&lt; &quot;Done\\n&quot;; return 0;&#125; 上面的代码中，对pc3使用定位new运算符之前没有释放pc1指向的对象，因此，直接覆盖pc1所在的内存，程序运行后，pc1和pc3指向的对象都无法调用析构函数，下面是程序的运行结果： 123456789101112131415Just Testing constructedHeap1 constructedMemory block addresses:buffer: 0x6d1730 heap: 0x6d1940Memory contents:0x6d1730: Just Testing, 00x6d1940: Heap1, 20Bad Idea constructedHeap2 constructedMemory contents:0x6d1730: Bad Idea, 60x6d1970: Heap2, 10Heap1 destroyedHeap2 destroyedDone 再看另一段代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// placenew1.cpp -- new, placement new, no delete#include &lt;iostream&gt;#include &lt;new&gt;#include &lt;string&gt;using namespace std;const int BUF = 512;class JustTesting&#123;private: string words; int number;public: JustTesting(const string &amp;s = &quot;Just Testing&quot;, int n = 0) &#123; words = s; number = n; cout &lt;&lt; words &lt;&lt; &quot; constructed\\n&quot;; &#125; ~JustTesting() &#123; cout &lt;&lt; words &lt;&lt; &quot; destroyed\\n&quot;; &#125; void Show() const &#123; cout &lt;&lt; words &lt;&lt; &quot;, &quot; &lt;&lt; number &lt;&lt; endl; &#125;&#125;;int main()&#123; char *buffer = new char[BUF]; // get a block of memory in heap JustTesting *pc1, *pc2; pc1 = new (buffer) JustTesting; // place object in buffer pc2 = new JustTesting(&quot;Heap1&quot;, 20); cout &lt;&lt; &quot;Memory block addresses:\\n&quot; &lt;&lt; &quot;buffer: &quot; &lt;&lt; (void *)buffer &lt;&lt; &quot; heap: &quot; &lt;&lt; pc2 &lt;&lt; endl; cout &lt;&lt; &quot;Memory contents:\\n&quot;; cout &lt;&lt; pc1 &lt;&lt; &quot;: &quot;; pc1-&gt;Show(); cout &lt;&lt; pc2 &lt;&lt; &quot;: &quot;; pc2-&gt;Show(); JustTesting *pc3, *pc4; pc3 = new (buffer + sizeof(JustTesting)) JustTesting(&quot;Better Idea&quot;, 6); pc4 = new JustTesting(&quot;Heap2&quot;, 10); cout &lt;&lt; &quot;Memory contents:\\n&quot;; cout &lt;&lt; pc3 &lt;&lt; &quot;: &quot;; pc3-&gt;Show(); cout &lt;&lt; pc4 &lt;&lt; &quot;: &quot;; pc4-&gt;Show(); delete pc2; delete pc4; // explicitly destroy placement new objects pc3-&gt;~JustTesting(); pc1-&gt;~JustTesting(); delete[] buffer; cout &lt;&lt; &quot;Done\\n&quot;; return 0;&#125; 这段代码的运行结果如下： 1234567891011121314151617Just Testing constructedHeap1 constructedMemory block addresses:buffer: 0x1081730 heap: 0x1081940Memory contents:0x1081730: Just Testing, 00x1081940: Heap1, 20Better Idea constructedHeap2 constructedMemory contents:0x1081758: Better Idea, 60x1081970: Heap2, 10Heap1 destroyedHeap2 destroyedBetter Idea destroyedJust Testing destroyedDone 所有对象都得到了释放，且buffer也被delete释放。这里需要注意的一点是，pc3位于pc1的后面，因此需要先释放，也就是说，释放的顺序与创建的顺序相反，原因在于晚创建的对象可能依赖于早创建的对象。另外，仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。 12.4 成员初始化列表成员初始化列表由逗号分隔的初始化列表组成，前面带冒号，它位于参数列表的右括号之后、函数体左括号之前。 1234Queue::Queue(int qs) : qsize(qs)&#123; ...&#125; 只有构造函数可以使用这种初始化列表语法。此外，对于类中声明的const变量，之前我们说无法对其进行初始化，要么使用枚举，要么加上static关键字来在类中声明常量。现在，可以使用初始化列表在执行构造函数的函数体之前对const变量进行初始化。上述代码的qsize就是一个const变量。而对于被声明为引用的类成员，也必须使用这种语法进行初始化。 12.5 C++11类内初始化C++11允许您以更直观的方式进行初始化： 1234567class Classy&#123; // in-class initialization int mem1 = 10; const int mem2 = 20; ...&#125;; 这与在构造函数中使用成员初始化列表等价： 1Classy::Classy() : mem1(10), mem2(20) &#123; ... &#125; 除非调用了使用成员初始化列表的构造函数，在这种情况下，实际列表将覆盖这些默认初始值： 1Classy::Classy(int n) : mem1(n) &#123; ... &#125; 在这里，构造函数将使用n来初始化mem1，但mem2仍被设置为20。 第13章 类继承13.1 公有继承公有继承，基类的公有成员将成为派生类的公有成员，基类的私有部分也成为派生类的一部分，但只能通过基类的公有和保护方法访问。派生类的对象有以下特征： 派生类对象存储了基类的数据成员（派生类继承了基类的的实现） 派生类对象可以使用基类的方法（派生类继承了基类的接口） 13.1.1 构造函数：访问权限的考虑派生类不能直接访问基类的私有成员，而必须通过基类的方法进行访问。派生类构造函数必须使用基类构造函数。 创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表语法完成这项工作。 创建派生类对象时，程序首先调用基类的构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以成员初始化列表指明要使用的构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序首先调用派生类析构函数，然后再调用基类析构函数。 13.1.2 派生类与基类之间的特殊关系 派生类对象可以使用基类的方法，条件是方法不是私有的。 基类指针可以在不显示类型转换的情况下指向派生类对象；基类引用可以在不显示类型转换的情况下引用派生类对象。通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。利用这样的属性，可以带来一大好处：在函数参数中使用基类引用或指针，在调用时可以向其传递基类对象、地址或派生类的对象、地址，这就是多态的一种体现。 13.2 多态公有继承13.2.1 virtual关键字和虚方法如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚方法。这样，在使用引用或指针调用该方法时，将根据引用或指针指向的对象的类型来选择方法的版本，而不是根据引用或指针的类型来选择。如果声明为类型本身，而不是指针或引用，则按声明类型选择方法版本。 虚方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法，尽管如此，在派生类声明中使用关键字virtual来指出哪些函数时虚函数也不失为一个好办法。 13.2.2 虚析构函数虚析构函数可确保释放派生对象时，按正确的顺序调用析构函数。如果有一个基类的指针指向派生类的对象，若析构函数不是虚函数，则按指针类型调用虚函数，即只调用基类的析构函数。如果派生类中有使用new分配的内存的数据成员，则派生类的析构函数无法调用，将无法释放该内存空间。使用虚析构函数，将根据指针或引用指向的对象的类型来选择函数版本，此时将会调用派生类的析构函数，然后自动调用基类的析构函数。因此，使用析构函数，可以保证正确的析构函数序列被调用。 13.3 静态联编和动态联编将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。在编译过程中进行这种联编被称为静态联编，又称早期联编。然而C++引入虚函数，导致使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。编译器必须生成能够在运行时选择正确的虚函数的代码，这被称为动态联编，又称为晚期联编。 13.3.1 指针和引用类型的兼容性在C++中，动态联编与通过指针和引用调用方法相关。通常C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型。然而，指向基类的引用或指针可以引用派生类对象，而不必进行强制类型转换。 将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting），这使公有继承不需要进行显示类型转换，该规则是is-a规则的一部分。 将基类指针或引用转换为派生类指针或引用——称为向下强制转换（downcasting）。如果不适用显示类型转换，则向下强制转换是不允许的。 13.3.2 虚函数和动态联编如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。 1 - 虚函数工作原理编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table，tvbl）。虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也被添加到vtbl中。注意，无论时类中包含的虚函数是1个还是10个，都只需在对象中添加1个地址成员，只是表的大小不同而已。 调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括： 每个对象都将增大，增大量为存储地址的空间； 对于每个类，编译器都创建一个虚函数地址表（数组）； 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址 2 - 有关虚函数注意事项 构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义。 析构函数应当是虚函数，除非不用做基类。通常应给基类提供一个虚析构函数，即使它并不需要析构函数。 友元不能是虚函数。友元不是类成员，而只有成员才能是虚函数。 如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。 重新定义将隐藏方法。如果在派生类中重新定义函数（改变了特征标，即参数列表），不会生成函数的两个重载版本，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。 1234567891011121314151617181920class Dwelling&#123;public: virtual void showperks(int a) const;&#125;;class Hovel : public Dwelling&#123;public: virtual void showperks() const;&#125;;int main()&#123; Hovel trump; trump.showperks(); // valid trump.showperks(5); // invalid return 0;&#125; 如果仅仅是改变了返回类型，则要看是否协变： 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性称为返回类型协变。如果不满足协变规则，将编译报错。所以，如果不改变参数列表，则返回类型要么一样，要么符合协变。 1234567891011class Dwelling &#123; public: virtual Dwelling &amp;build(int n); &#125;; class Hovel : public Dwelling &#123; public: virtual Hovel &amp;build(int n); // same function signature &#125;; 如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。注意，如果不需要修改，则新定义只需调用基类版本即可。 123456789101112131415class Dwelling &#123; public: virtual void showperks(int a) const; virtual void showperks(double x) const; virtual void showperks() const; &#125;; class Hovel : public Dwelling &#123; public: virtual void showperks(int a) const; virtual void showperks(double x) const; virtual void showperks() const; &#125;; 13.4 访问控制：protectedprotected成员对类外不可见，对类内可见，这一点与private是一致的。protected的特点在继承时体现：protected成员在派生类中可见。 13.5 抽象基类C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为=0。当类声明中包含纯虚函数时，则不能创建该类的对象。包含纯虚函数的类只用作基类。要成为真正的抽象基类，必须至少包含一个纯虚函数。C++允许纯虚函数有定义。 13.6 继承和动态内存分配13.6.1 基类使用动态内存分配，派生类不使用动态内存分配123456789101112class baseDMA&#123;private: char *label; int rating;public: baseDMA(const char *l = &quot;null&quot;, int r = 0); baseDMA(const baseDMA &amp;rs); virtual ~baseDMA(); baseDMA &amp;operator=(const baseDMA &amp;rs);&#125;; baseDMA类声明中包含了构造函数使用new时需要的特殊方法：析构函数、复制构造函数和重载赋值运算符。现在，从baseDMA派生出lackDMA类，而后者不使用new，也未包含其他一些不常用的、需要特殊处理的设计特性： 1234567class lacksDMA : public baseDMA&#123;private: char color[40];public:...&#125;; 是否需要为lackDMA类定义显示析构函数、复制构造函数和赋值运算符呢？不需要。 首先，来看是否需要析构函数。如果没有定义析构函数，编译器将定义一个不执行任何操作的默认构造函数。实际上，派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。因为lackDMA成员不需执行特殊操作，所以默认析构函数是合适的。 接下来看复制构造函数。复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。所以，lacksDMA类的默认复制构造函数使用显式baseDMA复制构造函数来复制lacksDMA对象的baseDMA部分。 对于赋值来说，类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件进行赋值。 13.6.2 基类使用动态内存分配，派生类也使用动态内存分配1234567class hasDMA : public baseDMA&#123;private: char *style;public:....&#125;; 在这种情况下，必须为派生类定义显示析构函数、复制构造函数和赋值运算符。 首先看析构函数。派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行的动态内存分配进行清理。因此，hasDMA析构函数必须释放指针style管理的内存，并依赖于baseDMA的析构函数来释放指针label管理的内存。 123456789baseDMA::~baseDMA()&#123; delete [] label;&#125;hasDMA::~hasDMA()&#123; delete [] style;&#125; 接下来看复制构造函数： 123456789101112baseDMA::baseDMA(const baseDMA &amp;rs)&#123; label = new char[std::strlen(rs.label) + 1]; std::strcpy(label, rs.label); rating = rs.rating;&#125;hasDMA::hasDMA(const hasDMA &amp;hs) : baseDMA(hs)&#123; style = new char[std::strlen(hs.style) + 1]; std::strcpy(style, hs.style);&#125; hasDMA复制构造函数只能访问hasDMA的数据，因此它必须调用baseDMA复制构造函数来处理共享的hasDMA数据。如果不这样做，它将自动调用基类的默认构造函数。 接下来看赋值运算符。baseDMA赋值运算符遵循下述常规模式： 12345678910baseDMA &amp;baseDMA::operator=(const baseDMA &amp;rs)&#123; if (this == &amp;rs) return *this; delete [] label; lable = new char[std::strlen(rs.label) + 1]; std::strcpy(label, rs.label); rating = rs.rating; return *this;&#125; 由于hasDMA也使用动态内存分配，所以它也需要一个显式赋值运算符。作为hasDMA的方法，它只能直接访问hasDMA的数据。然而，派生类的显示赋值运算符必须负责所有继承的baseDMA基类对象的赋值，可以通过显示调用基类赋值运算符来完成这项工作： 12345678910hasDMA &amp;hasDMA::operator=(const hasDMA &amp;hs)&#123; if (this == &amp;hs) return *this; baseDMA::operator=(hs); // 显式赋值运算符，不能写成*this = hs;这件导致调用hasDMA::operator=(hs)，进而递归调用 delete [] style; style = new char[std::strlen(hs.style) + 1]; std::strcpy(style, hs.style); return *this;&#125; 第14章 C++中的代码重用14.1 三种继承此处，私有继承能否隐式向上转换有待查证。 14.1.1 使用using重新定义访问权限使用保护派生或私有派生时，基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，有两种方法： 在派生类中定义一个使用该基类方法的派生类方法，相当于一个包装器，将基类方法包装在公有方法中。 1234double Student::sum() const // public Student method&#123; return std::valarray&lt;double&gt;::sum(); // use privately-inherited method&#125; 使用一个using声明来指出派生类可以使用特定的基类成员，即使采用私有派生。 12345678class Student : private std::string, private std::valarray&lt;double&gt;&#123;...public: using std::valarray&lt;double&gt;::min; using std::valarray&lt;double&gt;::max; ...&#125;; 上述using声明使得valarray&lt;double&gt;::min()和valarray&lt;double&gt;::max()可用，就像它们是Student的公有方法一样。注意，using声明只使用成员名，没有圆括号、函数特征标和返回类型。 14.2 多重继承14.2.1 多个拷贝如果有以下继承层次： 12345678910111213141516171819class Worker&#123; ... &#125;;class Waiter : public Worker&#123; ...&#125;;class Singer : public Worker&#123; ...&#125;;class SingingWaiter : public Waiter, public Singer&#123; ...&#125;; 上述是一个典型的菱形继承，SingingWaiter类的对象中将包含两个Worker对象的拷贝： 使用指向Worker类的指针直接指向SingingWaiter的对象，将会出现二义性： 12SingingWaiter ed;Worker *pw = &amp;ed; // compile error 需使用强制类型转换： 12Worker *pw1 = (Waiter *)&amp;ed;Worker *pw2 = (Singer *)&amp;ed; 14.2.2 虚基类虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。 1234class Worker &#123;...&#125;;class Waiter : virtual public Worker &#123;...&#125;;class Singer : public virtual Worker &#123;...&#125;;class SingingWaiter : public Waiter, public Singer &#123;...&#125;; 上述代码使得Worker类被用作Waiter和Singer的虚基类，virtual和public的次序无关紧要。而SingingWaiter对象将只包含Worker对象的一个副本。从本质上说，继承的Singer和Waiter对象共享一个Worker对象的一个副本： 1 - 新的构造函数规则对于非虚基类，唯一可以出现在初始化列表中的构造函数是即时基类构造函数（直接基类构造函数），而这些构造函数可能需要将信息传递给其基类。 1234567891011121314151617181920212223class A&#123; int a; public: A(int n = 0) : a(n) &#123;&#125;&#125;;class B : public A&#123; int b;public: B(int m = 0, int n = 0) : A(m), b(n) &#123;&#125;&#125;;class C : public B&#123; int c; public: C(int m = 0, int n = 0, int q = 0) : B(m, n), c(q) &#123;&#125;&#125;; C类的构造函数只能调用B类的构造函数，不能直接调用A类的构造函数，而B类的构造函数只能调用A类的构造函数。这里，C类的构造函数使用值q，并将m和n传递给B类的构造函数，而B类的构造函数使用n，并将m传递给A类的构造函数。 12345678910111213141516171819202122232425262728293031323334353637class Worker&#123;private: string fullname; int id;public: Worker() : fullname(&quot;&quot;), id(-1) &#123;&#125; Worker(const string &amp;s, int n) : fullname(s), id(n) &#123;&#125;&#125;;class Waiter : virtual public Worker&#123;private: int panache;public: Waiter() : Worker(), panache(0) &#123;&#125; Waiter(const string &amp;s, int n, int p) : Worker(s, n), panache(p) &#123;&#125; Waiter(const Worker &amp;wk, int p) : Worker(wk), panache(p) &#123;&#125;&#125;;class Singer : virtual public Worker&#123;private: int voice;public: Singer() : Worker(), voice(0) &#123;&#125; Singer(const string &amp;s, int n, int v) : Worker(s, n), voice(v) &#123;&#125; Singer(const Worker &amp;wk, int v) : Worker(wk), voice(v) &#123;&#125;&#125;;class SingingWaiter : public Waiter, public Singer&#123; ... &#125;; 如果Worker是虚基类，则这种信息自动传递将不起作用。例如，对于下面的MI构造函数： 1SingingWaiter(const Worker &amp;wk, int p, int v) : Waiter(wk, p), Singer(wk, v) &#123;&#125; 原因是，自动传递信息时，将通过两条不同的路径（Waiter和Singer）将wk传递给Worker对象。为避免这种冲突，C++在基类是虚的时，禁止信息通过中间类自动传递给基类。因此，上述构造函数将初始化panache和voice，但wk参数中的信息将不会传递给子对象Waiter。然而，编译器必须在构造派生对象之前构造基类对象组件，在上述情况下，编译器将使用Worker的默认构造函数。 如果不希望默认构造函数来构造虚基类对象，则需要显示地调用所需的基类构造函数： 1SingingWaiter(const Worker &amp;wk, int p, int v) : Worker(wk), Waiter(wk, p), Singer(wk, v) &#123;&#125; 上述代码对虚基类是合法的，但对非虚基类，则不合法。 如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显示地调用该虚基类地某个构造函数。 2 - 哪个方法单根继承中，如果子类没有重新实现父类的方法，那么子类的将使用最近祖先中的定义。而在多重继承中，可能导致函数调用的二义性，例如，SingingWaiter的父类Waiter和Singer中都有Show方法，而SingingWaiter没有对Show方法重新实现，此时如果使用SingingWaiter的对象调用Show方法，将会导致二义性： 12SingingWaiter s; // 假设已经有了对应的构造函数的正确定义s.Show(); // compile error 有两种方式解决以上问题，一是使用类作用域解析运算符： 12s.Singer::Show();s.Waiter::Show(); 另一种就是在SingingWaiter类中实现Show方法。 3 - 虚基类和支配使用虚基类将改变C++解析二义性的方式。使用非虚基类时，规则很简单，如果类从不同的类那里继承了两个或更多的同名成员（数据或方法），则使用该成员名时，如果没有用类名进行限定，将导致二义性。但如果使用的是虚基类，则这样做不一定会导致二义性。在这种情况下，如果某个名称优先于其他所有名称，则使用它时，即便不使用限定符，也不会导致二义性。 123456789101112131415161718192021class B &#123;public: short q();&#125;;class C : virtual public B &#123;public: long q(); int omg();&#125;;class D : public C &#123;&#125;;class E : virtual public B &#123;private: int omg();&#125;class F : public D, public E &#123;&#125; 上述代码的继承树如下： 123456789101112 B / \\ / \\/ \\C E| |D | \\ | \\ | \\ | \\ | F C中的q()优先级比B中的q()优先级高，因此F中的方法可以用q()来表示C::q()。另一方面，C中的omg()与E中的omg()谁也不比谁的优先级高，因此F中使用非限定的omg()将导致二义性。 虚二义性规则与访问规则无关，从上面的例子可以看到，C中的omg()访问权限为public，而E中的omg()访问权限为private，不能在F中访问E::omg()，但使用omg()仍将导致二义性。 14.3 类模板14.3.1 类模板定义与使用14.3.2 非类型参数14.3.3 模板的多功能性 递归使用模板 使用多个类型参数 14.3.4 模板的具体化 隐式实例化 显示实例化 显示具体化 部分具体化 14.3.5 将模板用作参数14.3.6 模板类和友元 非模板友元 约束模板友元 非约束模板友元 14.4 C++定义别名 typedef using","categories":[],"tags":[]},{"title":"十大经典排序算法","slug":"sorted-algorithm","date":"2021-04-20T15:32:20.000Z","updated":"2021-04-22T16:22:49.699Z","comments":true,"path":"2021/04/20/sorted-algorithm/","link":"","permalink":"http://example.com/2021/04/20/sorted-algorithm/","excerpt":"","text":"1. 冒泡排序思路冒泡排序是一种比较排序，且会交换元素位置。以从小到大排序为例，每轮排序过程会比较相邻两数大小，如果大数在前，则交换相邻两束位置，因此每轮将得到剩余元素中的最大值。 代码实现123456789101112131415161718192021void bubble_sort(int arr[], int len)&#123; bool did_swap; int temp; for (int i = 0; i &lt; len - 1; ++i) &#123; did_swap = false; for (int j = 0; j &lt; len - i - 1; ++j) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; did_swap = true; &#125; &#125; if (did_swap == false) break; &#125;&#125; 复杂度分析最好情况下，数组已经排好序，仍需进行1轮的比较，时间复杂度为$O\\left(n\\right)$。最坏情况下，数组为倒序，总共需要$n^2$次比较，因此最坏时间复杂度为$O\\left(n^2\\right)$；平均时间复杂度为$O\\left(n^2\\right)$。 由于使用原数组进行元素交换排序，借用一个临时变量，因此时间复杂度为$O\\left(1\\right)$。 稳定性使用交换元素进行排序，如果数相同，不会进行交换位置，因此冒泡排序为稳定排序。 2.选择排序思路选择排序是一种简单直观的排序算法，它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 代码实现12345678910111213141516void selection_sort(int arr[], int len)&#123; int min_index, temp; for (int i = 0; i &lt; len - 1; ++i) &#123; min_index = i; for (int j = i + 1; j &lt; len; ++j) &#123; if (arr[min_index] &gt; arr[j]) min_index = j; &#125; temp = arr[i]; arr[i] = arr[min_index]; arr[min_index] = temp; &#125;&#125; 复杂度分析无论什么数据进去，都会进行进行$\\frac{n\\left(n-1\\right)}{2}$次比较，因此时间复杂度无论最好最坏还是平均，都是$O\\left(n^2\\right)$。 由于只是借用临时变量来存储最小值索引和交换时所用的临时变量，因此空间复杂度为$O\\left(1\\right)$。 稳定性选择排序是不稳定排序，例如5、8、5、2、9这个序列，第一次将第一个5和2交换，第一个5到了第二个5的后面。 3.插入排序思路插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。插入排序需要在有序表中查找合适的位置，通常从后往前扫描，找到相应的位置并插入。 代码实现1234567891011121314151617181920212223242526272829void insert_sort(int arr[], int len)&#123; int temp; for (int i = 1; i &lt; len; ++i) &#123; temp = arr[i]; // 注意下标 for (int j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp; --j) &#123; arr[j] = arr[j - 1]; &#125; arr[j] = temp; &#125;&#125;void insert_sort(int arr[], int len)&#123; int temp, pre; for (int i = 1; i &lt; len; ++i) &#123; temp = arr[i]; pre = i - 1; // 注意下标 while (pre &gt;= 0 &amp;&amp; arr[pre] &gt; temp) &#123; arr[pre + 1] = arr[pre]; --pre; &#125; arr[pre + 1] = temp; &#125;&#125; 复杂度分析最坏情况下数组逆序，需要比较$\\frac{n\\left(n - 1\\right)}{2}$次，时间复杂度为$O\\left(n^2\\right)$。最好情况下，数组有序，只需要跟前一个元素比较一次，共$n-1$次，时间复杂度为$O\\left(n\\right)$。平均时间复杂度为$O\\left(n^2\\right)$。 空间复杂度为$O\\left(1\\right)$。 稳定性由于比较用的是arr[pre] &gt; temp，因此不会向左查询位置时，不会越过与自身相同的值，为稳定排序。 4. 希尔排序思路希尔排序可以说是对插入排序的一种改进，通过设置增量将序列分组进行插入排序。随着增量逐渐减少，每组包含的数越来越多，当增量减为1时，整个序列恰好被分成一组，算法便终止。增量为几，序列就被分成几组。下面来看一个具体的排序案例： 假设序列长度为len，我们设置增量gap的初值为len / 2，并以gap /= 2的方式减少增量形成一个增量序列：$\\left(\\frac{1}{2}len，\\frac{1}{4}len，…，1\\right)$。这里的除法为整除，舍弃余数部分。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。下面是整个过程： 代码实现123456789101112131415161718void shell_sort(int arr[], int len)&#123; for (int gap = len / 2; gap &gt; 0; gap /= 2) &#123; /* 分组插入排序 */ for (int i = gap; i &lt; len; ++i) &#123; int temp = arr[i]; int j = i; while (j - gap &gt;= 0 &amp;&amp; arr[j - gap] &gt; arr[j]) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125;&#125; 上述代码实现时，内部for循环i的初值设置为gap，是因为下标为gap的元素即第一组的第二个元素，插入排序一般从第二个元素开始。 复杂度分析希尔排序最好情况下时间复杂度为$O\\left(n\\right)$，最坏情况下时间复杂度为$O\\left(n^2\\right)$。平均时间复杂度为$O\\left(n^{1.3}\\right)$。这里说的应该不一定指的是使用上述的增量序列的时间复杂度。 由于只是借助几个临时变量，且是在原数组上进行操作的，并未有额外的内存开销，因此空间复杂度为$O\\left(1\\right)$。 稳定性由于通过增量进行分组并分别在组内排序，希尔排序为不稳定排序。 5. 归并排序思路归并排序采用分治法，将序列分成两份，对两个子序列分别排完序后进行归并。而子序列的排序采用同样的策略，直到子序列的长度为1。 代码实现12345678910111213141516171819202122232425262728293031void merge(int arr[], int bak[], int start, int end)&#123; if (start &gt;= end) return; int mid = (end - start) &gt;&gt; 1 + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge(arr, bak, start, mid); merge(arr, bak, mid + 1, end); /* 归并 */ int k = start; while (start1 &lt;= end1 &amp;&amp; start &lt;= end2) bak[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt;= end1) bak[k++] = arr[start1++]; while (start2 &lt;= end2) bak[k++] = arr[start2++]; for (int i = start; i &lt;= end; ++i) arr[i] = bak[i];&#125;void merge_sort(int arr[], int len)&#123; int *backup = new int[len]; merge(arr, backup, 0, len - 1); delete[] backup;&#125; 复杂度分析归并排序的时间复杂度无论是最好还是最坏情况下都是$O\\left(nlogn\\right)$。 由于需要借助额外的空间来存储中间过程，空间复杂度为$O\\left(n\\right)$。 稳定性归并排序是稳定的。 未完待续….","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"剑指Offer09 - 用两个栈实现队列","slug":"algorithm1","date":"2021-04-16T14:14:27.000Z","updated":"2021-04-16T14:35:28.220Z","comments":true,"path":"2021/04/16/algorithm1/","link":"","permalink":"http://example.com/2021/04/16/algorithm1/","excerpt":"","text":"题目描述 用两个栈实现一个队列。队列的生命如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。（若队列中没有元素，deleteHead操作返回-1）。 123456/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-&gt;appendTail(value); * int param_2 = obj-&gt;deleteHead(); */ 思路使用两个栈实现队列，考察的是栈和队列的工作方式。栈是后进先出，队列是先进先出。假设有栈s1和栈s2，分析如下： 入队列：直接入栈s1 出队列： 如果栈s2为空，栈s1不为空，由于出栈是从栈顶弹出元素，而出队列是从队列首弹出元素，因此不能直接从栈s1出栈，需要借助栈s2。可以将s1中的元素逐个弹出并压入s2中，此时，最后入栈s1的就在栈s1的栈底，而最先入栈s1的元素在栈s2的栈顶。因此只要再从s2出栈，即可拿到最先入队列的元素。 如果栈s2为空，栈s1也为空，则队列中没有任何元素，返回-1。 如果栈s2不为空，可直接从s2出栈，得到的就是当前队列的队首元素。 代码实现123456789101112131415161718192021222324252627282930313233class CQueue &#123;public: stack&lt;int&gt; s1, s2; CQueue() &#123; while (!s1.empty()) s1.pop(); while (!s2.empty()) s2.pop(); &#125; void appendTail(int value) &#123; s1.push(value); &#125; int deleteHead() &#123; int temp; if (s2.empty()) &#123; while (!s1.empty()) &#123; temp = s1.top(); s1.pop(); s2.push(temp); &#125; &#125; if (s2.empty()) return -1; temp = s2.top(); s2.pop(); return temp; &#125;&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Hello World - Github+Hexo搭建个人博客","slug":"hello-world","date":"2021-04-16T14:11:12.697Z","updated":"2021-04-16T14:11:12.697Z","comments":true,"path":"2021/04/16/hello-world/","link":"","permalink":"http://example.com/2021/04/16/hello-world/","excerpt":"","text":"搭建个人博客有很多平台，比较受欢迎的就是基于Github使用Hexo框架搭建个人博客了。本文记载了一次使用Github+Hexo搭建个人博客的过程。 1 准备工作1.1 为Github配置ssh1.1.1 生成新的ssh密钥 打开终端，Windows上最好使用Git Bash，配置用户名和邮箱： 12$ git config --global user.name &quot;your_username&quot;$ git config --global user.email &quot;your_email@example.com&quot; 生成新的ssh密钥 1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 当提示输入一个文件来存储密钥时，按回车选择默认文件就好 1&gt; Enter a file in which to save the key (~/.ssh/id_rsa): [Press Enter] 当提示输入私钥密码时，按回车表示不使用私钥密码，也可以自行设置 12&gt; Enter passphrase (empty for no passphrase): [Type a passphrase or press enter]&gt; Enter same passphrase again: [Type a passphrase or press enter] 生成好后，密钥保存在~/.ssh/id_rsa文件中。 1.1.2 添加ssh密钥到ssh代理 后台启动ssh-agent 12$ eval &quot;$(ssh-agent -s)&quot;&gt; Agent pid 59566 根据官网的配置教程，如果你的系统是macOS Sierra 10.12.2或更高版本，需要修改~/.ssh/config文件自动加载密钥到ssh-agent，并在密钥链存储私钥密码。 检查~/.ssh/config文件是否存在 12$ open ~/.ssh/config&gt; The file /Users/you/.ssh/config does not exist. 如果文件不存在，则创建 1$ touch ~/.ssh/config 编辑~/.ssh/config文件 1234Host * Add KeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa 添加你的ssh私钥到ssh-agent并且存储私钥密码 1$ ssh-add -K ~/.ssh/id_rsa 1.1.3 添加ssh公钥到Github账号 复制ssh公钥，可以手动复制，也可以使用命令复制 12$ clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 打开Github，选择用户下的设置 选择”SSH and GPG keys” 点击”New SSH key” 将刚才复制的ssh公钥粘贴到key一栏，点击“Add SSH key”添加公钥 1.1.4 测试配置是否成功 打开终端或Git Bash，输入命令 12$ ssh -T git@github.com# Attempts to ssh to Github 你可能会看到如下警告： 123&gt; The authenticity of host &#x27;github.com (IP ADDRESS)&#x27; can&#x27;t be established.&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.&gt; Are you sure you want to continue connecting (yes/no)? 输入”yes”，如果显示以下信息，说明配置成功 12&gt; Hi username! You&#x27;ve successfully authenticated, but GitHub does not&gt; provide shell access. 如果你接收到了一个“permission denied”消息，说明配置失败，请参考Error: Permission denied (publickey)。 1.2 安装Node.js1.2.1 下载安装Node.jsMacOS下安装Node.js只需在官网下载.dmg包安装即可。 1.2.2 修改镜像为淘宝镜像国内推荐使用淘宝镜像加速npm下载，可使用如下命令配置： 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 2 博客搭建2.1 创建Github仓库以Github为平台，需要首先新建一个Github仓库，仓库名为username.github.io。 2.2 初始化本地环境 安装hexo框架： 1$ npm install -g hexo 新建本地目录，并使用hexo初始化： 12$ mkdir hexo &amp;&amp; cd hexo$ hexo init 在本地预览博客效果： 1$ hexo server 2.3 推送到Github仓库 配置博客根目录下的_config.yml: 12345678language: zh# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: git@github.com:username/username.github.io.git branch: master 注意，username字段请自行替换成自己的github用户名。 推送到github仓库 1$ hexo deploy 访问https://username.github.io，即可查看博客主页。 Hexo常用命令3.1 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server 3.3 Generate static files1$ hexo generate More info: Generating 3.4 Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Windows 10操作系统为Visual Studio 2019配置PCL 1.11.0","slug":"VS-PCL-Config-Win","date":"2021-04-15T12:44:04.000Z","updated":"2021-04-16T14:10:43.037Z","comments":true,"path":"2021/04/15/VS-PCL-Config-Win/","link":"","permalink":"http://example.com/2021/04/15/VS-PCL-Config-Win/","excerpt":"","text":"下载安装PCL访问PCL的Github官网，进入Release页面，找到PCL 1.11.0，点击进入后在Assets下面可看到4个文件，前两个就是我们需要的。 首先安装.exe包，选择添加环境变量时，勾选为所有用户添加环境变量： 安装路径可以自行更改，这里以D:\\pcl-1.11.0为例，路径中最好不要含空格： 安装过程中可能会提示路径过长，忽略即可。安装完后，打开安装目录下的3rdParty\\OpenNI2目录，双击OpenNI-Windows-x64-2.2.msi，先点击remove删除已安装的OpenNI，删除后再次打开该安装文件，安装目录选择D:\\PCL-1.11.0\\3rdParty\\OpenNI2。安装完毕后，将之前下载的.zip文件的所有内容解压到D:\\PCL-1.11.0\\bin下。 添加环境变量编辑用户的Path环境变量，添加以下内容： 配置Visual Studio项目属性配置打开Visual Studio，创建空项目，选择编译环境为64位，Debug版本： 选择菜单栏的“项目”—“属性”，设置调试环境为: 1PATH=D:\\PCL-1.11.0\\\\bin;D:\\PCL-1.11.0\\\\3rdParty\\FLANN\\bin;D:\\PCL-1.11.0\\\\3rdParty\\VTK\\bin;D:\\PCL-1.11.0\\\\3rdParty\\OpenNI2\\Tools 接着选择“C/C++”—“语言”，将符合模式设置为否： 还要在所有选项中将SDL检查设置为否： 属性表配置选择菜单栏的“视图”—“其他窗口”—“属性管理器”，在Debug | 64下新建项目属性表，命名为PCL 1.11.0 Debug x64.props： 创建完后，右键点击该属性表，选择属性： 在C/C++的所有选项中，将SDL检查设置为否： 接着配置Include目录： 紧接着配置库目录： 配置预处理器： 接下来配置附加依赖项： Debug版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147pcl_kdtreed.libpcl_stereod.libpcl_commond.libpcl_recognitiond.libpcl_keypointsd.libpcl_surfaced.libpcl_featuresd.libpcl_registrationd.libpcl_mld.libpcl_trackingd.libpcl_filtersd.libpcl_sample_consensusd.libpcl_octreed.libpcl_visualizationd.libpcl_searchd.libpcl_io_plyd.libpcl_outofcored.libpcl_iod.libpcl_segmentationd.libpcl_peopled.libvtkChartsCore-8.2-gd.libvtkCommonColor-8.2-gd.libvtkCommonComputationalGeometry-8.2-gd.libvtkCommonCore-8.2-gd.libvtkCommonDataModel-8.2-gd.libvtkCommonExecutionModel-8.2-gd.libvtkCommonMath-8.2-gd.libvtkCommonMisc-8.2-gd.libvtkCommonSystem-8.2-gd.libvtkCommonTransforms-8.2-gd.libvtkDICOMParser-8.2-gd.libvtkDomainsChemistry-8.2-gd.libvtkDomainsChemistryOpenGL2-8.2-gd.libvtkdoubleconversion-8.2-gd.libvtkexodusII-8.2-gd.libvtkexpat-8.2-gd.libvtkFiltersAMR-8.2-gd.libvtkFiltersCore-8.2-gd.libvtkFiltersExtraction-8.2-gd.libvtkFiltersFlowPaths-8.2-gd.libvtkFiltersGeneral-8.2-gd.libvtkFiltersGeneric-8.2-gd.libvtkFiltersGeometry-8.2-gd.libvtkFiltersHybrid-8.2-gd.libvtkFiltersHyperTree-8.2-gd.libvtkFiltersImaging-8.2-gd.libvtkFiltersModeling-8.2-gd.libvtkFiltersParallel-8.2-gd.libvtkFiltersParallelImaging-8.2-gd.libvtkFiltersPoints-8.2-gd.libvtkFiltersProgrammable-8.2-gd.libvtkFiltersSelection-8.2-gd.libvtkFiltersSMP-8.2-gd.libvtkFiltersSources-8.2-gd.libvtkFiltersStatistics-8.2-gd.libvtkFiltersTexture-8.2-gd.libvtkFiltersTopology-8.2-gd.libvtkFiltersVerdict-8.2-gd.libvtkfreetype-8.2-gd.libvtkGeovisCore-8.2-gd.libvtkgl2ps-8.2-gd.libvtkglew-8.2-gd.libvtkGUISupportMFC-8.2-gd.libvtkhdf5-8.2-gd.libvtkhdf5_hl-8.2-gd.libvtkImagingColor-8.2-gd.libvtkImagingCore-8.2-gd.libvtkImagingFourier-8.2-gd.libvtkImagingGeneral-8.2-gd.libvtkImagingHybrid-8.2-gd.libvtkImagingMath-8.2-gd.libvtkImagingMorphological-8.2-gd.libvtkImagingSources-8.2-gd.libvtkImagingStatistics-8.2-gd.libvtkImagingStencil-8.2-gd.libvtkInfovisCore-8.2-gd.libvtkInfovisLayout-8.2-gd.libvtkInteractionImage-8.2-gd.libvtkInteractionStyle-8.2-gd.libvtkInteractionWidgets-8.2-gd.libvtkIOAMR-8.2-gd.libvtkIOAsynchronous-8.2-gd.libvtkIOCityGML-8.2-gd.libvtkIOCore-8.2-gd.libvtkIOEnSight-8.2-gd.libvtkIOExodus-8.2-gd.libvtkIOExport-8.2-gd.libvtkIOExportOpenGL2-8.2-gd.libvtkIOExportPDF-8.2-gd.libvtkIOGeometry-8.2-gd.libvtkIOImage-8.2-gd.libvtkIOImport-8.2-gd.libvtkIOInfovis-8.2-gd.libvtkIOLegacy-8.2-gd.libvtkIOLSDyna-8.2-gd.libvtkIOMINC-8.2-gd.libvtkIOMovie-8.2-gd.libvtkIONetCDF-8.2-gd.libvtkIOParallel-8.2-gd.libvtkIOParallelXML-8.2-gd.libvtkIOPLY-8.2-gd.libvtkIOSegY-8.2-gd.libvtkIOSQL-8.2-gd.libvtkIOTecplotTable-8.2-gd.libvtkIOVeraOut-8.2-gd.libvtkIOVideo-8.2-gd.libvtkIOXML-8.2-gd.libvtkIOXMLParser-8.2-gd.libvtkjpeg-8.2-gd.libvtkjsoncpp-8.2-gd.libvtklibharu-8.2-gd.libvtklibxml2-8.2-gd.libvtklz4-8.2-gd.libvtklzma-8.2-gd.libvtkmetaio-8.2-gd.libvtkNetCDF-8.2-gd.libvtkogg-8.2-gd.libvtkParallelCore-8.2-gd.libvtkpng-8.2-gd.libvtkproj-8.2-gd.libvtkpugixml-8.2-gd.libvtkRenderingAnnotation-8.2-gd.libvtkRenderingContext2D-8.2-gd.libvtkRenderingContextOpenGL2-8.2-gd.libvtkRenderingCore-8.2-gd.libvtkRenderingExternal-8.2-gd.libvtkRenderingFreeType-8.2-gd.libvtkRenderingGL2PSOpenGL2-8.2-gd.libvtkRenderingImage-8.2-gd.libvtkRenderingLabel-8.2-gd.libvtkRenderingLOD-8.2-gd.libvtkRenderingOpenGL2-8.2-gd.libvtkRenderingVolume-8.2-gd.libvtkRenderingVolumeOpenGL2-8.2-gd.libvtksqlite-8.2-gd.libvtksys-8.2-gd.libvtktheora-8.2-gd.libvtktiff-8.2-gd.libvtkverdict-8.2-gd.libvtkViewsContext2D-8.2-gd.libvtkViewsCore-8.2-gd.libvtkViewsInfovis-8.2-gd.libvtkzlib-8.2-gd.libflann-gd.libflann_cpp-gd.libflann_cpp_s-gd.libflann_s-gd.lib 测试环境编写代码这里我们写上一段测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;ctime&gt;#include &lt;pcl/point_cloud.h&gt;#include &lt;pcl/octree/octree.h&gt;#include &lt;boost/thread/thread.hpp&gt;#include &lt;pcl/visualization/pcl_visualizer.h&gt;using namespace std;int main(int argc, char** argv)&#123; srand((unsigned int)time(NULL)); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); cloud-&gt;width = 1000; cloud-&gt;height = 1; cloud-&gt;points.resize(cloud-&gt;width * cloud-&gt;height); for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i) &#123; cloud-&gt;points[i].x = 1024.0f * rand() / (RAND_MAX + 1.0f); cloud-&gt;points[i].y = 1024.0f * rand() / (RAND_MAX + 1.0f); cloud-&gt;points[i].z = 1024.0f * rand() / (RAND_MAX + 1.0f); &#125; pcl::octree::OctreePointCloudSearch&lt;pcl::PointXYZ&gt; octree(0.1); octree.setInputCloud(cloud); octree.addPointsFromInputCloud(); pcl::PointXYZ searchPoint; searchPoint.x = 1024.0f * rand() / (RAND_MAX + 1.0f); searchPoint.y = 1024.0f * rand() / (RAND_MAX + 1.0f); searchPoint.z = 1024.0f * rand() / (RAND_MAX + 1.0f); vector&lt;int&gt;pointIdxRadiusSearch; vector&lt;float&gt;pointRadiusSquaredDistance; float radius = 256.0f * rand() / (RAND_MAX + 1.0f); cout &lt;&lt; &quot;Neighbors within radius search at (&quot; &lt;&lt; searchPoint.x &lt;&lt; &quot; &quot; &lt;&lt; searchPoint.y &lt;&lt; &quot; &quot; &lt;&lt; searchPoint.z &lt;&lt; &quot;) with radius=&quot; &lt;&lt; radius &lt;&lt; endl; if (octree.radiusSearch(searchPoint, radius, pointIdxRadiusSearch, pointRadiusSquaredDistance) &gt; 0) &#123; for (size_t i = 0; i &lt; pointIdxRadiusSearch.size(); ++i) cout &lt;&lt; &quot; &quot; &lt;&lt; cloud-&gt;points[pointIdxRadiusSearch[i]].x &lt;&lt; &quot; &quot; &lt;&lt; cloud-&gt;points[pointIdxRadiusSearch[i]].y &lt;&lt; &quot; &quot; &lt;&lt; cloud-&gt;points[pointIdxRadiusSearch[i]].z &lt;&lt; &quot; (squared distance: &quot; &lt;&lt; pointRadiusSquaredDistance[i] &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt;viewer(new pcl::visualization::PCLVisualizer(&quot;显示点云&quot;)); viewer-&gt;setBackgroundColor(0, 0, 0); pcl::visualization::PointCloudColorHandlerCustom&lt;pcl::PointXYZ&gt;target_color(cloud, 255, 0, 0); viewer-&gt;addPointCloud&lt;pcl::PointXYZ&gt;(cloud, target_color, &quot;target cloud&quot;); viewer-&gt;setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, &quot;target cloud&quot;); while (!viewer-&gt;wasStopped()) &#123; viewer-&gt;spinOnce(100); boost::this_thread::sleep(boost::posix_time::microseconds(1000)); &#125; return (0);&#125; Debug运行 小结以上就是在Windows 10操作系统下，为Visual Studio 2019配置点云库PCL 1.11.0的过程。当然，上面用的是debug版本，也可以换成release版本，只要附加依赖的内容换成release的内容即可，这里给出release版本的附加依赖的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147pcl_kdtreed.libpcl_stereod.libpcl_commond.libpcl_recognitiond.libpcl_keypointsd.libpcl_surfaced.libpcl_featuresd.libpcl_registrationd.libpcl_mld.libpcl_trackingd.libpcl_filtersd.libpcl_sample_consensusd.libpcl_octreed.libpcl_visualizationd.libpcl_searchd.libpcl_io_plyd.libpcl_outofcored.libpcl_iod.libpcl_segmentationd.libpcl_peopled.libvtkChartsCore-8.2.libvtkCommonColor-8.2.libvtkCommonComputationalGeometry-8.2.libvtkCommonCore-8.2.libvtkCommonDataModel-8.2.libvtkCommonExecutionModel-8.2.libvtkCommonMath-8.2.libvtkCommonMisc-8.2.libvtkCommonSystem-8.2.libvtkCommonTransforms-8.2.libvtkDICOMParser-8.2.libvtkDomainsChemistry-8.2.libvtkDomainsChemistryOpenGL2-8.2.libvtkdoubleconversion-8.2.libvtkexodusII-8.2.libvtkexpat-8.2.libvtkFiltersAMR-8.2.libvtkFiltersCore-8.2.libvtkFiltersExtraction-8.2.libvtkFiltersFlowPaths-8.2.libvtkFiltersGeneral-8.2.libvtkFiltersGeneric-8.2.libvtkFiltersGeometry-8.2.libvtkFiltersHybrid-8.2.libvtkFiltersHyperTree-8.2.libvtkFiltersImaging-8.2.libvtkFiltersModeling-8.2.libvtkFiltersParallel-8.2.libvtkFiltersParallelImaging-8.2.libvtkFiltersPoints-8.2.libvtkFiltersProgrammable-8.2.libvtkFiltersSelection-8.2.libvtkFiltersSMP-8.2.libvtkFiltersSources-8.2.libvtkFiltersStatistics-8.2.libvtkFiltersTexture-8.2.libvtkFiltersTopology-8.2.libvtkFiltersVerdict-8.2.libvtkfreetype-8.2.libvtkGeovisCore-8.2.libvtkgl2ps-8.2.libvtkglew-8.2.libvtkGUISupportMFC-8.2.libvtkhdf5-8.2.libvtkhdf5_hl-8.2.libvtkImagingColor-8.2.libvtkImagingCore-8.2.libvtkImagingFourier-8.2.libvtkImagingGeneral-8.2.libvtkImagingHybrid-8.2.libvtkImagingMath-8.2.libvtkImagingMorphological-8.2.libvtkImagingSources-8.2.libvtkImagingStatistics-8.2.libvtkImagingStencil-8.2.libvtkInfovisCore-8.2.libvtkInfovisLayout-8.2.libvtkInteractionImage-8.2.libvtkInteractionStyle-8.2.libvtkInteractionWidgets-8.2.libvtkIOAMR-8.2.libvtkIOAsynchronous-8.2.libvtkIOCityGML-8.2.libvtkIOCore-8.2.libvtkIOEnSight-8.2.libvtkIOExodus-8.2.libvtkIOExport-8.2.libvtkIOExportOpenGL2-8.2.libvtkIOExportPDF-8.2.libvtkIOGeometry-8.2.libvtkIOImage-8.2.libvtkIOImport-8.2.libvtkIOInfovis-8.2.libvtkIOLegacy-8.2.libvtkIOLSDyna-8.2.libvtkIOMINC-8.2.libvtkIOMovie-8.2.libvtkIONetCDF-8.2.libvtkIOParallel-8.2.libvtkIOParallelXML-8.2.libvtkIOPLY-8.2.libvtkIOSegY-8.2.libvtkIOSQL-8.2.libvtkIOTecplotTable-8.2.libvtkIOVeraOut-8.2.libvtkIOVideo-8.2.libvtkIOXML-8.2.libvtkIOXMLParser-8.2.libvtkjpeg-8.2.libvtkjsoncpp-8.2.libvtklibharu-8.2.libvtklibxml2-8.2.libvtklz4-8.2.libvtklzma-8.2.libvtkmetaio-8.2.libvtkNetCDF-8.2.libvtkogg-8.2.libvtkParallelCore-8.2.libvtkpng-8.2.libvtkproj-8.2.libvtkpugixml-8.2.libvtkRenderingAnnotation-8.2.libvtkRenderingContext2D-8.2.libvtkRenderingContextOpenGL2-8.2.libvtkRenderingCore-8.2.libvtkRenderingExternal-8.2.libvtkRenderingFreeType-8.2.libvtkRenderingGL2PSOpenGL2-8.2.libvtkRenderingImage-8.2.libvtkRenderingLabel-8.2.libvtkRenderingLOD-8.2.libvtkRenderingOpenGL2-8.2.libvtkRenderingVolume-8.2.libvtkRenderingVolumeOpenGL2-8.2.libvtksqlite-8.2.libvtksys-8.2.libvtktheora-8.2.libvtktiff-8.2.libvtkverdict-8.2.libvtkViewsContext2D-8.2.libvtkViewsCore-8.2.libvtkViewsInfovis-8.2.libvtkzlib-8.2.libflann.libflann_cpp.libflann_cpp_s.libflann_s.lib","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"PCL","slug":"PCL","permalink":"http://example.com/tags/PCL/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"PCL","slug":"PCL","permalink":"http://example.com/tags/PCL/"}]}