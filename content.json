{"meta":{"title":"Hexo","subtitle":"Keep Learning","description":"A personal blog based on github and hexo","author":"Cleo","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-04-16T14:02:50.000Z","updated":"2021-04-16T14:03:12.052Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-16T14:00:40.000Z","updated":"2021-04-16T14:02:36.525Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"十大经典排序算法","slug":"sorted-algorithm","date":"2021-04-20T15:32:20.000Z","updated":"2021-04-21T16:28:16.408Z","comments":true,"path":"2021/04/20/sorted-algorithm/","link":"","permalink":"http://example.com/2021/04/20/sorted-algorithm/","excerpt":"","text":"1. 冒泡排序思路冒泡排序是一种比较排序，且会交换元素位置。以从小到大排序为例，每轮排序过程会比较相邻两数大小，如果大数在前，则交换相邻两束位置，因此每轮将得到剩余元素中的最大值。 代码实现123456789101112131415161718192021void bubble_sort(int arr[], int len)&#123; bool did_swap; int temp; for (int i = 0; i &lt; len - 1; ++i) &#123; did_swap = false; for (int j = 0; j &lt; len - i - 1; ++j) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; did_swap = true; &#125; &#125; if (!did_swap) break; &#125;&#125; 复杂度分析最好情况下，数组已经排好序，仍需进行1轮的比较，时间复杂度为$O\\left(n\\right)$。最坏情况下，数组为倒序，总共需要$n^2$次比较，因此最坏时间复杂度为$O\\left(n^2\\right)$；平均时间复杂度为$O\\left(n^2\\right)$。 由于使用原数组进行元素交换排序，借用一个临时变量，因此时间复杂度为$O\\left(1\\right)$。 稳定性使用交换元素进行排序，如果数相同，不会进行交换位置，因此冒泡排序为稳定排序。 2.选择排序思路选择排序是一种简单直观的排序算法，它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 代码实现12345678910111213141516void selection_sort(int arr[], int len)&#123; int min_index, temp; for (int i = 0; i &lt; len - 1; ++i) &#123; min_index = i; for (int j = i + 1; j &lt; len; ++j) &#123; if (arr[min_index] &gt; arr[j]) min_index = j; &#125; temp = arr[i]; arr[i] = arr[min_index]; arr[min_index] = temp; &#125;&#125; 复杂度分析无论什么数据进去，都会进行进行$\\frac{n\\left(n-1\\right)}{2}$次比较，因此时间复杂度无论最好最坏还是平均，都是$O\\left(n^2\\right)$。 由于只是借用临时变量来存储最小值索引和交换时所用的临时变量，因此空间复杂度为$O\\left(1\\right)$。 稳定性选择排序是不稳定排序，例如5、8、5、2、9这个序列，第一次将第一个5和2交换，第一个5到了第二个5的后面。 3.插入排序思路插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。插入排序需要在有序表中查找合适的位置，通常从后往前扫描，找到相应的位置并插入。 代码实现1234567891011121314151617181920212223242526272829void insert_sort(int arr[], int len)&#123; int temp; for (int i = 1; i &lt; len; ++i) &#123; temp = arr[i]; // 注意下标 for (int j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp; --j) &#123; arr[j] = arr[j - 1]; &#125; arr[j] = temp; &#125;&#125;void insert_sort(int arr[], int len)&#123; int temp, pre; for (int i = 1; i &lt; len; ++i) &#123; temp = arr[i]; pre = i - 1; // 注意下标 while (pre &gt;= 0 &amp;&amp; arr[pre] &gt; temp) &#123; arr[pre + 1] = arr[pre]; --pre; &#125; arr[pre + 1] = temp; &#125;&#125; 复杂度分析最坏情况下数组逆序，需要比较$\\frac{n\\left(n - 1\\right)}{2}$次，时间复杂度为$O\\left(n^2\\right)$。最好情况下，数组有序，只需要跟前一个元素比较一次，共$n-1$次，时间复杂度为$O\\left(n\\right)$。平均时间复杂度为$O\\left(n^2\\right)$。 空间复杂度为$O\\left(1\\right)$。 稳定性由于比较用的是arr[pre] &gt; temp，因此不会向左查询位置时，不会越过与自身相同的值，为稳定排序。 4. 希尔排序思路希尔排序可以说是对插入排序的一种改进，通过设置增量将序列分组进行插入排序。随着增量逐渐减少，每组包含的数越来越多，当增量减为1时，整个序列恰好被分成一组，算法便终止。增量为几，序列就被分成几组。下面来看一个具体的排序案例： 假设序列长度为len，我们设置增量gap的初值为len / 2，并以gap /= 2的方式减少增量形成一个增量序列：$\\left(\\frac{1}{2}len，\\frac{1}{4}len，…，1\\right)$。这里的除法为整除，舍弃余数部分。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。下面是整个过程： 代码实现123456789101112131415161718void shell_sort(int arr[], int len)&#123; for (int gap = len / 2; gap &gt; 0; gap /= 2) &#123; /* 分组插入排序 */ for (int i = gap; i &lt; len; ++i) &#123; int temp = arr[i]; int j = i; while (j - gap &gt;= 0 &amp;&amp; arr[j - gap] &gt; arr[j]) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125;&#125; 上述代码实现时，内部for循环i的初值设置为gap，是因为下标为gap的元素即第一组的第二个元素，插入排序一般从第二个元素开始。 复杂度分析希尔排序最好情况下时间复杂度为$O\\left(n\\right)$，最坏情况下时间复杂度为$O\\left(n^2\\right)$。平均时间复杂度为$O\\left(n^{1.3}\\right)$。这里说的应该不一定指的是使用上述的增量序列的时间复杂度。 由于只是借助几个临时变量，且是在原数组上进行操作的，并未有额外的内存开销，因此空间复杂度为$O\\left(1\\right)$。 稳定性由于通过增量进行分组并分别在组内排序，希尔排序为不稳定排序。 未完待续…","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"剑指Offer09 - 用两个栈实现队列","slug":"algorithm1","date":"2021-04-16T14:14:27.000Z","updated":"2021-04-16T14:35:28.220Z","comments":true,"path":"2021/04/16/algorithm1/","link":"","permalink":"http://example.com/2021/04/16/algorithm1/","excerpt":"","text":"题目描述 用两个栈实现一个队列。队列的生命如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。（若队列中没有元素，deleteHead操作返回-1）。 123456/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-&gt;appendTail(value); * int param_2 = obj-&gt;deleteHead(); */ 思路使用两个栈实现队列，考察的是栈和队列的工作方式。栈是后进先出，队列是先进先出。假设有栈s1和栈s2，分析如下： 入队列：直接入栈s1 出队列： 如果栈s2为空，栈s1不为空，由于出栈是从栈顶弹出元素，而出队列是从队列首弹出元素，因此不能直接从栈s1出栈，需要借助栈s2。可以将s1中的元素逐个弹出并压入s2中，此时，最后入栈s1的就在栈s1的栈底，而最先入栈s1的元素在栈s2的栈顶。因此只要再从s2出栈，即可拿到最先入队列的元素。 如果栈s2为空，栈s1也为空，则队列中没有任何元素，返回-1。 如果栈s2不为空，可直接从s2出栈，得到的就是当前队列的队首元素。 代码实现123456789101112131415161718192021222324252627282930313233class CQueue &#123;public: stack&lt;int&gt; s1, s2; CQueue() &#123; while (!s1.empty()) s1.pop(); while (!s2.empty()) s2.pop(); &#125; void appendTail(int value) &#123; s1.push(value); &#125; int deleteHead() &#123; int temp; if (s2.empty()) &#123; while (!s1.empty()) &#123; temp = s1.top(); s1.pop(); s2.push(temp); &#125; &#125; if (s2.empty()) return -1; temp = s2.top(); s2.pop(); return temp; &#125;&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Hello World - Github+Hexo搭建个人博客","slug":"hello-world","date":"2021-04-16T14:11:12.697Z","updated":"2021-04-16T14:11:12.697Z","comments":true,"path":"2021/04/16/hello-world/","link":"","permalink":"http://example.com/2021/04/16/hello-world/","excerpt":"","text":"搭建个人博客有很多平台，比较受欢迎的就是基于Github使用Hexo框架搭建个人博客了。本文记载了一次使用Github+Hexo搭建个人博客的过程。 1 准备工作1.1 为Github配置ssh1.1.1 生成新的ssh密钥 打开终端，Windows上最好使用Git Bash，配置用户名和邮箱： 12$ git config --global user.name &quot;your_username&quot;$ git config --global user.email &quot;your_email@example.com&quot; 生成新的ssh密钥 1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 当提示输入一个文件来存储密钥时，按回车选择默认文件就好 1&gt; Enter a file in which to save the key (~/.ssh/id_rsa): [Press Enter] 当提示输入私钥密码时，按回车表示不使用私钥密码，也可以自行设置 12&gt; Enter passphrase (empty for no passphrase): [Type a passphrase or press enter]&gt; Enter same passphrase again: [Type a passphrase or press enter] 生成好后，密钥保存在~/.ssh/id_rsa文件中。 1.1.2 添加ssh密钥到ssh代理 后台启动ssh-agent 12$ eval &quot;$(ssh-agent -s)&quot;&gt; Agent pid 59566 根据官网的配置教程，如果你的系统是macOS Sierra 10.12.2或更高版本，需要修改~/.ssh/config文件自动加载密钥到ssh-agent，并在密钥链存储私钥密码。 检查~/.ssh/config文件是否存在 12$ open ~/.ssh/config&gt; The file /Users/you/.ssh/config does not exist. 如果文件不存在，则创建 1$ touch ~/.ssh/config 编辑~/.ssh/config文件 1234Host * Add KeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa 添加你的ssh私钥到ssh-agent并且存储私钥密码 1$ ssh-add -K ~/.ssh/id_rsa 1.1.3 添加ssh公钥到Github账号 复制ssh公钥，可以手动复制，也可以使用命令复制 12$ clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 打开Github，选择用户下的设置 选择”SSH and GPG keys” 点击”New SSH key” 将刚才复制的ssh公钥粘贴到key一栏，点击“Add SSH key”添加公钥 1.1.4 测试配置是否成功 打开终端或Git Bash，输入命令 12$ ssh -T git@github.com# Attempts to ssh to Github 你可能会看到如下警告： 123&gt; The authenticity of host &#x27;github.com (IP ADDRESS)&#x27; can&#x27;t be established.&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.&gt; Are you sure you want to continue connecting (yes/no)? 输入”yes”，如果显示以下信息，说明配置成功 12&gt; Hi username! You&#x27;ve successfully authenticated, but GitHub does not&gt; provide shell access. 如果你接收到了一个“permission denied”消息，说明配置失败，请参考Error: Permission denied (publickey)。 1.2 安装Node.js1.2.1 下载安装Node.jsMacOS下安装Node.js只需在官网下载.dmg包安装即可。 1.2.2 修改镜像为淘宝镜像国内推荐使用淘宝镜像加速npm下载，可使用如下命令配置： 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 2 博客搭建2.1 创建Github仓库以Github为平台，需要首先新建一个Github仓库，仓库名为username.github.io。 2.2 初始化本地环境 安装hexo框架： 1$ npm install -g hexo 新建本地目录，并使用hexo初始化： 12$ mkdir hexo &amp;&amp; cd hexo$ hexo init 在本地预览博客效果： 1$ hexo server 2.3 推送到Github仓库 配置博客根目录下的_config.yml: 12345678language: zh# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: git@github.com:username/username.github.io.git branch: master 注意，username字段请自行替换成自己的github用户名。 推送到github仓库 1$ hexo deploy 访问https://username.github.io，即可查看博客主页。 Hexo常用命令3.1 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server 3.3 Generate static files1$ hexo generate More info: Generating 3.4 Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Windows 10操作系统为Visual Studio 2019配置PCL 1.11.0","slug":"VS-PCL-Config-Win","date":"2021-04-15T12:44:04.000Z","updated":"2021-04-16T14:10:43.037Z","comments":true,"path":"2021/04/15/VS-PCL-Config-Win/","link":"","permalink":"http://example.com/2021/04/15/VS-PCL-Config-Win/","excerpt":"","text":"下载安装PCL访问PCL的Github官网，进入Release页面，找到PCL 1.11.0，点击进入后在Assets下面可看到4个文件，前两个就是我们需要的。 首先安装.exe包，选择添加环境变量时，勾选为所有用户添加环境变量： 安装路径可以自行更改，这里以D:\\pcl-1.11.0为例，路径中最好不要含空格： 安装过程中可能会提示路径过长，忽略即可。安装完后，打开安装目录下的3rdParty\\OpenNI2目录，双击OpenNI-Windows-x64-2.2.msi，先点击remove删除已安装的OpenNI，删除后再次打开该安装文件，安装目录选择D:\\PCL-1.11.0\\3rdParty\\OpenNI2。安装完毕后，将之前下载的.zip文件的所有内容解压到D:\\PCL-1.11.0\\bin下。 添加环境变量编辑用户的Path环境变量，添加以下内容： 配置Visual Studio项目属性配置打开Visual Studio，创建空项目，选择编译环境为64位，Debug版本： 选择菜单栏的“项目”—“属性”，设置调试环境为: 1PATH=D:\\PCL-1.11.0\\\\bin;D:\\PCL-1.11.0\\\\3rdParty\\FLANN\\bin;D:\\PCL-1.11.0\\\\3rdParty\\VTK\\bin;D:\\PCL-1.11.0\\\\3rdParty\\OpenNI2\\Tools 接着选择“C/C++”—“语言”，将符合模式设置为否： 还要在所有选项中将SDL检查设置为否： 属性表配置选择菜单栏的“视图”—“其他窗口”—“属性管理器”，在Debug | 64下新建项目属性表，命名为PCL 1.11.0 Debug x64.props： 创建完后，右键点击该属性表，选择属性： 在C/C++的所有选项中，将SDL检查设置为否： 接着配置Include目录： 紧接着配置库目录： 配置预处理器： 接下来配置附加依赖项： Debug版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147pcl_kdtreed.libpcl_stereod.libpcl_commond.libpcl_recognitiond.libpcl_keypointsd.libpcl_surfaced.libpcl_featuresd.libpcl_registrationd.libpcl_mld.libpcl_trackingd.libpcl_filtersd.libpcl_sample_consensusd.libpcl_octreed.libpcl_visualizationd.libpcl_searchd.libpcl_io_plyd.libpcl_outofcored.libpcl_iod.libpcl_segmentationd.libpcl_peopled.libvtkChartsCore-8.2-gd.libvtkCommonColor-8.2-gd.libvtkCommonComputationalGeometry-8.2-gd.libvtkCommonCore-8.2-gd.libvtkCommonDataModel-8.2-gd.libvtkCommonExecutionModel-8.2-gd.libvtkCommonMath-8.2-gd.libvtkCommonMisc-8.2-gd.libvtkCommonSystem-8.2-gd.libvtkCommonTransforms-8.2-gd.libvtkDICOMParser-8.2-gd.libvtkDomainsChemistry-8.2-gd.libvtkDomainsChemistryOpenGL2-8.2-gd.libvtkdoubleconversion-8.2-gd.libvtkexodusII-8.2-gd.libvtkexpat-8.2-gd.libvtkFiltersAMR-8.2-gd.libvtkFiltersCore-8.2-gd.libvtkFiltersExtraction-8.2-gd.libvtkFiltersFlowPaths-8.2-gd.libvtkFiltersGeneral-8.2-gd.libvtkFiltersGeneric-8.2-gd.libvtkFiltersGeometry-8.2-gd.libvtkFiltersHybrid-8.2-gd.libvtkFiltersHyperTree-8.2-gd.libvtkFiltersImaging-8.2-gd.libvtkFiltersModeling-8.2-gd.libvtkFiltersParallel-8.2-gd.libvtkFiltersParallelImaging-8.2-gd.libvtkFiltersPoints-8.2-gd.libvtkFiltersProgrammable-8.2-gd.libvtkFiltersSelection-8.2-gd.libvtkFiltersSMP-8.2-gd.libvtkFiltersSources-8.2-gd.libvtkFiltersStatistics-8.2-gd.libvtkFiltersTexture-8.2-gd.libvtkFiltersTopology-8.2-gd.libvtkFiltersVerdict-8.2-gd.libvtkfreetype-8.2-gd.libvtkGeovisCore-8.2-gd.libvtkgl2ps-8.2-gd.libvtkglew-8.2-gd.libvtkGUISupportMFC-8.2-gd.libvtkhdf5-8.2-gd.libvtkhdf5_hl-8.2-gd.libvtkImagingColor-8.2-gd.libvtkImagingCore-8.2-gd.libvtkImagingFourier-8.2-gd.libvtkImagingGeneral-8.2-gd.libvtkImagingHybrid-8.2-gd.libvtkImagingMath-8.2-gd.libvtkImagingMorphological-8.2-gd.libvtkImagingSources-8.2-gd.libvtkImagingStatistics-8.2-gd.libvtkImagingStencil-8.2-gd.libvtkInfovisCore-8.2-gd.libvtkInfovisLayout-8.2-gd.libvtkInteractionImage-8.2-gd.libvtkInteractionStyle-8.2-gd.libvtkInteractionWidgets-8.2-gd.libvtkIOAMR-8.2-gd.libvtkIOAsynchronous-8.2-gd.libvtkIOCityGML-8.2-gd.libvtkIOCore-8.2-gd.libvtkIOEnSight-8.2-gd.libvtkIOExodus-8.2-gd.libvtkIOExport-8.2-gd.libvtkIOExportOpenGL2-8.2-gd.libvtkIOExportPDF-8.2-gd.libvtkIOGeometry-8.2-gd.libvtkIOImage-8.2-gd.libvtkIOImport-8.2-gd.libvtkIOInfovis-8.2-gd.libvtkIOLegacy-8.2-gd.libvtkIOLSDyna-8.2-gd.libvtkIOMINC-8.2-gd.libvtkIOMovie-8.2-gd.libvtkIONetCDF-8.2-gd.libvtkIOParallel-8.2-gd.libvtkIOParallelXML-8.2-gd.libvtkIOPLY-8.2-gd.libvtkIOSegY-8.2-gd.libvtkIOSQL-8.2-gd.libvtkIOTecplotTable-8.2-gd.libvtkIOVeraOut-8.2-gd.libvtkIOVideo-8.2-gd.libvtkIOXML-8.2-gd.libvtkIOXMLParser-8.2-gd.libvtkjpeg-8.2-gd.libvtkjsoncpp-8.2-gd.libvtklibharu-8.2-gd.libvtklibxml2-8.2-gd.libvtklz4-8.2-gd.libvtklzma-8.2-gd.libvtkmetaio-8.2-gd.libvtkNetCDF-8.2-gd.libvtkogg-8.2-gd.libvtkParallelCore-8.2-gd.libvtkpng-8.2-gd.libvtkproj-8.2-gd.libvtkpugixml-8.2-gd.libvtkRenderingAnnotation-8.2-gd.libvtkRenderingContext2D-8.2-gd.libvtkRenderingContextOpenGL2-8.2-gd.libvtkRenderingCore-8.2-gd.libvtkRenderingExternal-8.2-gd.libvtkRenderingFreeType-8.2-gd.libvtkRenderingGL2PSOpenGL2-8.2-gd.libvtkRenderingImage-8.2-gd.libvtkRenderingLabel-8.2-gd.libvtkRenderingLOD-8.2-gd.libvtkRenderingOpenGL2-8.2-gd.libvtkRenderingVolume-8.2-gd.libvtkRenderingVolumeOpenGL2-8.2-gd.libvtksqlite-8.2-gd.libvtksys-8.2-gd.libvtktheora-8.2-gd.libvtktiff-8.2-gd.libvtkverdict-8.2-gd.libvtkViewsContext2D-8.2-gd.libvtkViewsCore-8.2-gd.libvtkViewsInfovis-8.2-gd.libvtkzlib-8.2-gd.libflann-gd.libflann_cpp-gd.libflann_cpp_s-gd.libflann_s-gd.lib 测试环境编写代码这里我们写上一段测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;ctime&gt;#include &lt;pcl/point_cloud.h&gt;#include &lt;pcl/octree/octree.h&gt;#include &lt;boost/thread/thread.hpp&gt;#include &lt;pcl/visualization/pcl_visualizer.h&gt;using namespace std;int main(int argc, char** argv)&#123; srand((unsigned int)time(NULL)); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); cloud-&gt;width = 1000; cloud-&gt;height = 1; cloud-&gt;points.resize(cloud-&gt;width * cloud-&gt;height); for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i) &#123; cloud-&gt;points[i].x = 1024.0f * rand() / (RAND_MAX + 1.0f); cloud-&gt;points[i].y = 1024.0f * rand() / (RAND_MAX + 1.0f); cloud-&gt;points[i].z = 1024.0f * rand() / (RAND_MAX + 1.0f); &#125; pcl::octree::OctreePointCloudSearch&lt;pcl::PointXYZ&gt; octree(0.1); octree.setInputCloud(cloud); octree.addPointsFromInputCloud(); pcl::PointXYZ searchPoint; searchPoint.x = 1024.0f * rand() / (RAND_MAX + 1.0f); searchPoint.y = 1024.0f * rand() / (RAND_MAX + 1.0f); searchPoint.z = 1024.0f * rand() / (RAND_MAX + 1.0f); vector&lt;int&gt;pointIdxRadiusSearch; vector&lt;float&gt;pointRadiusSquaredDistance; float radius = 256.0f * rand() / (RAND_MAX + 1.0f); cout &lt;&lt; &quot;Neighbors within radius search at (&quot; &lt;&lt; searchPoint.x &lt;&lt; &quot; &quot; &lt;&lt; searchPoint.y &lt;&lt; &quot; &quot; &lt;&lt; searchPoint.z &lt;&lt; &quot;) with radius=&quot; &lt;&lt; radius &lt;&lt; endl; if (octree.radiusSearch(searchPoint, radius, pointIdxRadiusSearch, pointRadiusSquaredDistance) &gt; 0) &#123; for (size_t i = 0; i &lt; pointIdxRadiusSearch.size(); ++i) cout &lt;&lt; &quot; &quot; &lt;&lt; cloud-&gt;points[pointIdxRadiusSearch[i]].x &lt;&lt; &quot; &quot; &lt;&lt; cloud-&gt;points[pointIdxRadiusSearch[i]].y &lt;&lt; &quot; &quot; &lt;&lt; cloud-&gt;points[pointIdxRadiusSearch[i]].z &lt;&lt; &quot; (squared distance: &quot; &lt;&lt; pointRadiusSquaredDistance[i] &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt;viewer(new pcl::visualization::PCLVisualizer(&quot;显示点云&quot;)); viewer-&gt;setBackgroundColor(0, 0, 0); pcl::visualization::PointCloudColorHandlerCustom&lt;pcl::PointXYZ&gt;target_color(cloud, 255, 0, 0); viewer-&gt;addPointCloud&lt;pcl::PointXYZ&gt;(cloud, target_color, &quot;target cloud&quot;); viewer-&gt;setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, &quot;target cloud&quot;); while (!viewer-&gt;wasStopped()) &#123; viewer-&gt;spinOnce(100); boost::this_thread::sleep(boost::posix_time::microseconds(1000)); &#125; return (0);&#125; Debug运行 小结以上就是在Windows 10操作系统下，为Visual Studio 2019配置点云库PCL 1.11.0的过程。当然，上面用的是debug版本，也可以换成release版本，只要附加依赖的内容换成release的内容即可，这里给出release版本的附加依赖的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147pcl_kdtreed.libpcl_stereod.libpcl_commond.libpcl_recognitiond.libpcl_keypointsd.libpcl_surfaced.libpcl_featuresd.libpcl_registrationd.libpcl_mld.libpcl_trackingd.libpcl_filtersd.libpcl_sample_consensusd.libpcl_octreed.libpcl_visualizationd.libpcl_searchd.libpcl_io_plyd.libpcl_outofcored.libpcl_iod.libpcl_segmentationd.libpcl_peopled.libvtkChartsCore-8.2.libvtkCommonColor-8.2.libvtkCommonComputationalGeometry-8.2.libvtkCommonCore-8.2.libvtkCommonDataModel-8.2.libvtkCommonExecutionModel-8.2.libvtkCommonMath-8.2.libvtkCommonMisc-8.2.libvtkCommonSystem-8.2.libvtkCommonTransforms-8.2.libvtkDICOMParser-8.2.libvtkDomainsChemistry-8.2.libvtkDomainsChemistryOpenGL2-8.2.libvtkdoubleconversion-8.2.libvtkexodusII-8.2.libvtkexpat-8.2.libvtkFiltersAMR-8.2.libvtkFiltersCore-8.2.libvtkFiltersExtraction-8.2.libvtkFiltersFlowPaths-8.2.libvtkFiltersGeneral-8.2.libvtkFiltersGeneric-8.2.libvtkFiltersGeometry-8.2.libvtkFiltersHybrid-8.2.libvtkFiltersHyperTree-8.2.libvtkFiltersImaging-8.2.libvtkFiltersModeling-8.2.libvtkFiltersParallel-8.2.libvtkFiltersParallelImaging-8.2.libvtkFiltersPoints-8.2.libvtkFiltersProgrammable-8.2.libvtkFiltersSelection-8.2.libvtkFiltersSMP-8.2.libvtkFiltersSources-8.2.libvtkFiltersStatistics-8.2.libvtkFiltersTexture-8.2.libvtkFiltersTopology-8.2.libvtkFiltersVerdict-8.2.libvtkfreetype-8.2.libvtkGeovisCore-8.2.libvtkgl2ps-8.2.libvtkglew-8.2.libvtkGUISupportMFC-8.2.libvtkhdf5-8.2.libvtkhdf5_hl-8.2.libvtkImagingColor-8.2.libvtkImagingCore-8.2.libvtkImagingFourier-8.2.libvtkImagingGeneral-8.2.libvtkImagingHybrid-8.2.libvtkImagingMath-8.2.libvtkImagingMorphological-8.2.libvtkImagingSources-8.2.libvtkImagingStatistics-8.2.libvtkImagingStencil-8.2.libvtkInfovisCore-8.2.libvtkInfovisLayout-8.2.libvtkInteractionImage-8.2.libvtkInteractionStyle-8.2.libvtkInteractionWidgets-8.2.libvtkIOAMR-8.2.libvtkIOAsynchronous-8.2.libvtkIOCityGML-8.2.libvtkIOCore-8.2.libvtkIOEnSight-8.2.libvtkIOExodus-8.2.libvtkIOExport-8.2.libvtkIOExportOpenGL2-8.2.libvtkIOExportPDF-8.2.libvtkIOGeometry-8.2.libvtkIOImage-8.2.libvtkIOImport-8.2.libvtkIOInfovis-8.2.libvtkIOLegacy-8.2.libvtkIOLSDyna-8.2.libvtkIOMINC-8.2.libvtkIOMovie-8.2.libvtkIONetCDF-8.2.libvtkIOParallel-8.2.libvtkIOParallelXML-8.2.libvtkIOPLY-8.2.libvtkIOSegY-8.2.libvtkIOSQL-8.2.libvtkIOTecplotTable-8.2.libvtkIOVeraOut-8.2.libvtkIOVideo-8.2.libvtkIOXML-8.2.libvtkIOXMLParser-8.2.libvtkjpeg-8.2.libvtkjsoncpp-8.2.libvtklibharu-8.2.libvtklibxml2-8.2.libvtklz4-8.2.libvtklzma-8.2.libvtkmetaio-8.2.libvtkNetCDF-8.2.libvtkogg-8.2.libvtkParallelCore-8.2.libvtkpng-8.2.libvtkproj-8.2.libvtkpugixml-8.2.libvtkRenderingAnnotation-8.2.libvtkRenderingContext2D-8.2.libvtkRenderingContextOpenGL2-8.2.libvtkRenderingCore-8.2.libvtkRenderingExternal-8.2.libvtkRenderingFreeType-8.2.libvtkRenderingGL2PSOpenGL2-8.2.libvtkRenderingImage-8.2.libvtkRenderingLabel-8.2.libvtkRenderingLOD-8.2.libvtkRenderingOpenGL2-8.2.libvtkRenderingVolume-8.2.libvtkRenderingVolumeOpenGL2-8.2.libvtksqlite-8.2.libvtksys-8.2.libvtktheora-8.2.libvtktiff-8.2.libvtkverdict-8.2.libvtkViewsContext2D-8.2.libvtkViewsCore-8.2.libvtkViewsInfovis-8.2.libvtkzlib-8.2.libflann.libflann_cpp.libflann_cpp_s.libflann_s.lib","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"PCL","slug":"PCL","permalink":"http://example.com/tags/PCL/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"PCL","slug":"PCL","permalink":"http://example.com/tags/PCL/"}]}